This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    project_description.mdc
app/
  ai-customiser/
    _components/
      ConfigureTab.tsx
      TestTab.tsx
      TrainTab.tsx
    page.tsx
  api/
    appointments/
      [id]/
        route.ts
      route.ts
    call-logs/
      route.ts
    create-query-tool/
      route.ts
    delete-tool/
      route.ts
    get-assistant-config/
      route.ts
    get-assistant-prompt/
      route.ts
    get-assistant-tools/
      route.ts
    knowledge-topics/
      [[...params]]/
        route.ts
    laine/
      book-appointment/
        route.ts
      check-availability/
        route.ts
    patients/
      route.ts
    tools/
      route.ts
    update-assistant-config/
      route.ts
    update-assistant-prompt/
      route.ts
    update-assistant-tool/
      route.ts
    update-tool/
      route.ts
    upload-kb-file/
      route.ts
    users/
      route.ts
  calendar/
    page.tsx
  call-logs/
    page.tsx
  dashboard/
    page.tsx
  patients/
    page.tsx
  tool-configuration/
    _components/
      EditToolModal.tsx
    page.tsx
  types/
    vapi.ts
  globals.css
  layout.tsx
  page.tsx
components/
  sidebar/
    index.tsx
  ui/
    accordion.tsx
    alert.tsx
    avatar.tsx
    button.tsx
    card.tsx
    dialog.tsx
    dropdown-menu.tsx
    input.tsx
    label.tsx
    select.tsx
    separator.tsx
    sheet.tsx
    sidebar.tsx
    skeleton.tsx
    table.tsx
    tabs.tsx
    textarea.tsx
    tooltip.tsx
  AppointmentDetailModal.tsx
  AppointmentFormModal.tsx
  Placeholder.tsx
  ToolListModal.tsx
hooks/
  use-mobile.ts
lib/
  prisma.ts
  utils.ts
  vapiUtils.ts
prisma/
  migrations/
    20250402023503_add_appointment_fields/
      migration.sql
    migration_lock.toml
  schema.prisma
  seed.ts
.gitignore
components.json
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: app/ai-customiser/_components/ConfigureTab.tsx
================
"use client";

import React, { useState, useEffect } from 'react';
import { Loader2, Save, AlertCircle, CheckCircle, RefreshCcw, Mic, UserCog } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Input } from "@/components/ui/input";

export interface AssistantConfig {
  name?: string;
  model?: {
    provider?: string;
    model?: string;
    messages?: Array<{ role: string; content?: string }>;
  };
  voice?: {
    provider?: string;
    voiceId?: string;
  };
}

interface ConfigureTabProps {
  initialConfig: AssistantConfig;
  assistantId: string;
}

// Simplified voice options based on client feedback
// This eliminates the need to show providers to end users
const voiceOptions = [
  { id: "Ali", name: "Ali", tier: "recommended" },
  { id: "Elliot", name: "Elliot", tier: "recommended" },
  { id: "Lily", name: "Lily", tier: "recommended" },
  { id: "Neha", name: "Neha", tier: "recommended" },
  { id: "Cole", name: "Cole", tier: "recommended" },
  { id: "Spencer", name: "Spencer", tier: "recommended" },
  { id: "Savannah", name: "Savannah", tier: "secondary" }
];

// Hidden from UI but needed for implementation
const llmProviders = ["openai", "google", "anthropic", "groq", "custom-llm", "vapi"];
const modelOptions: Record<string, string[]> = {
  openai: ["gpt-4o", "gpt-4-turbo", "gpt-3.5-turbo"],
  google: ["gemini-1.5-pro", "gemini-1.5-flash", "gemini-1.0-pro"],
  anthropic: ["claude-3-5-sonnet-20240620", "claude-3-opus-20240229"],
  groq: ["llama3-70b-8192", "mixtral-8x7b-32768"],
  "custom-llm": ["your-custom-model-name"],
  vapi: ["workflow-model"],
};

export function ConfigureTab({ initialConfig, assistantId }: ConfigureTabProps) {
  // State for editable fields
  const [assistantName, setAssistantName] = useState<string>(initialConfig.name || '');
  const [systemPrompt, setSystemPrompt] = useState<string>(
    initialConfig.model?.messages?.find(m => m.role === 'system')?.content || ''
  );
  const [voiceId, setVoiceId] = useState<string>(initialConfig.voice?.voiceId || '');
  const [llmProvider, setLlmProvider] = useState<string>(initialConfig.model?.provider || '');
  const [llmModel, setLlmModel] = useState<string>(initialConfig.model?.model || '');
  
  // Hidden state for voice provider - always use vapi but don't show to users
  const [voiceProvider, setVoiceProvider] = useState<string>(initialConfig.voice?.provider || 'vapi');

  // State for tracking initial values for reset/dirty check
  const [initialState, setInitialState] = useState(initialConfig);

  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [statusMessage, setStatusMessage] = useState<string>('');
  const [errorMessage, setErrorMessage] = useState<string>('');

  // Update initial state if initialConfig changes (e.g., parent re-fetches)
  useEffect(() => {
    setInitialState(initialConfig);
    setAssistantName(initialConfig.name || '');
    setSystemPrompt(initialConfig.model?.messages?.find(m => m.role === 'system')?.content || '');
    setVoiceProvider(initialConfig.voice?.provider || 'vapi');
    setVoiceId(initialConfig.voice?.voiceId || '');
    setLlmProvider(initialConfig.model?.provider || '');
    setLlmModel(initialConfig.model?.model || '');
  }, [initialConfig]);

  const handleSave = async () => {
    setIsSaving(true);
    setStatusMessage('');
    setErrorMessage('');
    try {
      // Construct the payload with only the fields being managed by this tab
      const updatePayload: Partial<AssistantConfig> = {
        name: assistantName,
        model: {
          // Important: Merge with existing model config to avoid overwriting other settings like tools
          ...(initialState.model || {}), // Start with existing model config
          provider: llmProvider,
          model: llmModel,
          messages: [
            // Replace only the system message, keep others if they exist
            ...(initialState.model?.messages?.filter(m => m.role !== 'system') || []),
            { role: "system", content: systemPrompt }
          ],
        },
        voice: {
          // Important: Merge with existing voice config
          ...(initialState.voice || {}),
          provider: voiceProvider, // Always set to vapi internally
          voiceId: voiceId,
        },
      };

      const response = await fetch('/api/update-assistant-config', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ assistantId, updatePayload }),
      });
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || `Failed to update assistant (status: ${response.status})`);
      }

      // Update initial state to reflect saved changes
      setInitialState(data.assistant); // Use the response data as the new initial state
      setStatusMessage('Configuration updated successfully!');

    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error saving config.';
      setErrorMessage(message);
    } finally {
      setIsSaving(false);
    }
  };

  const handleReset = () => {
    setAssistantName(initialState.name || '');
    setSystemPrompt(initialState.model?.messages?.find(m => m.role === 'system')?.content || '');
    setVoiceProvider(initialState.voice?.provider || 'vapi');
    setVoiceId(initialState.voice?.voiceId || '');
    setLlmProvider(initialState.model?.provider || '');
    setLlmModel(initialState.model?.model || '');
    setStatusMessage('Changes reverted to last saved state.');
    setErrorMessage('');
  };

  const hasChanges =
    assistantName !== (initialState.name || '') ||
    systemPrompt !== (initialState.model?.messages?.find(m => m.role === 'system')?.content || '') ||
    voiceProvider !== (initialState.voice?.provider || '') ||
    voiceId !== (initialState.voice?.voiceId || '') ||
    llmProvider !== (initialState.model?.provider || '') ||
    llmModel !== (initialState.model?.model || '');

  const currentModelOptions = modelOptions[llmProvider] || [];

  return (
    <div className="space-y-8">
      {/* Identity Section */}
      <section className="p-4 border rounded-lg bg-white dark:bg-gray-800 shadow-sm">
        <h2 className="text-xl font-semibold mb-4 flex items-center"><UserCog className="mr-2 h-5 w-5 text-gray-600 dark:text-gray-400" /> Identity & Persona</h2>
        <div className="mb-4">
          <Label htmlFor="assistantName">Assistant Name</Label>
          <Input
            id="assistantName"
            value={assistantName}
            onChange={(e) => setAssistantName(e.target.value)}
            className="mt-1"
            disabled={isSaving}
            placeholder="e.g., Laine"
          />
        </div>
        <div>
          <Label htmlFor="systemPrompt">System Prompt</Label>
          <Textarea
            id="systemPrompt"
            value={systemPrompt}
            onChange={(e) => setSystemPrompt(e.target.value)}
            rows={10}
            className="mt-1 w-full font-mono text-sm"
            placeholder="Define the assistant's role, goals, and personality..."
            disabled={isSaving}
          />
        </div>
      </section>

      {/* Voice Section - Simplified to only show voice selection */}
      <section className="p-4 border rounded-lg bg-white dark:bg-gray-800 shadow-sm">
        <h2 className="text-xl font-semibold mb-4 flex items-center"><Mic className="mr-2 h-5 w-5 text-gray-600 dark:text-gray-400" /> Voice</h2>
        <div>
          <Label htmlFor="voiceId">Voice</Label>
          <Select
            value={voiceId}
            onValueChange={setVoiceId}
            disabled={isSaving}
          >
            <SelectTrigger id="voiceId" className="mt-1 w-full">
              <SelectValue placeholder="Select a voice" />
            </SelectTrigger>
            <SelectContent>
              <div className="pb-1 pt-2 px-2 text-xs font-medium text-muted-foreground">Recommended</div>
              {voiceOptions
                .filter(voice => voice.tier === "recommended")
                .map(voice => (
                  <SelectItem key={voice.id} value={voice.id}>{voice.name}</SelectItem>
                ))
              }
              <div className="pb-1 pt-2 px-2 text-xs font-medium text-muted-foreground">Additional Options</div>
              {voiceOptions
                .filter(voice => voice.tier === "secondary")
                .map(voice => (
                  <SelectItem key={voice.id} value={voice.id}>{voice.name}</SelectItem>
                ))
              }
            </SelectContent>
          </Select>
        </div>
      </section>

      {/* Model Section - Hidden from users but maintained for api compatibility */}
      <div className="hidden">
        <div>
          <Label htmlFor="llmProvider">Provider</Label>
          <Select
            value={llmProvider}
            onValueChange={(value) => { setLlmProvider(value); setLlmModel(''); }}
            disabled={isSaving}
          >
            <SelectTrigger id="llmProvider" className="mt-1">
              <SelectValue placeholder="Select LLM provider" />
            </SelectTrigger>
            <SelectContent>
              {llmProviders.map(p => <SelectItem key={p} value={p}>{p}</SelectItem>)}
            </SelectContent>
          </Select>
        </div>
        <div>
          <Label htmlFor="llmModel">Model</Label>
          <Select
            value={llmModel}
            onValueChange={setLlmModel}
            disabled={isSaving || !llmProvider || currentModelOptions.length === 0}
          >
            <SelectTrigger id="llmModel" className="mt-1">
              <SelectValue placeholder={!llmProvider ? "Select provider first" : "Select model"} />
            </SelectTrigger>
            <SelectContent>
              {currentModelOptions.map(m => <SelectItem key={m} value={m}>{m}</SelectItem>)}
              {llmProvider && currentModelOptions.length === 0 && <SelectItem value="" disabled>No models listed for this provider</SelectItem>}
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Save/Reset Buttons and Status Messages */}
      <div className="mt-6 space-y-4">
        {statusMessage && !errorMessage && (
          <Alert>
            <CheckCircle className="h-4 w-4" />
            <AlertTitle>Success</AlertTitle>
            <AlertDescription>{statusMessage}</AlertDescription>
          </Alert>
        )}
        {errorMessage && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>Error</AlertTitle>
            <AlertDescription>{errorMessage}</AlertDescription>
          </Alert>
        )}

        <div className="flex flex-col sm:flex-row justify-end space-y-2 sm:space-y-0 sm:space-x-3">
          <Button
            variant="outline"
            onClick={handleReset}
            disabled={isSaving || !hasChanges}
          >
            <RefreshCcw className="mr-2 h-4 w-4" /> Reset Changes
          </Button>
          <Button
            onClick={handleSave}
            disabled={isSaving || !hasChanges}
          >
            {isSaving ? (
              <Loader2 className="animate-spin mr-2 h-4 w-4" />
            ) : (
              <Save className="mr-2 h-4 w-4" />
            )}
            Save Configuration
          </Button>
        </div>
      </div>
    </div>
  );
}

================
File: app/api/create-query-tool/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('VAPI_API_KEY is not set');
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    const { fileIds, toolName, kbName, kbDescription } = await request.json();

    if (!Array.isArray(fileIds) || fileIds.length === 0) {
      return NextResponse.json({ error: 'At least one fileId is required' }, { status: 400 });
    }
    if (!toolName || typeof toolName !== 'string') {
        return NextResponse.json({ error: 'toolName is required' }, { status: 400 });
    }
     if (!kbName || typeof kbName !== 'string') {
        return NextResponse.json({ error: 'kbName is required' }, { status: 400 });
    }
     if (!kbDescription || typeof kbDescription !== 'string') {
        return NextResponse.json({ error: 'kbDescription is required' }, { status: 400 });
    }

    console.log(`Creating query tool "${toolName}" with KB "${kbName}" using file IDs: ${fileIds.join(', ')}`);

    const toolPayload = {
      type: "query",
      // The 'function' object defines how the assistant *calls* the tool.
      // The 'name' here is what the assistant uses internally.
      function: {
        name: toolName, // e.g., "search_dynamic_knowledge"
        description: `Use this tool to answer questions based on the dynamically uploaded content about: ${kbDescription}`, // Help LLM know when to use it
        parameters: { // Define parameters the LLM needs to extract from the user query
          type: "object",
          properties: {
            query: {
              type: "string",
              description: "The specific question or topic the user is asking about related to the knowledge base."
            }
          },
          required: ["query"]
        }
      },
      // The 'knowledgeBases' array defines the actual data sources for the tool.
      knowledgeBases: [
        {
          provider: "google", // Currently the only supported provider for Query Tool KB
          model: "gemini-1.5-flash", // Default model for Google KB
          name: kbName, // An internal name for this specific KB source
          description: kbDescription, // Helps the assistant choose *this specific KB* if multiple are present
          fileIds: fileIds // The IDs of the files uploaded earlier
        }
        // You could add more knowledgeBase objects here if needed
      ]
      // Optional: Add server config if you want Vapi to call *your* server
      // when this tool is invoked, instead of Vapi handling the query directly.
      // server: { url: "YOUR_SERVER_ENDPOINT_FOR_QUERY_TOOL" }
    };

    const response = await fetch('https://api.vapi.ai/tool', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(toolPayload),
    });

    const responseData = await response.json();

    if (!response.ok) {
      console.error(`Vapi API Error (Create Tool): ${response.status}`, responseData);
      return NextResponse.json({ error: `Failed to create query tool: ${responseData.message || response.statusText}` }, { status: response.status });
    }

    console.log(`Successfully created query tool "${toolName}". Tool ID: ${responseData.id}`);
    return NextResponse.json({ toolId: responseData.id });

  } catch (error) {
    console.error('Error in /api/create-query-tool:', error);
    const message = error instanceof Error ? error.message : 'Unknown error during tool creation';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/delete-tool/route.ts
================
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  // Basic validation check
  if (!VAPI_API_KEY) {
    console.error("VAPI_API_KEY is not set in environment variables.");
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    // Parse request body
    const body = await request.json() as { toolId: string };
    const { toolId } = body;

    // Validate required fields
    if (!toolId) {
      return NextResponse.json({ error: 'Missing required field: toolId' }, { status: 400 });
    }

    console.log(`[delete-tool] Deleting tool ${toolId}`);

    // Initialize Vapi Client
    const vapi = new VapiClient({ token: VAPI_API_KEY });

    // Delete the tool
    await vapi.tools.delete(toolId);
    
    console.log(`[delete-tool] Successfully deleted tool ${toolId}`);
    return NextResponse.json({ success: true });
  } catch (error) {
    // Log and return error
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error("[delete-tool] Error deleting tool:", errorMessage);
    return NextResponse.json({ error: 'Failed to delete tool' }, { status: 500 });
  }
}

================
File: app/api/get-assistant-config/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function GET(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('API Key missing in server environment.');
    return NextResponse.json({ error: 'Server configuration error.' }, { status: 500 });
  }

  try {
    // Get the assistant ID from the query parameters
    const url = new URL(request.url);
    const assistantId = url.searchParams.get('id');

    if (!assistantId) {
      return NextResponse.json({ error: 'assistantId is required.' }, { status: 400 });
    }

    console.log(`API: Fetching config for assistant ID: ${assistantId}`);
    const response = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Accept': 'application/json',
      },
      cache: 'no-store', // Ensure fresh data is fetched
    });

    const data = await response.json();

    if (!response.ok) {
      console.error(`API Error (Fetch Assistant): ${response.status}`, data);
      return NextResponse.json({ error: `Failed to fetch assistant: ${data.message || response.statusText}` }, { status: response.status });
    }

    console.log("API: Successfully fetched assistant config.");
    return NextResponse.json(data);

  } catch (error) {
    console.error('API Error in /api/get-assistant-config:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/get-assistant-prompt/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;
const VAPI_ASSISTANT_ID = process.env.VAPI_ASSISTANT_ID;

// Define interface for message object
interface VapiMessage {
  role: string;
  content: string;
}

export async function GET() {
  if (!VAPI_API_KEY || !VAPI_ASSISTANT_ID) {
    console.error('API Key or Assistant ID is missing in server environment variables.');
    return NextResponse.json({ error: 'Server configuration error.' }, { status: 500 });
  }

  try {
    console.log(`Fetching assistant configuration for ID: ${VAPI_ASSISTANT_ID}`);
    const response = await fetch(`https://api.vapi.ai/assistant/${VAPI_ASSISTANT_ID}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      console.error(`Vapi API Error (Fetch Assistant): ${response.status}`, data);
      return NextResponse.json({ error: `Failed to fetch assistant: ${data.message || response.statusText}` }, { status: response.status });
    }

    // Find the system prompt within the model messages
    let systemPromptContent = '';
    if (data.model && Array.isArray(data.model.messages)) {
      const systemMessage = data.model.messages.find((msg: VapiMessage) => msg.role === 'system');
      if (systemMessage) {
        systemPromptContent = systemMessage.content || '';
      }
    }

    console.log("Successfully fetched system prompt.");
    return NextResponse.json({ prompt: systemPromptContent });

  } catch (error) {
    console.error('Error fetching assistant prompt:', error);
    const message = error instanceof Error ? error.message : 'Unknown error occurred';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/knowledge-topics/[[...params]]/route.ts
================
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { z } from 'zod'; // For input validation
import { uploadFileToVapi, generateVapiNamesUtil, vapiFetch } from '@/lib/vapiUtils'; // Import helpers

const prisma = new PrismaClient();

// --- Logging Utility ---
function log(message: string, data?: unknown) {
    console.log(`[${new Date().toISOString()}] [knowledge-topics] ${message}`);
    if (data !== undefined) {
        console.log(JSON.stringify(data, null, 2));
    }
}

// --- CORS Headers ---
const corsHeaders = {
    'Access-Control-Allow-Origin': '*', // Adjust in production
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

// --- Input Schemas (Zod) ---
const PostTopicSchema = z.object({
    assistantId: z.string().min(1, "Assistant ID is required"),
    topicName: z.string().min(1, "Topic name is required"),
    content: z.string().min(1, "Content cannot be empty"),
});

const PutTopicSchema = z.object({
    assistantId: z.string().min(1, "Assistant ID is required"), // Often needed for verification
    topicName: z.string().min(1, "Topic name is required"),
    content: z.string().min(1, "Content cannot be empty"),
});

// --- Helper Functions ---

// --- API Route Handlers ---

// GET /api/knowledge-topics?assistantId={id}
export async function GET(request: Request) {
    log("GET request received");
    const { searchParams } = new URL(request.url);
    const assistantId = searchParams.get('assistantId');

    if (!assistantId) {
        return NextResponse.json({ error: 'Missing assistantId query parameter' }, { status: 400, headers: corsHeaders });
    }

    try {
        const topics = await prisma.knowledgeTopic.findMany({
            where: { assistantId: assistantId },
            orderBy: { createdAt: 'asc' },
        });
        log(`Found ${topics.length} topics for assistant ${assistantId}`);
        return NextResponse.json(topics, { status: 200, headers: corsHeaders });
    } catch (error) {
        log('Error fetching knowledge topics from DB', error);
        const message = error instanceof Error ? error.message : 'Failed to retrieve knowledge topics.';
        return NextResponse.json({ error: message }, { status: 500, headers: corsHeaders });
    } finally {
        await prisma.$disconnect().catch(e => log('Error disconnecting Prisma', e));
    }
}

// POST /api/knowledge-topics
export async function POST(request: Request) {
    log("POST request received");
    let assistantId: string | undefined; // Define here for use in catch/finally
    try {
        const body = await request.json();
        const validation = PostTopicSchema.safeParse(body);

        if (!validation.success) {
            log('Invalid POST request body', validation.error.errors);
            return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400, headers: corsHeaders });
        }

        // Assign assistantId after validation
        assistantId = validation.data.assistantId;
        const { topicName, content } = validation.data;
        log(`Processing POST for topic "${topicName}" for assistant ${assistantId}`);

        const { vapiFileName, vapiToolName, vapiKbName, vapiDescription } = generateVapiNamesUtil(topicName);

        let vapiFileId: string | null = null;
        let vapiToolId: string | null = null;
        let assistantUpdated = false;

        try {
            // 1. Upload File via Utility Function
            vapiFileId = await uploadFileToVapi(content, vapiFileName);
            log(`File uploaded successfully via utility: ${vapiFileId}`);

            // 2. Create Query Tool in Vapi (Correct Payload)
            log(`Creating tool ${vapiToolName} with KB ${vapiKbName}...`);
            const toolPayload = {
                type: "query",
                function: { // Define how LLM calls it
                    name: vapiToolName,
                    description: vapiDescription,
                    parameters: {
                        type: "object",
                        properties: {
                            query: {
                                type: "string",
                                description: `The specific question or topic about ${topicName.trim()} the user is asking.`
                            }
                        },
                        required: ["query"]
                    }
                },
                knowledgeBases: [{ // Define the KB source
                    provider: "google", // Ensure this matches Vapi's capability
                    model: "gemini-1.5-flash", // Ensure this matches Vapi's capability
                    name: vapiKbName,
                    description: vapiDescription,
                    fileIds: [vapiFileId],
                }],
                // messages: [ ... ] // Optional tool messages
            };
            const toolData = await vapiFetch('/tool', {
                method: 'POST',
                body: JSON.stringify(toolPayload),
            });
            vapiToolId = (toolData && typeof toolData === 'object' && 'id' in toolData && typeof toolData.id === 'string') ? toolData.id : null;
            if (!vapiToolId) throw new Error('Vapi did not return a valid tool ID after creation.');
            log(`Tool created successfully: ${vapiToolId}`);

            // 3. Update Assistant in Vapi
            log(`Attaching tool ${vapiToolId} to assistant ${assistantId}...`);
            const assistantData = await vapiFetch(`/assistant/${assistantId}`);
            let existingToolIds: string[] = [];
            if (assistantData && typeof assistantData === 'object' && 'model' in assistantData && assistantData.model && typeof assistantData.model === 'object' && 'toolIds' in assistantData.model && Array.isArray(assistantData.model.toolIds)) {
                existingToolIds = assistantData.model.toolIds.filter((id): id is string => typeof id === 'string');
            }
            const newToolIds = [...new Set([...existingToolIds, vapiToolId])];

            await vapiFetch(`/assistant/${assistantId}`, {
                method: 'PATCH',
                body: JSON.stringify({ model: { toolIds: newToolIds } }),
            });
            assistantUpdated = true;
            log(`Assistant ${assistantId} updated successfully with tool ${vapiToolId}`);

            // 4. Create KnowledgeTopic in Local DB
            log(`Saving KnowledgeTopic "${topicName}" to local DB...`);
            const newTopic = await prisma.knowledgeTopic.create({
                data: {
                    topicName: topicName.trim(),
                    content: content,
                    assistantId: assistantId,
                    vapiToolId: vapiToolId,
                    vapiFileId: vapiFileId,
                    vapiKbName: vapiKbName,
                    vapiToolName: vapiToolName,
                    vapiFileName: vapiFileName,
                    vapiDescription: vapiDescription,
                }
            });
            log('KnowledgeTopic saved to DB successfully', newTopic);

            return NextResponse.json(newTopic, { status: 201, headers: corsHeaders });

        } catch (vapiError) {
            log('Error during Vapi operations or DB save', vapiError);
            // --- Rollback Vapi Resources ---
             if (vapiToolId && assistantUpdated) {
                 log(`Attempting rollback: Detach tool ${vapiToolId} from assistant ${assistantId}`);
                 try {
                     const currentAssistantData = await vapiFetch(`/assistant/${assistantId}`);
                     let currentToolIds: string[] = [];
                      if (currentAssistantData && typeof currentAssistantData === 'object' && 'model' in currentAssistantData && currentAssistantData.model && typeof currentAssistantData.model === 'object' && 'toolIds' in currentAssistantData.model && Array.isArray(currentAssistantData.model.toolIds)) {
                         currentToolIds = currentAssistantData.model.toolIds.filter((id): id is string => typeof id === 'string');
                     }
                     const filteredToolIds = currentToolIds.filter((id: string) => id !== vapiToolId);
                     await vapiFetch(`/assistant/${assistantId}`, {
                         method: 'PATCH',
                         body: JSON.stringify({ model: { toolIds: filteredToolIds } }),
                     });
                     log(`Rollback: Tool ${vapiToolId} detached from assistant ${assistantId}`);
                 } catch (rollbackError) {
                     log(`CRITICAL: Failed to detach tool ${vapiToolId} during rollback`, rollbackError);
                 }
            }
            if (vapiToolId) {
                 log(`Attempting rollback: Delete tool ${vapiToolId}`);
                 try {
                     await vapiFetch(`/tool/${vapiToolId}`, { method: 'DELETE' });
                     log(`Rollback: Tool ${vapiToolId} deleted`);
                 } catch (rollbackError) {
                     log(`CRITICAL: Failed to delete tool ${vapiToolId} during rollback`, rollbackError);
                 }
            }
             if (vapiFileId) {
                 log(`Attempting rollback: Delete file ${vapiFileId}`);
                 try {
                     await vapiFetch(`/file/${vapiFileId}`, { method: 'DELETE' });
                     log(`Rollback: File ${vapiFileId} deleted`);
                 } catch (rollbackError) {
                     log(`CRITICAL: Failed to delete file ${vapiFileId} during rollback`, rollbackError);
                 }
            }
            const message = vapiError instanceof Error ? vapiError.message : 'Failed to create knowledge topic.';
            return NextResponse.json({ error: message }, { status: 500, headers: corsHeaders });
        }

    } catch (error) {
        log('Unhandled error in POST handler', error);
        const message = error instanceof Error ? error.message : 'An unknown server error occurred.';
        return NextResponse.json({ error: message }, { status: 500, headers: corsHeaders });
    } finally {
        await prisma.$disconnect().catch(e => log('Error disconnecting Prisma', e));
    }
}


// PUT /api/knowledge-topics/{toolId}
export async function PUT(
    request: Request,
    { params }: { params: Promise<{ params?: string[] }> }
) {
    const { params: segments } = await params;  // Await the dynamic params (Next.js 15+)
    const toolId = segments?.[0];
    log(`PUT request received for toolId: ${toolId}`);

     if (!toolId) {
        return NextResponse.json({ error: 'Missing knowledge topic ID (toolId) in URL path' }, { status: 400, headers: corsHeaders });
    }

    let assistantIdFromBody: string | undefined; // For use in catch/finally
    try {
        const body = await request.json();
        const validation = PutTopicSchema.safeParse(body);

        if (!validation.success) {
            log('Invalid PUT request body', validation.error.errors);
            return NextResponse.json({ error: 'Invalid input', details: validation.error.flatten() }, { status: 400, headers: corsHeaders });
        }

        assistantIdFromBody = validation.data.assistantId; // Assign here
        const { topicName, content } = validation.data;
        log(`Processing PUT for topic "${topicName}" (toolId: ${toolId})`);

        // 1. Fetch existing topic from DB
        const existingTopic = await prisma.knowledgeTopic.findUnique({
            where: { vapiToolId: toolId },
        });

        if (!existingTopic || !existingTopic.vapiToolId || !existingTopic.vapiFileId) {
            log(`Knowledge topic with Vapi tool ID ${toolId} not found in DB or missing Vapi IDs.`);
            return NextResponse.json({ error: 'Knowledge topic not found.' }, { status: 404, headers: corsHeaders });
        }

        // Optional: Verify assistantId matches if needed for authorization
        if (existingTopic.assistantId !== assistantIdFromBody) {
             log(`Authorization error: Assistant ID mismatch for tool ${toolId}`);
             return NextResponse.json({ error: 'Unauthorized to modify this topic.' }, { status: 403, headers: corsHeaders });
        }

        let newVapiFileId: string | null = null;
        const oldVapiFileId = existingTopic.vapiFileId;
        const names = generateVapiNamesUtil(topicName); // Use Util function

         try {
            // 2. Upload *new* File content via Utility Function
            log(`Uploading new file content ${names.vapiFileName} via utility...`);
            newVapiFileId = await uploadFileToVapi(content, names.vapiFileName);
            log(`New file uploaded successfully via utility: ${newVapiFileId}`);

             // 3. Update Vapi Tool (PATCH) - Correct Payload
             log(`Updating Vapi tool ${toolId} to use new file ${newVapiFileId}...`);
             const toolUpdatePayload = {
                 type: "query", // Type is required for PATCH on tools
                 function: { // Update function description
                     description: names.vapiDescription,
                     // IMPORTANT: Resend the *entire* function block for safety
                     name: existingTopic.vapiToolName || names.vapiToolName, // Use existing or new tool name
                     parameters: {
                         type: "object",
                         properties: { query: { type: "string", description: `The specific question or topic about ${topicName.trim()} the user is asking.` }},
                         required: ["query"]
                     }
                 },
                 knowledgeBases: [{
                     // Re-specify all required KB fields
                     provider: "google", // Assuming google provider
                     model: "gemini-1.5-flash", // Assuming this model
                     name: existingTopic.vapiKbName || names.vapiKbName, // Use existing or new KB name
                     description: names.vapiDescription, // Update description
                     fileIds: [newVapiFileId], // The crucial update
                 }],
                 // messages: [...] // Resend messages if they were part of the original tool
             };
             await vapiFetch(`/tool/${toolId}`, {
                 method: 'PATCH',
                 body: JSON.stringify(toolUpdatePayload),
             });
             log(`Vapi tool ${toolId} updated successfully.`);

             // 4. Delete *old* Vapi File
             if (oldVapiFileId) {
                 log(`Deleting old Vapi file ${oldVapiFileId}...`);
                 await vapiFetch(`/file/${oldVapiFileId}`, { method: 'DELETE' }).catch(delErr => {
                      log(`WARNING: Failed to delete old Vapi file ${oldVapiFileId}. Manual cleanup might be needed.`, delErr);
                 });
                 log(`Old Vapi file ${oldVapiFileId} deleted (or deletion attempted).`);
             }

            // 5. Update KnowledgeTopic in Local DB
            log(`Updating KnowledgeTopic ${existingTopic.id} in local DB...`);
            const updatedTopic = await prisma.knowledgeTopic.update({
                where: { id: existingTopic.id },
                data: {
                    topicName: topicName.trim(),
                    content: content,
                    vapiFileId: newVapiFileId,
                    vapiFileName: names.vapiFileName,
                    vapiDescription: names.vapiDescription,
                    vapiToolName: names.vapiToolName, // Update tool name if regenerated
                    vapiKbName: names.vapiKbName,     // Update KB name if regenerated
                }
            });
            log('KnowledgeTopic updated in DB successfully', updatedTopic);

            return NextResponse.json(updatedTopic, { status: 200, headers: corsHeaders });

        } catch (vapiError) {
            log('Error during Vapi operations or DB update', vapiError);
             // --- Rollback attempt for new file ---
             if (newVapiFileId) {
                 log(`Attempting rollback: Delete newly uploaded file ${newVapiFileId}`);
                 try {
                     await vapiFetch(`/file/${newVapiFileId}`, { method: 'DELETE' });
                     log(`Rollback: New file ${newVapiFileId} deleted`);
                 } catch (rollbackError) {
                     log(`CRITICAL: Failed to delete newly uploaded file ${newVapiFileId} during PUT rollback`, rollbackError);
                 }
             }
            const message = vapiError instanceof Error ? vapiError.message : 'Failed to update knowledge topic.';
            return NextResponse.json({ error: message }, { status: 500, headers: corsHeaders });
        }

    } catch (error) {
        log('Unhandled error in PUT handler', error);
        const message = error instanceof Error ? error.message : 'An unknown server error occurred.';
        return NextResponse.json({ error: message }, { status: 500, headers: corsHeaders });
    } finally {
        await prisma.$disconnect().catch(e => log('Error disconnecting Prisma', e));
    }
}


// DELETE /api/knowledge-topics/{toolId}
export async function DELETE(
    request: Request,
    { params }: { params: Promise<{ params?: string[] }> }
) {
     const { params: segments } = await params;  // Await the dynamic params (Next.js 15+)
     const toolId = segments?.[0];
     log(`DELETE request received for toolId: ${toolId}`);

    if (!toolId) {
        return NextResponse.json({ error: 'Missing knowledge topic ID (toolId) in URL path' }, { status: 400, headers: corsHeaders });
    }

     try {
        // 1. Fetch existing topic from DB to get Vapi IDs and assistantId
        const existingTopic = await prisma.knowledgeTopic.findUnique({
            where: { vapiToolId: toolId },
        });

        if (!existingTopic || !existingTopic.vapiToolId || !existingTopic.vapiFileId || !existingTopic.assistantId) {
            log(`Knowledge topic with Vapi tool ID ${toolId} not found in DB or missing crucial IDs.`);
            return NextResponse.json({ error: 'Knowledge topic not found.' }, { status: 404, headers: corsHeaders });
        }

        const { vapiToolId, vapiFileId, assistantId } = existingTopic;
        log(`Found topic in DB. Proceeding with deletion for assistant ${assistantId}, tool ${vapiToolId}, file ${vapiFileId}`);

        // --- Delete Vapi Resources (Best effort, log errors) ---
        const vapiErrors: string[] = [];

        // 2. Detach Tool from Assistant
        try {
            log(`Detaching tool ${vapiToolId} from assistant ${assistantId}...`);
            const assistantData = await vapiFetch(`/assistant/${assistantId}`);
            let currentToolIds: string[] = [];
             if (assistantData && typeof assistantData === 'object' && 'model' in assistantData && assistantData.model && typeof assistantData.model === 'object' && 'toolIds' in assistantData.model && Array.isArray(assistantData.model.toolIds)) {
                 currentToolIds = assistantData.model.toolIds.filter((id): id is string => typeof id === 'string');
            }
            if (currentToolIds.includes(vapiToolId)) {
                const filteredToolIds = currentToolIds.filter((id: string) => id !== vapiToolId);
                 await vapiFetch(`/assistant/${assistantId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ model: { toolIds: filteredToolIds } }),
                });
                log(`Tool ${vapiToolId} detached successfully.`);
            } else {
                 log(`Tool ${vapiToolId} was already detached or not found on assistant ${assistantId}.`);
            }
        } catch (error) {
             const msg = `Failed to detach tool ${vapiToolId} from assistant ${assistantId}: ${error instanceof Error ? error.message : error}`;
             log(msg);
             vapiErrors.push(msg);
        }

        // 3. Delete Tool
        try {
            log(`Deleting tool ${vapiToolId}...`);
            await vapiFetch(`/tool/${vapiToolId}`, { method: 'DELETE' });
            log(`Tool ${vapiToolId} deleted successfully.`);
        } catch (error) {
             const msg = `Failed to delete tool ${vapiToolId}: ${error instanceof Error ? error.message : error}`;
             log(msg);
             vapiErrors.push(msg);
        }

        // 4. Delete File
        try {
            log(`Deleting file ${vapiFileId}...`);
            await vapiFetch(`/file/${vapiFileId}`, { method: 'DELETE' });
            log(`File ${vapiFileId} deleted successfully.`);
        } catch (error) {
             const msg = `Failed to delete file ${vapiFileId}: ${error instanceof Error ? error.message : error}`;
             log(msg);
             vapiErrors.push(msg);
        }

        // 5. Delete from Local DB
        log(`Deleting KnowledgeTopic ${existingTopic.id} from local DB...`);
        await prisma.knowledgeTopic.delete({
            where: { id: existingTopic.id },
        });
        log('KnowledgeTopic deleted from DB successfully.');

        if (vapiErrors.length > 0) {
             log('DELETE completed with Vapi errors. Local DB record deleted.', vapiErrors);
             // Return 200 with message instead of 204
             return NextResponse.json({ message: "Knowledge topic deleted from database. Some Vapi resources might require manual cleanup.", details: vapiErrors }, { status: 200, headers: corsHeaders });
        }

        log(`DELETE completed successfully for tool ${toolId}.`);
        return new NextResponse(null, { status: 204, headers: corsHeaders }); // No content on successful delete

    } catch (error) {
        log('Unhandled error in DELETE handler', error);
        const message = error instanceof Error ? error.message : 'An unknown server error occurred while deleting the knowledge topic.';
        return NextResponse.json({ error: message }, { status: 500, headers: corsHeaders });
    } finally {
        await prisma.$disconnect().catch(e => log('Error disconnecting Prisma', e));
    }
}


// Handle CORS preflight OPTIONS request
export async function OPTIONS() {
  return new NextResponse(null, { status: 204, headers: corsHeaders });
}

================
File: app/api/laine/check-availability/route.ts
================
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Simple logging utility
function log(message: string, data?: Record<string, unknown>) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${message}`, data ? JSON.stringify(data, null, 2) : '');
}

// Define CORS headers for cross-origin requests
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

// Day of week mapping for date calculations
const DAYS_OF_WEEK = [
  'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
];

// Helper to find the next occurrence of a day of the week
function getNextDayOfWeek(dayName: string, fromDate = new Date()): Date {
  const targetDay = DAYS_OF_WEEK.findIndex(
    day => day.toLowerCase() === dayName.toLowerCase()
  );
  
  if (targetDay === -1) return fromDate; // Invalid day name
  
  const today = fromDate.getDay();
  const daysToAdd = (targetDay + 7 - today) % 7;
  
  const result = new Date(fromDate);
  result.setDate(result.getDate() + (daysToAdd === 0 ? 7 : daysToAdd));
  return result;
}

// More specific types for arguments
type FunctionArguments = {
  startDate?: string;
  [key: string]: unknown;
};

// Type for possible request body formats
type RequestBody = {
  message?: {
    toolCalls?: Array<{
      id: string;
      function?: {
        name?: string;
        arguments?: string | Record<string, unknown>;
      };
    }>;
    toolCallList?: Array<{
      id: string;
      function?: {
        name?: string;
        arguments?: string | Record<string, unknown>;
      };
    }>;
  };
  tool_call_id?: string;
  parameters?: { startDate?: string };
  toolCallId?: string;
  arguments?: string | Record<string, unknown>;
  toolCalls?: Array<{
    id: string;
    function?: {
      name?: string;
      arguments?: string | Record<string, unknown>;
    };
  }>;
};

// Process date to ensure it's valid and in the future
function processRequestDate(dateString: string): Date {
  const currentTime = new Date();
  
  // Create a date object from the string
  const parsedDate = new Date(dateString);
  
  // Check if date string is a valid ISO format date
  if (!Number.isNaN(parsedDate.getTime())) {
    // Extract the day of week from the parsed date
    const dayOfWeek = DAYS_OF_WEEK[parsedDate.getDay()];
    
    log('Parsed date information', {
      originalDate: dateString,
      parsedDate: parsedDate.toISOString(),
      dayOfWeek
    });
    
    // Always use the NEXT occurrence of that day of week from today
    const correctDayOfWeekDate = getNextDayOfWeek(dayOfWeek, currentTime);
    
    // Keep the time from the original parsed date
    correctDayOfWeekDate.setHours(parsedDate.getHours());
    correctDayOfWeekDate.setMinutes(parsedDate.getMinutes());
    correctDayOfWeekDate.setSeconds(parsedDate.getSeconds());
    
    log('Corrected to next occurrence of day of week', {
      originalDate: dateString,
      correctedDate: correctDayOfWeekDate.toISOString(),
      dayOfWeek
    });
    
    return correctDayOfWeekDate;
  }
  
  // If we get here, the date string was not valid ISO format
  // Try to extract day name and time if string contains day reference
  const dayPatterns = [
    { day: 'monday', regex: /\b(mon|monday)\b/i },
    { day: 'tuesday', regex: /\b(tue|tues|tuesday)\b/i },
    { day: 'wednesday', regex: /\b(wed|weds|wednesday)\b/i },
    { day: 'thursday', regex: /\b(thu|thur|thurs|thursday)\b/i },
    { day: 'friday', regex: /\b(fri|friday)\b/i },
    { day: 'saturday', regex: /\b(sat|saturday)\b/i },
    { day: 'sunday', regex: /\b(sun|sunday)\b/i },
  ];
  
  // Check if string contains day reference
  for (const { day, regex } of dayPatterns) {
    if (regex.test(dateString)) {
      // Extract time if available (assuming format like "3pm" or "3:00pm")
      const timeMatch = dateString.match(/(\d{1,2})(?::(\d{2}))?(?:\s*)(am|pm)/i);
      
      const nextDayDate = getNextDayOfWeek(day, currentTime);
      
      // If time was extracted, set it
      if (timeMatch) {
        const hours = Number.parseInt(timeMatch[1], 10);
        const minutes = timeMatch[2] ? Number.parseInt(timeMatch[2], 10) : 0;
        const isPM = timeMatch[3].toLowerCase() === 'pm';
        
        // Convert to 24-hour format
        const adjustedHours = isPM && hours < 12 
          ? hours + 12 
          : (!isPM && hours === 12 ? 0 : hours);
        
        nextDayDate.setHours(adjustedHours, minutes, 0, 0);
      } else {
        // Default to 3PM if no time specified
        nextDayDate.setHours(15, 0, 0, 0);
      }
      
      log('Extracted day reference and created date', {
        originalText: dateString,
        extractedDay: day,
        extractedTime: timeMatch ? `${timeMatch[1]}:${timeMatch[2] || '00'} ${timeMatch[3]}` : 'default 3:00 PM',
        resultDate: nextDayDate.toISOString()
      });
      
      return nextDayDate;
    }
  }
  
  // For demo purposes, use tomorrow at 3:00 PM as fallback
  log('Could not parse date reference, using tomorrow at 3PM as fallback', { 
    originalDate: dateString
  });
  
  const fallbackDate = new Date(currentTime);
  fallbackDate.setDate(fallbackDate.getDate() + 1);
  fallbackDate.setHours(15, 0, 0, 0); // 3:00 PM
  return fallbackDate;
}

// Get current date info for debugging and reference
function getCurrentDateInfo(): Record<string, string> {
  const now = new Date();
  return {
    currentDateTime: now.toISOString(),
    currentDateUTC: now.toUTCString(),
    currentDateLocale: now.toLocaleString(),
    currentDayOfWeek: DAYS_OF_WEEK[now.getDay()],
    nextWednesday: getNextDayOfWeek('wednesday', now).toISOString(),
  };
}

export async function POST(request: Request) {
  log('Received check-availability request');
  log('Current date info', getCurrentDateInfo());
  
  // Handle preflight request
  if (request.method === 'OPTIONS') {
    return new NextResponse(null, { headers: corsHeaders });
  }

  let reqBody: RequestBody = {}; // Define here to access in catch block
  
  try {
    reqBody = await request.json();
    log('Request body', reqBody);

    // Extract toolCallId and parameters from different possible structures
    let toolCallId = '';
    let startDate = '';
    
    // Handle nested message format from VAPI
    if (reqBody.message?.toolCalls && reqBody.message.toolCalls.length > 0) {
      const toolCall = reqBody.message.toolCalls[0];
      toolCallId = toolCall.id;
      
      if (typeof toolCall.function?.arguments === 'string') {
        try {
          const args = JSON.parse(toolCall.function.arguments) as FunctionArguments;
          startDate = args.startDate || '';
        } catch (e) {
          log('Error parsing tool call arguments', { error: e });
        }
      } else if (toolCall.function?.arguments) {
        const args = toolCall.function.arguments as Record<string, unknown>;
        startDate = (args.startDate as string) || '';
      }
    }
    // Handle nested message with toolCallList format
    else if (reqBody.message?.toolCallList && reqBody.message.toolCallList.length > 0) {
      const toolCall = reqBody.message.toolCallList[0];
      toolCallId = toolCall.id;
      
      if (typeof toolCall.function?.arguments === 'string') {
        try {
          const args = JSON.parse(toolCall.function.arguments) as FunctionArguments;
          startDate = args.startDate || '';
        } catch (e) {
          log('Error parsing tool call arguments', { error: e });
        }
      } else if (toolCall.function?.arguments) {
        const args = toolCall.function.arguments as Record<string, unknown>;
        startDate = (args.startDate as string) || '';
      }
    }
    // Handle direct VAPI format
    else if (reqBody.tool_call_id) {
      toolCallId = reqBody.tool_call_id;
      startDate = reqBody.parameters?.startDate || '';
    } 
    // Handle OpenAI format (from VAPI proxy)
    else if (reqBody.toolCallId) {
      toolCallId = reqBody.toolCallId;
      
      if (typeof reqBody.arguments === 'string') {
        try {
          const args = JSON.parse(reqBody.arguments) as FunctionArguments;
          startDate = args.startDate || '';
        } catch (e) {
          log('Error parsing arguments', { error: e });
        }
      } else if (reqBody.arguments) {
        const args = reqBody.arguments as Record<string, unknown>;
        startDate = (args.startDate as string) || '';
      }
    } 
    // Handle array format from VAPI
    else if (Array.isArray(reqBody.toolCalls) && reqBody.toolCalls.length > 0) {
      const toolCall = reqBody.toolCalls[0];
      toolCallId = toolCall.id;
      
      if (typeof toolCall.function?.arguments === 'string') {
        try {
          const args = JSON.parse(toolCall.function.arguments) as FunctionArguments;
          startDate = args.startDate || '';
        } catch (e) {
          log('Error parsing tool call arguments', { error: e });
        }
      } else if (toolCall.function?.arguments) {
        const args = toolCall.function.arguments as Record<string, unknown>;
        startDate = (args.startDate as string) || '';
      }
    }
    
    // For debugging, log the extracted parameters
    log('Extracted parameters', { toolCallId, startDate });
    
    if (!startDate) {
      log('No start date provided in request');
      return NextResponse.json(
        { 
          results: [{
            toolCallId: toolCallId,
            result: 'Start date is required'
          }]
        }, 
        { 
          status: 400,
          headers: corsHeaders 
        }
      );
    }

    log('Checking availability for date', { startDate });
    
    // Process the date to ensure it's valid and in the future
    const requestedTime = processRequestDate(startDate);
    
    // Query appointments from database
    const appointments = await prisma.appointment.findMany({
      select: {
        id: true,
        date: true,
        patient: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
      orderBy: {
        date: 'asc',
      },
    });
    
    log('Retrieved appointments', { count: appointments.length });
    
    // Format the requested time for display
    const formattedTime = requestedTime.toLocaleString('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      hour12: true
    });
    
    // Find if there's a conflicting appointment
    const conflictingAppointment = appointments.find(appointment => {
      const appointmentTime = new Date(appointment.date);
      const timeDiffMs = Math.abs(appointmentTime.getTime() - requestedTime.getTime());
      // Consider appointments within 30 minutes as conflicting
      return timeDiffMs < 30 * 60 * 1000;
    });
    
    // Generate alternative times for unavailable slots
    function getAlternativeTimes(baseTime: Date): string[] {
      const alternatives = [];
      
      // Next day, same time
      const nextDay = new Date(baseTime);
      nextDay.setDate(nextDay.getDate() + 1);
      alternatives.push(nextDay.toLocaleString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        hour12: true
      }));
      
      // Same day, 2 hours later
      const laterTime = new Date(baseTime);
      laterTime.setHours(laterTime.getHours() + 2);
      alternatives.push(laterTime.toLocaleString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        hour12: true
      }));
      
      return alternatives;
    }
    
    let message = '';
    if (conflictingAppointment) {
      const alternatives = getAlternativeTimes(requestedTime);
      message = `No ${formattedTime} is not available, here are ${alternatives[0]} and ${alternatives[1]}`;
    } else {
      message = `Yes ${formattedTime} is available`;
    }
    
    // Format response according to Vapi docs - simplified to exactly match the docs
    const response = {
      results: [{
        toolCallId: toolCallId,
        result: message
      }]
    };
    
    // Return the result
    log('Sending response', response);
    return NextResponse.json(
      response,
      { headers: corsHeaders }
    );
    
  } catch (error) {
    // Log the error and return error response
    log('Error checking availability', error as Record<string, unknown>);
    
    const toolCallId = reqBody?.tool_call_id || '';
    const errorMessage = 'error';
    
    return NextResponse.json(
      {
        results: [{
          toolCallId: toolCallId,
          result: errorMessage
        }]
      },
      { 
        status: 500,
        headers: corsHeaders 
      }
    );
  }
}

export async function OPTIONS() {
  return new NextResponse(null, {
    headers: corsHeaders,
  });
}

================
File: app/api/tools/route.ts
================
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';
import type { ToolInfo } from '@/app/types/vapi';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function GET() {
  // Basic validation check
  if (!VAPI_API_KEY) {
    console.error("VAPI_API_KEY is not set in environment variables.");
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    // Initialize Vapi Client
    const vapi = new VapiClient({ token: VAPI_API_KEY });

    // Fetch all tools for the organization
    console.log("[tools] Fetching all tools for the organization");
    const tools = await vapi.tools.list();

    if (!tools || !Array.isArray(tools)) {
      console.log("[tools] No tools found or invalid response format");
      // Return empty array if no tools found
      return NextResponse.json({ tools: [] });
    }

    // Transform tools to consistent format
    const formattedTools: ToolInfo[] = tools.map(tool => {
      // Cast the tool to appropriate shape
      const typedTool = tool as unknown as Record<string, unknown>;

      return {
        id: typedTool.id as string | undefined,
        name: ((typedTool.function as Record<string, unknown> | undefined)?.name as string) || typedTool.type as string,
        description: ((typedTool.function as Record<string, unknown> | undefined)?.description as string) || 
                     (typedTool.description as string) || 
                     `A ${typedTool.type as string} tool.`,
        type: typedTool.type as string,
        function: typedTool.function as {
          name?: string;
          description?: string;
          parameters?: Record<string, unknown>;
        } | undefined,
        destinations: typedTool.destinations as string[] | undefined,
        knowledgeBases: typedTool.knowledgeBases as string[] | undefined
      };
    });

    console.log(`[tools] Successfully fetched ${formattedTools.length} tools`);
    return NextResponse.json({ tools: formattedTools });
  } catch (error) {
    // Log and return error
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error("[tools] Error fetching tools:", errorMessage);
    return NextResponse.json({ error: 'Failed to fetch tools' }, { status: 500 });
  }
}

================
File: app/api/update-assistant-config/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('API Key missing in server environment.');
    return NextResponse.json({ error: 'Server configuration error.' }, { status: 500 });
  }

  try {
    const { assistantId, updatePayload } = await request.json();

    if (!assistantId || typeof assistantId !== 'string') {
      return NextResponse.json({ error: 'assistantId is required.' }, { status: 400 });
    }
    if (!updatePayload || typeof updatePayload !== 'object') {
      return NextResponse.json({ error: 'updatePayload object is required.' }, { status: 400 });
    }

    console.log(`API: Updating config for assistant ${assistantId}...`);

    const updateResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updatePayload),
    });

    const responseData = await updateResponse.json();

    if (!updateResponse.ok) {
      console.error(`API Error (Update Assistant): ${updateResponse.status}`, responseData);
      return NextResponse.json({ error: `Failed to update assistant: ${responseData.message || updateResponse.statusText}` }, { status: updateResponse.status });
    }

    console.log(`API: Successfully updated assistant ${assistantId}.`);
    return NextResponse.json({ success: true, assistant: responseData });

  } catch (error) {
    console.error('API Error in /api/update-assistant-config:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/update-assistant-prompt/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;
// Note: We get assistantId from the request body now, but keep VAPI_ASSISTANT_ID for potential fallback or validation if needed.
// const VAPI_ASSISTANT_ID = process.env.VAPI_ASSISTANT_ID;

// Define interface for message object
interface VapiMessage {
  role: string;
  content: string;
}

export async function POST(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('VAPI_API_KEY is not set');
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    const { assistantId, newPrompt } = await request.json();

    if (!assistantId || typeof assistantId !== 'string') {
      return NextResponse.json({ error: 'assistantId is required in the request body' }, { status: 400 });
    }
    if (typeof newPrompt !== 'string') { // Allow empty string but require the key
      return NextResponse.json({ error: 'newPrompt (string) is required in the request body' }, { status: 400 });
    }

    console.log(`Fetching current config for assistant ${assistantId} before updating prompt...`);

    // --- 1. Fetch current assistant config ---
    const fetchResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'GET',
      headers: { 'Authorization': `Bearer ${VAPI_API_KEY}` },
    });

    if (!fetchResponse.ok) {
      const errorBody = await fetchResponse.text();
      console.error(`Failed to fetch assistant ${assistantId}. Status: ${fetchResponse.status}, Body: ${errorBody}`);
      return NextResponse.json({ error: `Vapi API Error: Failed to fetch assistant. Status: ${fetchResponse.status}`, details: errorBody }, { status: fetchResponse.status });
    }
    const currentAssistant = await fetchResponse.json();
    console.log(`Successfully fetched current configuration for assistant ${assistantId}.`);

    // --- 2. Prepare PATCH payload ---
    // Ensure model and messages array exist, create if necessary
    const currentModel = currentAssistant.model || { provider: 'openai', model: 'gpt-4o', messages: [] }; // Provide defaults
    const currentMessages = Array.isArray(currentModel.messages) ? currentModel.messages : [];

    let systemPromptFound = false;
    const updatedMessages = currentMessages.map((msg: VapiMessage) => {
      if (msg.role === 'system') {
        systemPromptFound = true;
        // Update the content of the existing system prompt
        return { ...msg, content: newPrompt };
      }
      return msg; // Keep other messages as they are
    });

    // If no system prompt was found, add a new one
    if (!systemPromptFound) {
      updatedMessages.unshift({ role: 'system', content: newPrompt }); // Add to the beginning
    }

    const updatePayload = {
      model: {
        ...currentModel, // Keep other model settings (provider, model name, tools, etc.)
        messages: updatedMessages, // Set the updated messages array
      },
      // Include other top-level fields from currentAssistant if you want to ensure they aren't reset
      // Example: name: currentAssistant.name, voice: currentAssistant.voice, etc.
      // However, PATCH should ideally only update the specified 'model' object here.
    };

    console.log(`Updating assistant ${assistantId} with new system prompt...`);

    // --- 3. Send PATCH request ---
    const updateResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updatePayload),
    });

    const responseData = await updateResponse.json();

    if (!updateResponse.ok) {
      console.error(`Vapi API Error (Update Assistant ${assistantId}): ${updateResponse.status}`, responseData);
      return NextResponse.json({ error: `Failed to update assistant: ${responseData.message || updateResponse.statusText}` }, { status: updateResponse.status });
    }

    console.log(`Successfully updated assistant ${assistantId}.`);
    return NextResponse.json({ success: true, assistant: responseData });

  } catch (error) {
    console.error('Error in /api/update-assistant-prompt:', error);
    const message = error instanceof Error ? error.message : 'Unknown error during prompt update';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/update-tool/route.ts
================
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';
import type { ToolUpdatePayload } from '@/app/types/vapi';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  // Basic validation check
  if (!VAPI_API_KEY) {
    console.error("VAPI_API_KEY is not set in environment variables.");
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    // Parse request body
    const body = await request.json() as { updatePayload: ToolUpdatePayload };
    const { updatePayload } = body;

    // Validate required fields
    if (!updatePayload || !updatePayload.id || !updatePayload.type) {
      return NextResponse.json({ 
        error: 'Missing required fields: toolId and type are required' 
      }, { status: 400 });
    }

    const { id: toolId, ...toolData } = updatePayload;
    console.log(`[update-tool] Updating tool ${toolId} with data:`, toolData);

    // Initialize Vapi Client
    const vapi = new VapiClient({ token: VAPI_API_KEY });

    // Update the tool
    // Use type assertion to bypass TypeScript checking since we know our data structure is valid
    // for Vapi's API but TypeScript definitions might be stricter
    const updatedTool = await vapi.tools.update(toolId, toolData as any);
    
    if (!updatedTool) {
      console.log(`[update-tool] Failed to update tool ${toolId}`);
      return NextResponse.json({ error: 'Failed to update tool' }, { status: 500 });
    }

    console.log(`[update-tool] Successfully updated tool ${toolId}`);
    return NextResponse.json({ success: true, tool: updatedTool });
  } catch (error) {
    // Log and return error
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error("[update-tool] Error updating tool:", errorMessage);
    return NextResponse.json({ error: 'Failed to update tool' }, { status: 500 });
  }
}

================
File: app/api/upload-kb-file/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('VAPI_API_KEY is not set');
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    const { content, filename } = await request.json();

    if (!content || typeof content !== 'string' || content.trim() === '') {
      return NextResponse.json({ error: 'File content cannot be empty' }, { status: 400 });
    }
    if (!filename || typeof filename !== 'string') {
        return NextResponse.json({ error: 'Filename is required' }, { status: 400 });
    }

    console.log(`Received request to upload file: ${filename}`);

    // Create a Blob from the text content
    const blob = new Blob([content], { type: 'text/plain' });

    // Create FormData to send the Blob as a file
    const formData = new FormData();
    formData.append('file', blob, filename); // Vapi expects the field name 'file'

    console.log(`Uploading ${filename} to Vapi...`);

    const response = await fetch('https://api.vapi.ai/file', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        // Content-Type is set automatically by fetch when using FormData
      },
      body: formData,
    });

    const responseData = await response.json();

    if (!response.ok) {
      console.error(`Vapi API Error (Upload File ${filename}): ${response.status}`, responseData);
      return NextResponse.json({ error: `Failed to upload file to Vapi: ${responseData.message || response.statusText}` }, { status: response.status });
    }

    console.log(`Successfully uploaded ${filename}. File ID: ${responseData.id}`);
    return NextResponse.json({ fileId: responseData.id });

  } catch (error) {
    console.error('Error in /api/upload-kb-file:', error);
    const message = error instanceof Error ? error.message : 'Unknown error during file upload';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/dashboard/page.tsx
================
"use client"

import { Bell, Search } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"

export default function DashboardPage() {
  return (
    <div className="flex flex-col p-6">
      <div className="flex flex-col space-y-4 md:flex-row md:items-center md:justify-between md:space-y-0">
        <h1 className="text-2xl font-bold">Dashboard</h1>
        <div className="flex items-center space-x-2">
          <div className="relative">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              type="search"
              placeholder="Search..."
              className="w-full rounded-md bg-background pl-8 md:w-[200px] lg:w-[300px]"
            />
          </div>
          <div className="flex h-9 w-9 items-center justify-center">
            <div className="relative">
              <div className="h-2 w-2 rounded-full bg-green-500 ring-2 ring-green-500/25 animate-pulse" />
            </div>
          </div>
          <Button variant="ghost" size="icon">
            <Bell className="h-5 w-5" />
            <span className="sr-only">Notifications</span>
          </Button>
        </div>
      </div>
      <div className="mt-8">
        {/* Dashboard content will be added here */}
      </div>
    </div>
  )
}

================
File: app/tool-configuration/_components/EditToolModal.tsx
================
"use client";

import { useState, useEffect } from "react";
import { Sheet, SheetContent, SheetHeader, SheetTitle } from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import type { ToolInfo, ToolUpdatePayload } from "@/app/types/vapi";

interface EditToolModalProps {
  tool: ToolInfo | null;
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
  onSave: (updatePayload: ToolUpdatePayload) => Promise<void>;
  isLoading: boolean;
}

export default function EditToolModal({
  tool,
  isOpen,
  onOpenChange,
  onSave,
  isLoading,
}: EditToolModalProps) {
  const [name, setName] = useState<string>(tool?.name || "");
  const [description, setDescription] = useState<string>(tool?.description || "");

  // Reset form when tool changes
  useEffect(() => {
    if (tool) {
      setName(tool.name || "");
      setDescription(tool.description || "");
    }
  }, [tool]);

  const handleSave = async () => {
    if (!tool) return;

    // Create update payload - always include the type as it's required by Vapi
    const updatePayload: ToolUpdatePayload = {
      id: tool.id as string,
      type: tool.type,
      name,
      description,
    };

    // If it's a function tool, we need to update the function property
    if (tool.type === "function" && tool.function) {
      updatePayload.function = {
        ...tool.function,
        name,
        description,
      };
    }

    await onSave(updatePayload);
  };

  return (
    <Sheet open={isOpen} onOpenChange={onOpenChange}>
      <SheetContent className="sm:max-w-md">
        <SheetHeader>
          <SheetTitle>Edit Tool</SheetTitle>
        </SheetHeader>
        <div className="mt-6 space-y-4">
          <div className="space-y-2">
            <div className="text-sm font-medium">Tool Type</div>
            <div className="px-3 py-2 border rounded-md bg-muted/50">
              {tool?.type}
            </div>
          </div>
          
          <div className="space-y-2">
            <label htmlFor="name" className="text-sm font-medium">Name</label>
            <Input
              id="name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="Tool name"
              disabled={isLoading}
            />
          </div>
          
          <div className="space-y-2">
            <label htmlFor="description" className="text-sm font-medium">Description</label>
            <Textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Tool description"
              disabled={isLoading}
            />
          </div>

          <div className="flex items-center justify-end gap-2 pt-4">
            <Button
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isLoading}
            >
              Cancel
            </Button>
            <Button onClick={handleSave} disabled={isLoading}>
              {isLoading ? "Saving..." : "Save Changes"}
            </Button>
          </div>
        </div>
      </SheetContent>
    </Sheet>
  );
}

================
File: app/tool-configuration/page.tsx
================
"use client";

import { useState, useEffect } from "react";
import { Table, TableHeader, TableRow, TableHead, TableBody, TableCell } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { AlertCircle, PencilIcon, Trash2Icon, Loader2 } from "lucide-react";
import type { ToolInfo, ToolUpdatePayload } from "@/app/types/vapi";
import EditToolModal from "./_components/EditToolModal";
import { Alert } from "@/components/ui/alert";

export default function ToolConfigurationPage() {
  const [tools, setTools] = useState<ToolInfo[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [editingTool, setEditingTool] = useState<ToolInfo | null>(null);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [isDeleting, setIsDeleting] = useState<string | null>(null);

  // Fetch tools on component mount
  useEffect(() => {
    fetchTools();
  }, []);

  const fetchTools = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const response = await fetch("/api/tools");
      
      if (!response.ok) {
        throw new Error(`Error fetching tools: ${response.statusText}`);
      }
      
      const data = await response.json();
      setTools(data.tools || []);
    } catch (err) {
      console.error("Failed to fetch tools:", err);
      setError("Failed to load tools. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  const handleEditTool = (tool: ToolInfo) => {
    setEditingTool(tool);
    setIsEditModalOpen(true);
  };

  const handleSaveTool = async (updatePayload: ToolUpdatePayload) => {
    try {
      setIsSaving(true);
      setError(null);
      
      const response = await fetch("/api/update-tool", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ updatePayload }),
      });
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || `Error updating tool: ${response.statusText}`);
      }
      
      // Update the tool in the local state
      setTools(prevTools => 
        prevTools.map(tool => 
          tool.id === updatePayload.id 
            ? { ...tool, name: updatePayload.name || tool.name, description: updatePayload.description || tool.description }
            : tool
        )
      );
      
      // Close the modal
      setIsEditModalOpen(false);
      setEditingTool(null);
    } catch (err) {
      console.error("Failed to update tool:", err);
      setError(err instanceof Error ? err.message : "Failed to update tool");
    } finally {
      setIsSaving(false);
    }
  };

  const handleDeleteTool = async (toolId: string) => {
    // Confirm before deleting
    if (!window.confirm("Are you sure you want to delete this tool? This action cannot be undone.")) {
      return;
    }
    
    try {
      setIsDeleting(toolId);
      setError(null);
      
      const response = await fetch("/api/delete-tool", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ toolId }),
      });
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || `Error deleting tool: ${response.statusText}`);
      }
      
      // Remove the tool from the local state
      setTools(prevTools => prevTools.filter(tool => tool.id !== toolId));
    } catch (err) {
      console.error("Failed to delete tool:", err);
      setError(err instanceof Error ? err.message : "Failed to delete tool");
    } finally {
      setIsDeleting(null);
    }
  };

  return (
    <div className="container py-8 space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Tool Configuration</h1>
      </div>
      
      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <div className="ml-3">{error}</div>
        </Alert>
      )}
      
      {isLoading ? (
        <div className="space-y-3">
          <Skeleton className="h-8 w-full" />
          <Skeleton className="h-24 w-full" />
          <Skeleton className="h-24 w-full" />
          <Skeleton className="h-24 w-full" />
        </div>
      ) : tools.length === 0 ? (
        <div className="py-12 text-center text-muted-foreground">
          <p>No tools found for your organization.</p>
        </div>
      ) : (
        <div className="border rounded-md">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Name</TableHead>
                <TableHead>Type</TableHead>
                <TableHead className="hidden md:table-cell">Description</TableHead>
                <TableHead className="text-right">Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {tools.map((tool) => (
                <TableRow key={tool.id || `${tool.name}-${tool.type}`}>
                  <TableCell className="font-medium">{tool.name}</TableCell>
                  <TableCell>{tool.type}</TableCell>
                  <TableCell className="hidden md:table-cell max-w-[400px] truncate">
                    {tool.description}
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex justify-end gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleEditTool(tool)}
                        disabled={!!isDeleting}
                      >
                        <PencilIcon className="h-4 w-4" />
                        <span className="sr-only">Edit</span>
                      </Button>
                      <Button
                        variant="destructive"
                        size="sm"
                        onClick={() => handleDeleteTool(tool.id as string)}
                        disabled={isDeleting === tool.id || !tool.id}
                      >
                        {isDeleting === tool.id ? (
                          <Loader2 className="h-4 w-4 animate-spin" />
                        ) : (
                          <Trash2Icon className="h-4 w-4" />
                        )}
                        <span className="sr-only">Delete</span>
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      )}
      
      <EditToolModal
        tool={editingTool}
        isOpen={isEditModalOpen}
        onOpenChange={setIsEditModalOpen}
        onSave={handleSaveTool}
        isLoading={isSaving}
      />
    </div>
  );
}

================
File: app/types/vapi.ts
================
// Type definitions for Vapi tools

export interface ToolInfo {
  id?: string; // ID might not exist for transient tools
  name: string;
  description?: string;
  type: string; // e.g., 'function', 'query', 'transferCall'
  function?: {
    name?: string;
    description?: string;
    parameters?: Record<string, unknown>;
  };
  destinations?: string[]; // For transferCall tools
  knowledgeBases?: string[]; // For query tools
}

// Simplified interface for update payload
export interface ToolUpdatePayload {
  id: string;
  type: string; // Required for PATCH requests
  name?: string;
  description?: string;
  function?: {
    name?: string;
    description?: string;
    parameters?: Record<string, unknown>;
  };
  destinations?: string[]; // For transferCall tools
  knowledgeBases?: string[]; // For query tools
}

================
File: components/ui/accordion.tsx
================
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

================
File: components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }

================
File: components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

================
File: components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}

================
File: components/ui/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}

================
File: components/ui/dropdown-menu.tsx
================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}

================
File: components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

================
File: components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

================
File: components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

================
File: components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

================
File: components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: components/ui/sidebar.tsx
================
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

================
File: components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: components/ui/table.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn("bg-primary font-medium text-primary-foreground", className)}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

================
File: components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

================
File: components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: components/AppointmentDetailModal.tsx
================
import { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Trash2, AlertCircle } from "lucide-react";

// Assuming Appointment type is defined centrally or passed appropriately
// If not, define a basic version here or import it
interface Appointment {
    id: string;
    date: Date;
    reason: string;
    status: 'SCHEDULED' | 'CONFIRMED' | 'CANCELLED' | 'COMPLETED';
    patientType: 'NEW' | 'EXISTING';
    notes?: string | null;
    patient: {
        firstName: string;
        lastName: string;
    };
}

interface AppointmentDetailModalProps {
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
  appointment: Appointment | null;
  onDeleteSuccess: () => void; // Callback after successful delete
}

export default function AppointmentDetailModal({ isOpen, onOpenChange, appointment, onDeleteSuccess }: AppointmentDetailModalProps) {
  const [isDeleting, setIsDeleting] = useState(false);
  const [error, setError] = useState('');

  const handleDelete = async () => {
    if (!appointment) return;

    // Optional: Add a confirmation step here if desired
    // if (!confirm('Are you sure you want to delete this appointment?')) {
    //   return;
    // }

    setIsDeleting(true);
    setError('');
    try {
      const response = await fetch(`/api/appointments/${appointment.id}`, { method: 'DELETE' });
      if (!response.ok) {
        let errorMsg = 'Failed to delete appointment';
        try {
            const errData = await response.json();
            errorMsg = errData.error || errorMsg;
        } catch {
            /* Ignore JSON parsing error */
        }
        throw new Error(errorMsg);
      }
      onDeleteSuccess(); // Call callback on success
    } catch (err) { 
      setError(err instanceof Error ? err.message : 'Could not delete appointment');
      console.error("Delete error:", err);
    } finally {
      setIsDeleting(false);
    }
  };

  // Use useEffect to reset state when modal visibility changes
  useEffect(() => {
    if (!isOpen) {
      // Reset state when modal closes
      setError('');
      setIsDeleting(false);
    }
  }, [isOpen]);

  if (!appointment) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Appointment Details</DialogTitle>
          <DialogDescription>
            {appointment.reason} for {appointment.patient.firstName} {appointment.patient.lastName}
          </DialogDescription>
        </DialogHeader>
        <div className="py-4 space-y-2 text-sm">
          <p><strong>Date & Time:</strong> {appointment.date.toLocaleString()}</p>
          <p><strong>Status:</strong> 
            <span className={`ml-2 px-2 py-0.5 text-xs rounded ${
              appointment.status === 'CONFIRMED' ? 'bg-green-100 text-green-800' :
              appointment.status === 'CANCELLED' ? 'bg-red-100 text-red-800' :
              appointment.status === 'COMPLETED' ? 'bg-blue-100 text-blue-800' :
              appointment.status === 'SCHEDULED' ? 'bg-primary/10 text-primary' : 'bg-gray-100 text-gray-800' // Fallback for SCHEDULED
            }`}>
              {appointment.status}
            </span>
          </p>
          <p><strong>Patient Type:</strong> 
             <span className={`ml-2 px-2 py-0.5 text-xs rounded ${
                appointment.patientType === 'NEW' ? 'bg-purple-100 text-purple-800' : 'bg-gray-100 text-gray-800'
            }`}>
                {appointment.patientType}
            </span>
          </p>
          {appointment.notes && <p><strong>Notes:</strong> {appointment.notes}</p>}
          
          {error && (
            <Alert variant="destructive" className="mt-4">
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>Error</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
            </Alert>
           )}
        </div>
        <DialogFooter className="gap-2 sm:justify-between">
          <Button variant="destructive" onClick={handleDelete} disabled={isDeleting} className="order-last sm:order-first">
            {isDeleting ? 'Deleting...' : <><Trash2 className="mr-2 h-4 w-4" /> Delete</>}
          </Button>
          <div className="flex gap-2">
            {/* Add Edit Button placeholder if needed */}
            {/* <Button variant="outline" disabled={isDeleting}>Edit</Button> */}
             <Button variant="outline" onClick={() => onOpenChange(false)} disabled={isDeleting}>Close</Button>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

================
File: components/AppointmentFormModal.tsx
================
import { useState, useEffect, useMemo } from 'react';
import type { FormEvent } from 'react';
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetDescription, SheetFooter, SheetClose } from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, Loader2 } from 'lucide-react';

// Define types locally for now, consider centralizing
interface Patient {
    id: string;
    firstName: string;
    lastName: string;
    email?: string;
    phoneNumber?: string;
}

// Define the structure of the form data
interface AppointmentFormData {
    date: string;          // YYYY-MM-DD
    time: string;          // HH:MM
    patientId: string;     // ID of existing patient (if patientType is EXISTING)
    reason: string;
    patientType: 'NEW' | 'EXISTING';
    notes: string;
    // New patient fields (only used if patientType is NEW)
    newPatientFirstName: string;
    newPatientLastName: string;
    newPatientEmail: string;
    newPatientPhone: string;
}

interface AppointmentFormModalProps {
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
  initialDateTime: { start: Date; end: Date } | null;
  patients: Patient[]; // List of existing patients for the dropdown
  onSubmitSuccess: () => void; // Callback on successful save
}

const defaultFormData: AppointmentFormData = {
    date: new Date().toISOString().split('T')[0],
    time: '09:00',
    patientId: '',
    reason: '',
    patientType: 'EXISTING',
    notes: '',
    newPatientFirstName: '',
    newPatientLastName: '',
    newPatientEmail: '',
    newPatientPhone: '',
};

export default function AppointmentFormModal({
    isOpen,
    onOpenChange,
    initialDateTime,
    patients,
    onSubmitSuccess
}: AppointmentFormModalProps) {

  const [formData, setFormData] = useState<AppointmentFormData>(defaultFormData);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');

  // Pre-fill date/time when modal opens with slot info or reset otherwise
  useEffect(() => {
    if (isOpen) {
      if (initialDateTime) {
        const startDate = initialDateTime.start;
        // Format date and time carefully
        const year = startDate.getFullYear();
        const month = (startDate.getMonth() + 1).toString().padStart(2, '0');
        const day = startDate.getDate().toString().padStart(2, '0');
        const hours = startDate.getHours().toString().padStart(2, '0');
        const minutes = startDate.getMinutes().toString().padStart(2, '0');
        
        setFormData({
          ...defaultFormData, 
          date: `${year}-${month}-${day}`, 
          time: `${hours}:${minutes}`,     
        });
      } else {
         // Reset to default if opened without slot info
         setFormData(defaultFormData);
      }
      // Reset error and loading state whenever modal opens
      setError('');
      setIsLoading(false);
    }
  }, [isOpen, initialDateTime]);

  const handleChange = (
      e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
     const { name, value } = e.target;
     setFormData(prev => ({ ...prev, [name]: value }));
     
     // If switching patient type, clear the other type's fields
     if (name === 'patientType') {
        if (value === 'NEW') {
            setFormData(prev => ({ ...prev, patientId: ''}));
        } else {
            setFormData(prev => ({
                ...prev,
                newPatientFirstName: '',
                newPatientLastName: '',
                newPatientEmail: '',
                newPatientPhone: '',
            }));
        }
     }
  };

  // Handle Select change specifically for Radix/Shadcn components
  const handleSelectChange = (name: keyof AppointmentFormData) => (value: string) => {
    setFormData(prev => ({ ...prev, [name]: value }));
    // Trigger the same clearing logic as handleChange
    if (name === 'patientType') {
       if (value === 'NEW') {
           setFormData(prev => ({ ...prev, patientId: ''}));
       } else {
           setFormData(prev => ({
               ...prev,
               newPatientFirstName: '',
               newPatientLastName: '',
               newPatientEmail: '',
               newPatientPhone: '',
           }));
       }
    }
  };

  // Placeholder handleSubmit - Replace with your actual API logic
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    console.log("Submitting Form Data:", formData);

    // --- Start: Replace with your API Call Logic --- 
    try {
      // 1. Combine date and time
      const dateTime = new Date(`${formData.date}T${formData.time}`);
      if (Number.isNaN(dateTime.getTime())) { // Use Number.isNaN
          throw new Error('Invalid date or time format.');
      }

      // 2. Determine Patient ID (Create new if needed)
      let finalPatientId = formData.patientId;
      if (formData.patientType === 'NEW') {
          if (!formData.newPatientFirstName || !formData.newPatientLastName) {
              throw new Error('First and last name are required for new patients.');
          }
          // Optional: Fetch dentist ID if needed for patient creation
          // const usersRes = await fetch('/api/users?role=DENTIST');
          // const users = await usersRes.json();
          // if (users.length === 0) throw new Error('No dentist found.');
          // const dentistId = users[0].id;

          const patientPayload = {
              firstName: formData.newPatientFirstName,
              lastName: formData.newPatientLastName,
              email: formData.newPatientEmail || undefined,
              phoneNumber: formData.newPatientPhone || undefined,
              // userId: dentistId, // Include if needed by your API
          };
          console.log("Creating new patient:", patientPayload);
          const patientRes = await fetch('/api/patients', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(patientPayload),
          });
          if (!patientRes.ok) {
              const errData = await patientRes.json();
              throw new Error(errData.error || 'Failed to create new patient');
          }
          const newPatient = await patientRes.json();
          finalPatientId = newPatient.id;
          console.log("New patient created:", newPatient);
      } else if (!finalPatientId) {
          throw new Error('Please select an existing patient.');
      }

      // 3. Create the Appointment
      const appointmentPayload = {
          date: dateTime.toISOString(),
          patientId: finalPatientId,
          reason: formData.reason,
          patientType: formData.patientType,
          notes: formData.notes || undefined,
          status: 'SCHEDULED', // Default status, adjust as needed
      };
      console.log("Creating appointment:", appointmentPayload);
      const appointmentRes = await fetch('/api/appointments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(appointmentPayload),
      });

      if (!appointmentRes.ok) {
          const errData = await appointmentRes.json();
          throw new Error(errData.error || 'Failed to create appointment');
      }
      
      const newAppointment = await appointmentRes.json();
      console.log("Appointment created:", newAppointment);

      // 4. Success
      onSubmitSuccess(); // Call the success callback from parent

    } catch (err) {
      const message = err instanceof Error ? err.message : 'An unexpected error occurred.';
      setError(message);
      console.error('Form submission error:', err);
    } finally {
      setIsLoading(false);
    }
    // --- End: Replace with your API Call Logic --- 
  };

  // Generate basic time slots (e.g., 8 AM to 5:30 PM)
  const timeSlots = useMemo(() => {
      const slots = [];
      for (let hour = 8; hour < 18; hour++) {
          slots.push(`${hour.toString().padStart(2, '0')}:00`);
          slots.push(`${hour.toString().padStart(2, '0')}:30`);
      }
      return slots;
  }, []);

  return (
    <Sheet open={isOpen} onOpenChange={onOpenChange}>
      <SheetContent className="overflow-y-auto w-full sm:max-w-lg">
        <SheetHeader>
          <SheetTitle>Add New Appointment</SheetTitle>
          <SheetDescription>Fill in the details below to schedule an appointment.</SheetDescription>
        </SheetHeader>
        <form onSubmit={handleSubmit} className="py-4 space-y-4">
          {/* Date Input */} 
          <div className="space-y-1">
            <Label htmlFor="date">Date</Label>
            <Input
              id="date"
              type="date"
              name="date"
              value={formData.date}
              onChange={handleChange}
              required
              disabled={isLoading}
            />
          </div>

          {/* Time Select */} 
          <div className="space-y-1">
             <Label htmlFor="time">Time</Label>
             <Select name="time" value={formData.time} onValueChange={handleSelectChange('time')} disabled={isLoading} required>
                <SelectTrigger id="time">
                    <SelectValue placeholder="Select time" />
                </SelectTrigger>
                <SelectContent>
                    {timeSlots.map((time: string) => ( // Add string type here
                        <SelectItem key={time} value={time}>{time}</SelectItem>
                    ))}
                </SelectContent>
            </Select>
          </div>

          {/* Patient Type Select */} 
          <div className="space-y-1">
             <Label htmlFor="patientType">Patient Type</Label>
             <Select name="patientType" value={formData.patientType} onValueChange={handleSelectChange('patientType')} disabled={isLoading} required>
                <SelectTrigger id="patientType">
                    <SelectValue placeholder="Select patient type" />
                </SelectTrigger>
                <SelectContent>
                    <SelectItem value="EXISTING">Existing Patient</SelectItem>
                    <SelectItem value="NEW">New Patient</SelectItem>
                </SelectContent>
            </Select>
          </div>

          {/* Conditional Patient Fields */} 
          {formData.patientType === 'EXISTING' ? (
            <div className="space-y-1">
               <Label htmlFor="patientId">Patient</Label>
               <Select name="patientId" value={formData.patientId} onValueChange={handleSelectChange('patientId')} disabled={isLoading} required>
                  <SelectTrigger id="patientId">
                      <SelectValue placeholder="Select existing patient" />
                  </SelectTrigger>
                  <SelectContent>
                      {patients.length > 0 ? (
                          patients.map(patient => (
                            <SelectItem key={patient.id} value={patient.id}>
                              {patient.firstName} {patient.lastName}
                            </SelectItem>
                          ))
                      ) : (
                         <SelectItem value="" disabled>No existing patients found</SelectItem> 
                      )}
                  </SelectContent>
              </Select>
            </div>
          ) : (
            <div className="space-y-3 border-t border-b py-4 px-1 my-4 border-dashed">
              <h3 className="font-medium text-sm mb-2">New Patient Information</h3>
              <div className="grid grid-cols-2 gap-3">
                  <div className="space-y-1">
                    <Label htmlFor="newPatientFirstName">First Name</Label>
                    <Input
                      id="newPatientFirstName"
                      name="newPatientFirstName"
                      value={formData.newPatientFirstName}
                      onChange={handleChange}
                      required
                      disabled={isLoading}
                    />
                  </div>
                  <div className="space-y-1">
                    <Label htmlFor="newPatientLastName">Last Name</Label>
                    <Input
                      id="newPatientLastName"
                      name="newPatientLastName"
                      value={formData.newPatientLastName}
                      onChange={handleChange}
                      required
                      disabled={isLoading}
                    />
                  </div>
              </div>
               <div className="space-y-1">
                <Label htmlFor="newPatientEmail">Email <span className="text-xs text-muted-foreground">(Optional)</span></Label>
                <Input
                  id="newPatientEmail"
                  type="email"
                  name="newPatientEmail"
                  value={formData.newPatientEmail}
                  onChange={handleChange}
                  disabled={isLoading}
                />
              </div>
              <div className="space-y-1">
                <Label htmlFor="newPatientPhone">Phone <span className="text-xs text-muted-foreground">(Optional)</span></Label>
                <Input
                  id="newPatientPhone"
                  type="tel"
                  name="newPatientPhone"
                  value={formData.newPatientPhone}
                  onChange={handleChange}
                  disabled={isLoading}
                />
              </div>
            </div>
          )}

          {/* Reason Input */} 
          <div className="space-y-1">
            <Label htmlFor="reason">Reason for Visit</Label>
            <Input
              id="reason"
              name="reason"
              value={formData.reason}
              onChange={handleChange}
              required
              disabled={isLoading}
              placeholder="e.g., Check-up, Cleaning, Consultation"
            />
          </div>

          {/* Notes Textarea */} 
          <div className="space-y-1">
            <Label htmlFor="notes">Notes <span className="text-xs text-muted-foreground">(Optional)</span></Label>
            <Textarea
              id="notes"
              name="notes"
              value={formData.notes}
              onChange={handleChange}
              rows={3}
              disabled={isLoading}
              placeholder="Any additional information..."
            />
          </div>

          {/* Error Display */} 
          {error && (
            <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>Error</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
            </Alert>
           )}

          <SheetFooter className="pt-4">
            <SheetClose asChild>
               <Button type="button" variant="outline" disabled={isLoading}>Cancel</Button>
            </SheetClose>
            <Button type="submit" disabled={isLoading}>
              {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />} 
              {isLoading ? 'Saving...' : 'Save Appointment'}
            </Button>
          </SheetFooter>
        </form>
      </SheetContent>
    </Sheet>
  );
}

================
File: components/Placeholder.tsx
================
import type { ReactNode } from 'react';

interface PlaceholderProps {
  className?: string;
  children?: ReactNode;
}

export function Placeholder({ className, children }: PlaceholderProps) {
  return (
    <div className={`flex items-center justify-center border-2 border-dashed border-gray-300 rounded-md ${className}`}>
      {children || 'Placeholder content'}
    </div>
  );
}

================
File: hooks/use-mobile.ts
================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: lib/prisma.ts
================
import { PrismaClient } from '@prisma/client'

const globalForPrisma = global as unknown as { prisma: PrismaClient }

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  })

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: lib/vapiUtils.ts
================
import { randomUUID } from 'node:crypto';

const VAPI_API_KEY = process.env.VAPI_API_KEY;
const VAPI_BASE_URL = 'https://api.vapi.ai';

function logUtil(scope: string, message: string, data?: unknown) {
    console.log(`[${new Date().toISOString()}] [${scope}] ${message}`);
    if (data !== undefined) {
        console.log(JSON.stringify(data, null, 2));
    }
}

// --- Vapi API Call Helper (Modified for FormData) ---
// This helper now needs to handle both JSON and FormData
async function vapiFetchUtil(endpoint: string, options: RequestInit & { body?: BodyInit | null | FormData } = {}): Promise<unknown> {
    if (!VAPI_API_KEY) {
        throw new Error("VAPI_API_KEY environment variable is not set.");
    }
    const url = `${VAPI_BASE_URL}${endpoint}`;
    const isFormData = options.body instanceof FormData;

    logUtil('vapiFetchUtil', `Calling Vapi: ${options.method || 'GET'} ${url}`, isFormData ? '(FormData body)' : (options.body ? '(JSON body)' : ''));

    const headers: HeadersInit = {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        // DO NOT set Content-Type for FormData, let fetch do it
        ...(isFormData ? {} : { 'Content-Type': 'application/json' }),
        ...options.headers,
    };

    const response = await fetch(url, {
        ...options,
        headers: headers,
    });

    let responseData: unknown;
    try {
        if (response.status === 204 || response.headers.get('content-length') === '0') {
            responseData = null;
        } else {
            // Assume JSON unless proven otherwise, handle potential errors
             const contentType = response.headers.get("content-type");
             if (contentType?.includes("application/json")) {
                 responseData = await response.json();
             } else {
                 // If not JSON, read as text for debugging, especially for errors
                 const textResponse = await response.text();
                 if (!response.ok) {
                     throw new Error(`Vapi request failed with status ${response.status}. Response: ${textResponse}`);
                 }
                 logUtil('vapiFetchUtil', `Vapi call ${options.method || 'GET'} ${url} succeeded (${response.status}) but response was not JSON. Body: ${textResponse}`);
                 responseData = textResponse; // Or null if text isn't useful
             }
        }
    } catch (e) {
        if (response.ok && !(e instanceof SyntaxError)) { // Don't throw if OK status but non-JSON body was expected/handled
             logUtil('vapiFetchUtil', `Vapi call ${options.method || 'GET'} ${url} succeeded (${response.status}) but response parsing failed or was not JSON.`);
             responseData = null;
        } else {
             logUtil('vapiFetchUtil', `Vapi call ${options.method || 'GET'} ${url} failed (${response.status}) and/or response parsing failed.`);
             const errorMsg = e instanceof Error ? e.message : 'Unknown parsing error';
             throw new Error(`Vapi request failed with status ${response.status}. Error: ${errorMsg}`);
        }
    }

    if (!response.ok) {
        logUtil('vapiFetchUtil', `Vapi Error: ${response.status} ${response.statusText}`, responseData);
        let errorMessage = `Request failed with status ${response.status}`;
        if (responseData && typeof responseData === 'object') {
             if ('message' in responseData && responseData.message) errorMessage = String(responseData.message);
             else if ('error' in responseData && responseData.error) errorMessage = String(responseData.error);
        } else if (typeof responseData === 'string') {
            errorMessage = responseData; // Use text response if available for non-JSON errors
        }
        throw new Error(`Vapi API Error: ${errorMessage}`);
    }

    logUtil('vapiFetchUtil', `Vapi Success: ${options.method || 'GET'} ${url} (${response.status})`, responseData);
    return responseData;
}


// --- File Upload Utility ---
export async function uploadFileToVapi(content: string, filename: string): Promise<string> {
    logUtil('uploadFileToVapi', `Preparing to upload file: ${filename}`);
    const blob = new Blob([content], { type: 'text/plain' });
    const formData = new FormData();
    formData.append('file', blob, filename); // Vapi expects the field name 'file'

    const fileData = await vapiFetchUtil('/file', {
        method: 'POST',
        body: formData, // Pass FormData directly
        // No Content-Type header here!
    });

    const vapiFileId = (fileData && typeof fileData === 'object' && 'id' in fileData && typeof fileData.id === 'string') ? fileData.id : null;
    if (!vapiFileId) {
        throw new Error('Vapi did not return a valid file ID after upload.');
    }
    logUtil('uploadFileToVapi', `File uploaded successfully: ${vapiFileId}`);
    return vapiFileId;
}

// --- Generate Vapi Names Utility ---
export function generateVapiNamesUtil(topicName: string) {
    const safeName = topicName.trim().toLowerCase().replace(/[^a-z0-9_-]/g, '_').replace(/_{2,}/g, '_').substring(0, 30); // Limit base name length
    const uniqueSuffix = randomUUID().substring(0, 8);
    const base = `${safeName}_${uniqueSuffix}`;
    return {
        vapiFileName: `kb_${base}.txt`,
        vapiToolName: `query_${base}`, // Max 64 chars for function name
        vapiKbName: `kb_${base}`,
        vapiDescription: `Knowledge about: ${topicName.trim()}`,
    };
}

// --- Export vapiFetch for other routes if needed ---
export const vapiFetch = vapiFetchUtil;

================
File: prisma/migrations/20250402023503_add_appointment_fields/migration.sql
================
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN', 'RECEPTIONIST', 'DENTIST');

-- CreateEnum
CREATE TYPE "PatientType" AS ENUM ('NEW', 'EXISTING');

-- CreateEnum
CREATE TYPE "AppointmentStatus" AS ENUM ('SCHEDULED', 'CONFIRMED', 'CANCELLED', 'COMPLETED');

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "role" "Role" NOT NULL DEFAULT 'USER',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Patient" (
    "id" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "email" TEXT,
    "phoneNumber" TEXT,
    "dateOfBirth" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Patient_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Appointment" (
    "id" TEXT NOT NULL,
    "date" TIMESTAMP(3) NOT NULL,
    "reason" TEXT NOT NULL,
    "patientType" "PatientType" NOT NULL DEFAULT 'EXISTING',
    "status" "AppointmentStatus" NOT NULL DEFAULT 'SCHEDULED',
    "notes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "patientId" TEXT NOT NULL,

    CONSTRAINT "Appointment_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Patient_email_key" ON "Patient"("email");

-- AddForeignKey
ALTER TABLE "Patient" ADD CONSTRAINT "Patient_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Appointment" ADD CONSTRAINT "Appointment_patientId_fkey" FOREIGN KEY ("patientId") REFERENCES "Patient"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: eslint.config.mjs
================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================
File: postcss.config.mjs
================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: .cursor/rules/project_description.mdc
================
---
description: 
globs: 
alwaysApply: false
---
# .cursorrules

project:
  name: "Laine"
  description: >
    Laine is an AI-Powered Dental Office Assistant designed to optimize dental practice workflows.
    It is built to enhance patient interactions and streamline office operations, combining a
    real-time dashboard, a customizable AI virtual assistant, intelligent call handling, and smart task
    management into one unified experience.

vision:
  - "Improve patient communication and engagement in dental practices."
  - "Empower dental staff with intuitive tools that automate routine tasks."
  - "Provide a clean, user-centric interface that makes managing dental operations effortless."
  - "Lay the groundwork for future enhancements like EHR integration and multi-channel messaging."

focus:
  - "Real-time data and actionable insights on a simplified dashboard."
  - "A highly customizable AI assistant tailored for dental office workflows."
  - "Efficient call handling with intelligent transcription and task creation."
  - "A straightforward, minimal interface that prioritizes clarity and usability."

philosophy:
  - "User-first design: Build tools that dental professionals love to use."
  - "Simplicity meets functionality: Keep the interface clean and effective."
  - "Scalable core: Establish a robust foundation for future features and integrations."

================
File: app/ai-customiser/_components/TestTab.tsx
================
"use client";

import React, { useState, useEffect } from 'react';
import Vapi from '@vapi-ai/web';
import { Mic, MicOff, Play, Square, Loader2, AlertCircle, Bot } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";

interface TestTabProps {
  assistantId: string;
}

interface TranscriptEntry {
  id: string; // Unique ID for React key
  role: 'assistant' | 'user' | 'system' | 'tool_calls' | 'tool_call_result';
  content: string;
  name?: string; // For tool results
  toolCallId?: string; // For tool results/calls
  timestamp: number;
}

// Define a generic message type for Vapi messages
interface VapiMessage {
  type?: string;
  role?: string;
  transcriptType?: string;
  transcript?: string;
  toolCallList?: Array<{
    id: string;
    function?: {
      name?: string;
      arguments?: Record<string, unknown> | string;
    };
  }>;
  toolCallResult?: {
    name: string;
    result?: unknown;
    error?: unknown;
    toolCallId: string;
  };
  content?: string;
  message?: string;
}

export function TestTab({ assistantId }: TestTabProps) {
  const [assistant, setAssistant] = useState<Vapi | null>(null);
  const [isSessionActive, setIsSessionActive] = useState<boolean>(false);
  const [isConnecting, setIsConnecting] = useState<boolean>(false);
  const [isMuted, setIsMuted] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [transcript, setTranscript] = useState<TranscriptEntry[]>([]);
  const [showToolCallNotification, setShowToolCallNotification] = useState<string | null>(null);
  const [showToolResultNotification, setShowToolResultNotification] = useState<string | null>(null);

  const publicKey = process.env.NEXT_PUBLIC_VAPI_PUBLIC_KEY;

  useEffect(() => {
    if (!publicKey) {
      setError("Unable to initialize the test system.");
      return;
    }
    const assistant = new Vapi(publicKey);
    setAssistant(assistant);

    assistant.on('call-start', () => {
      console.log('Test Call Started');
      setIsSessionActive(true);
      setIsConnecting(false);
      setError(null);
      setTranscript([]); // Clear transcript on new call
    });
    assistant.on('call-end', () => {
      console.log('Test Call Ended');
      setIsSessionActive(false);
      setIsConnecting(false);
      setIsMuted(false); // Reset mute state on call end
    });
    assistant.on('message', (message: VapiMessage) => {
      console.log('Received message:', message); // Keep for debugging

      const createEntry = (role: TranscriptEntry['role'], content: string, name?: string, toolCallId?: string): TranscriptEntry => ({
        id: `${Date.now()}-${Math.random()}`, // Simple unique key
        role,
        content,
        name,
        toolCallId,
        timestamp: Date.now()
      });

      setTranscript(prev => {
        const newEntries: TranscriptEntry[] = [];

        switch (message.type) {
          case 'transcript':
            // Only add final transcripts to the main log for clarity
            if (message.transcriptType === 'final' && message.role && message.transcript) {
              newEntries.push(createEntry(message.role as TranscriptEntry['role'], message.transcript));
            }
            break;
          case 'tool-calls':
            if (message.toolCallList && message.toolCallList.length > 0) {
              for (const tc of message.toolCallList) {
                const argsString = JSON.stringify(tc.function?.arguments || {});
                const content = `Calling tool: ${tc.function?.name}(${argsString})`;
                newEntries.push(createEntry('tool_calls', content, tc.function?.name, tc.id));
                // Trigger toaster
                setShowToolCallNotification(`Calling: ${tc.function?.name}`);
                setTimeout(() => setShowToolCallNotification(null), 3000); // Hide after 3s
              }
            }
            break;
          case 'tool-calls-result':
             if (message.toolCallResult) {
                const resultString = JSON.stringify(message.toolCallResult.result || message.toolCallResult.error || 'No result/error provided');
                const content = `Tool Result (${message.toolCallResult.name}): ${resultString}`;
                newEntries.push(createEntry('tool_call_result', content, message.toolCallResult.name, message.toolCallResult.toolCallId));
                // Trigger result toaster
                setShowToolResultNotification(`Result for ${message.toolCallResult.name}: ${resultString.substring(0, 50)}...`);
                 setTimeout(() => setShowToolResultNotification(null), 4000); // Hide after 4s
             }
            break;
          default:
             // If the message has a 'role' and 'content' or 'message', add it generically
             if (message.role && (message.content || message.message)) {
                 const content = message.content || message.message || '[No Content]';
                 // Avoid adding duplicates if transcript event already handled it
                 if (!prev.some(entry => entry.content === content && entry.role === message.role)) {
                    newEntries.push(createEntry(message.role as TranscriptEntry['role'], content as string));
                 }
             }
        }
        return [...prev, ...newEntries];
      });
    });
    assistant.on('error', (e) => {
      console.error('Assistant Error:', e);
      setError(e?.message || 'An unknown error occurred during the call.');
      setIsSessionActive(false);
      setIsConnecting(false);
    });

    return () => {
      assistant.stop(); // Ensure call stops if component unmounts
      // Clean up listeners if assistant SDK provides an 'off' method or similar
    };
  }, [publicKey]); // Re-initialize if publicKey changes

  const handleStartCall = async () => {
    if (!assistant || !assistantId) return;
    setIsConnecting(true);
    setError(null);
    setTranscript([]); // Clear transcript
    try {
      await assistant.start(assistantId);
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      setError(`Failed to start test call: ${errorMsg}`);
      setIsConnecting(false);
    }
  };

  const handleStopCall = async () => {
    if (!assistant) return;
    try {
      await assistant.stop();
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      setError(`Failed to stop test call: ${errorMsg}`);
    } finally {
      setIsSessionActive(false);
      setIsConnecting(false);
    }
  };

  const toggleMute = () => {
    if (!assistant) return;
    const newMutedState = !isMuted;
    assistant.setMuted(newMutedState);
    setIsMuted(newMutedState);
  };

  return (
    <div className="space-y-6 p-4 border rounded-lg bg-white dark:bg-gray-800 shadow-sm">
      <h2 className="text-xl font-semibold mb-4 flex items-center">
        <Bot className="mr-2 h-5 w-5 text-gray-600 dark:text-gray-400" /> Test Assistant
      </h2>

      {!publicKey && (
         <Alert variant="destructive">
           <AlertCircle className="h-4 w-4" />
           <AlertTitle>Configuration Error</AlertTitle>
           <AlertDescription>The assistant test system is not fully configured. Please contact your administrator.</AlertDescription>
         </Alert>
      )}

      <div className="flex flex-col sm:flex-row items-center justify-center space-y-3 sm:space-y-0 sm:space-x-4">
        {!isSessionActive ? (
          <Button
            onClick={handleStartCall}
            disabled={!assistant || isConnecting || !publicKey || !assistantId}
            className="w-full sm:w-auto"
          >
            {isConnecting ? (
              <Loader2 className="animate-spin mr-2 h-4 w-4" />
            ) : (
              <Play className="mr-2 h-5 w-5" />
            )}
            {isConnecting ? 'Connecting...' : 'Start Test Call'}
          </Button>
        ) : (
          <Button
            onClick={handleStopCall}
            variant="destructive"
            disabled={!assistant}
            className="w-full sm:w-auto"
          >
            <Square className="mr-2 h-5 w-5" /> End Test Call
          </Button>
        )}
        <Button
          variant="outline"
          onClick={toggleMute}
          disabled={!isSessionActive}
          className="w-full sm:w-auto"
        >
          {isMuted ? <MicOff className="mr-2 h-5 w-5" /> : <Mic className="mr-2 h-5 w-5" />}
          {isMuted ? 'Unmute Mic' : 'Mute Mic'}
        </Button>
      </div>

      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Call Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {/* Transcript Display Area */}
      <div className="mt-4 p-3 bg-gray-50 dark:bg-gray-700 rounded min-h-[200px] max-h-[400px] overflow-y-auto space-y-2">
        <p className="text-xs text-gray-500 dark:text-gray-400 sticky top-0 bg-gray-50 dark:bg-gray-700 py-1">Conversation Transcript:</p>
        {transcript.length === 0 && !isSessionActive && <p className="text-sm text-gray-500 dark:text-gray-400">Call not active.</p>}
        {transcript.length === 0 && isSessionActive && <p className="text-sm text-gray-500 dark:text-gray-400">Waiting for speech...</p>}
        {transcript.map((entry) => (
          <div key={entry.id} className={`text-sm ${
            entry.role === 'user' ? 'text-right' : 'text-left'
          }`}>
            <span className={`inline-block p-2 rounded-lg max-w-[80%] ${
              entry.role === 'assistant' ? 'bg-blue-100 dark:bg-blue-900 text-blue-900 dark:text-blue-100' :
              entry.role === 'user' ? 'bg-green-100 dark:bg-green-900 text-green-900 dark:text-green-100' :
              entry.role === 'system' ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-900 dark:text-yellow-100 italic' :
              entry.role === 'tool_calls' ? 'bg-purple-100 dark:bg-purple-900 text-purple-900 dark:text-purple-100 font-mono text-xs' :
              entry.role === 'tool_call_result' ? 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-200 font-mono text-xs' :
              'bg-gray-100 dark:bg-gray-600' // Default/System
            }`}>
              <span className="font-bold capitalize">{entry.role.replace('_', ' ')}{entry.name ? ` (${entry.name})` : ''}: </span>
              {entry.content}
            </span>
          </div>
        ))}
      </div>

      {/* Tool Call Toaster Notification */}
      {showToolCallNotification && (
        <div className="fixed bottom-4 right-4 bg-blue-500 text-white p-3 rounded-lg shadow-lg animate-pulse z-50 text-sm">
          {showToolCallNotification}
        </div>
      )}

      {/* Tool Result Toaster Notification */}
       {showToolResultNotification && (
         <div className="fixed bottom-16 right-4 bg-green-500 text-white p-3 rounded-lg shadow-lg z-50 text-sm max-w-xs break-words">
           {showToolResultNotification}
         </div>
       )}
    </div>
  );
}

================
File: app/api/appointments/[id]/route.ts
================
import { PrismaClient } from '@prisma/client';
import { NextResponse } from 'next/server';

const prisma = new PrismaClient();

// DELETE appointment by ID
export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  
  try {
    // Check if appointment exists
    const appointment = await prisma.appointment.findUnique({
      where: { id },
    });

    if (!appointment) {
      return NextResponse.json({ error: 'Appointment not found' }, { status: 404 });
    }

    // Delete appointment
    await prisma.appointment.delete({
      where: { id },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting appointment:', error);
    return NextResponse.json({ error: 'Failed to delete appointment' }, { status: 500 });
  }
}

// GET appointment by ID
export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  
  try {
    const appointment = await prisma.appointment.findUnique({
      where: { id },
      include: {
        patient: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    if (!appointment) {
      return NextResponse.json({ error: 'Appointment not found' }, { status: 404 });
    }

    return NextResponse.json(appointment);
  } catch (error) {
    console.error('Error fetching appointment:', error);
    return NextResponse.json({ error: 'Failed to fetch appointment' }, { status: 500 });
  }
}

================
File: app/api/laine/book-appointment/route.ts
================
import { NextResponse } from 'next/server';
import { PrismaClient, PatientType, Role } from '@prisma/client'; // Keep value imports
import type { Patient, Appointment } from '@prisma/client'; // Use type imports for types

const prisma = new PrismaClient();

// --- Configuration & Constants ---
const DEFAULT_APPOINTMENT_REASON = "Appointment via voice assistant";
const DEFAULT_TIMEZONE = 'America/Chicago'; // Or pull from env var if needed

// --- Logging Utility ---
function log(message: string, data?: unknown) {
  console.log(`[${new Date().toISOString()}] [book-appointment] ${message}`);
  if (data) {
    // Avoid logging potentially sensitive full request bodies in production if necessary
    // Consider redacting sensitive fields if logging the full body
    console.log(JSON.stringify(data, null, 2));
  }
}

// --- CORS Headers ---
const corsHeaders = {
  'Access-Control-Allow-Origin': '*', // Adjust in production
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

// --- Interfaces ---
interface AppointmentParams {
  start: string; // Expect ISO 8601 string
  name: string;
  email: string;
  smsReminderNumber?: string;
}

interface VapiToolCall {
    id: string;
    function?: {
        name?: string;
        arguments?: string | Record<string, unknown>;
    };
}

interface RequestBody {
    message?: { toolCalls?: VapiToolCall[]; toolCallList?: VapiToolCall[] };
    tool_call_id?: string;
    parameters?: Record<string, unknown>; // Direct Vapi format
    toolCallId?: string; // OpenAI format
    arguments?: string | Record<string, unknown>; // OpenAI format
    toolCalls?: VapiToolCall[]; // Vapi array format
}

// --- Helper Functions ---

// Standardized Vapi Response
function createVapiResponse(toolCallId: string, result?: string, error?: string, status = 200) {
  const payload = {
    results: [{
      toolCallId,
      ...(result && { result }), // Conditionally add result
      ...(error && { error }),   // Conditionally add error
    }]
  };
  return NextResponse.json(payload, { status, headers: corsHeaders });
}

// Parse Name
function parseFullName(fullName: string): { firstName: string; lastName: string } {
  const nameParts = fullName.trim().split(' ');
  const firstName = nameParts[0] || 'Unknown'; // Default if empty
  const lastName = nameParts.length > 1 ? nameParts.slice(1).join(' ') : 'Patient'; // Default if only one name part
  return { firstName, lastName };
}

// Format Date for Confirmation Message
function formatConfirmationDate(date: Date): string {
   return date.toLocaleString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      hour12: true,
      timeZone: DEFAULT_TIMEZONE, // Use configured timezone
    });
}


// --- Main API Route Handler ---
export async function POST(request: Request) {
  let toolCallId = 'unknown-tool-call-id'; // Default ID if extraction fails
  log('Received request');

  try {
    // Handle CORS preflight request
    if (request.method === 'OPTIONS') {
      return new NextResponse(null, { status: 204, headers: corsHeaders });
    }

    // --- Parameter Extraction ---
    const reqBody: RequestBody = await request.json();
    log('Request body received'); // Avoid logging full body in prod if sensitive

    let functionParams: AppointmentParams | undefined;
    let rawArgs: string | Record<string, unknown> | undefined;

    // Extract toolCallId and arguments from various possible structures
    if (reqBody.message?.toolCalls?.[0]?.id) {
        toolCallId = reqBody.message.toolCalls[0].id;
        rawArgs = reqBody.message.toolCalls[0].function?.arguments;
    } else if (reqBody.message?.toolCallList?.[0]?.id) {
        toolCallId = reqBody.message.toolCallList[0].id;
        rawArgs = reqBody.message.toolCallList[0].function?.arguments;
    } else if (reqBody.tool_call_id) {
        toolCallId = reqBody.tool_call_id;
        rawArgs = reqBody.parameters; // Assume parameters are the arguments
    } else if (reqBody.toolCallId) {
        toolCallId = reqBody.toolCallId;
        rawArgs = reqBody.arguments;
    } else if (Array.isArray(reqBody.toolCalls) && reqBody.toolCalls.length > 0) {
        toolCallId = reqBody.toolCalls[0].id;
        rawArgs = reqBody.toolCalls[0].function?.arguments;
    }

    // Parse arguments if they are a string
    if (typeof rawArgs === 'string') {
        try {
            const parsedArgs = JSON.parse(rawArgs);
            // Additional check after parsing
            if (parsedArgs && typeof parsedArgs === 'object' &&
                'start' in parsedArgs && typeof parsedArgs.start === 'string' &&
                'name' in parsedArgs && typeof parsedArgs.name === 'string' &&
                'email' in parsedArgs && typeof parsedArgs.email === 'string') {
                functionParams = {
                    start: parsedArgs.start,
                    name: parsedArgs.name,
                    email: parsedArgs.email,
                    smsReminderNumber: typeof parsedArgs.smsReminderNumber === 'string' ? parsedArgs.smsReminderNumber : undefined
                };
            } else {
                 log('Error: Parsed stringified arguments are missing required fields or have incorrect types', { parsedArgs });
                 return createVapiResponse(toolCallId, undefined, 'Could not understand the provided appointment details (invalid format).', 400);
            }
        } catch (parseError) {
            log('Error parsing stringified arguments', { rawArgs, error: parseError });
            return createVapiResponse(toolCallId, undefined, 'Could not understand the provided appointment details.', 400);
        }
    } else if (typeof rawArgs === 'object' && rawArgs !== null) {
        // Type guard to ensure rawArgs has the required properties
        if ('start' in rawArgs && typeof rawArgs.start === 'string' &&
            'name' in rawArgs && typeof rawArgs.name === 'string' &&
            'email' in rawArgs && typeof rawArgs.email === 'string') {
            // Create a new object matching the interface instead of asserting
            functionParams = {
                start: rawArgs.start,
                name: rawArgs.name,
                email: rawArgs.email,
                smsReminderNumber: 'smsReminderNumber' in rawArgs && typeof rawArgs.smsReminderNumber === 'string'
                    ? rawArgs.smsReminderNumber
                    : undefined
            };
        } else {
            log('Error: Received object arguments are missing required fields or have incorrect types', { rawArgs });
            return createVapiResponse(toolCallId, undefined, 'Could not understand the provided appointment details (invalid format).', 400);
        }
    }

    log('Extracted parameters', { toolCallId, functionParams: functionParams ? 'extracted' : 'not found' });

    if (!functionParams) {
      log('Error: Missing function parameters in request body');
      return createVapiResponse(toolCallId, undefined, 'Missing required appointment parameters.', 400);
    }

    const { start, name, email, smsReminderNumber } = functionParams;

    // --- Input Validation ---
    if (!start || !name || !email) {
      log('Error: Missing required fields', { start: !!start, name: !!name, email: !!email });
      return createVapiResponse(toolCallId, undefined, 'Start date, patient name, and email are required.', 400);
    }

    const appointmentDate = new Date(start);
    if (Number.isNaN(appointmentDate.getTime())) { // Use Number.isNaN
      log('Error: Invalid date format received', { start });
      return createVapiResponse(toolCallId, undefined, `Invalid date format: ${start}. Please use ISO 8601 format.`, 400);
    }

    // Optional: Add validation for email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        log('Error: Invalid email format', { email });
        return createVapiResponse(toolCallId, undefined, `Invalid email format provided: ${email}.`, 400);
    }

    log(`Processing booking for: ${name} (${email}) at ${appointmentDate.toISOString()}`);

    // --- Find or Create Patient ---
    let patient: Patient | null = null;
    let patientWasCreated = false;
    const { firstName, lastName } = parseFullName(name);

    try {
      patient = await prisma.patient.findUnique({ where: { email } });

      if (!patient) {
        log(`Patient with email ${email} not found. Creating new patient.`);
        const dentist = await prisma.user.findFirst({ where: { role: Role.DENTIST } }); // Use imported Enum
        if (!dentist) {
          log('CRITICAL Error: No DENTIST user found in the database.');
          return createVapiResponse(toolCallId, undefined, 'Internal setup error. Cannot schedule appointment.', 500);
        }

        patient = await prisma.patient.create({
          data: {
            firstName,
            lastName,
            email,
            phoneNumber: smsReminderNumber || null,
            userId: dentist.id,
          },
        });
        patientWasCreated = true;
        log('New patient created successfully', { patientId: patient.id });
      } else {
        log('Existing patient found', { patientId: patient.id });
        if (smsReminderNumber && patient.phoneNumber !== smsReminderNumber) {
           await prisma.patient.update({
             where: { id: patient.id },
             data: { phoneNumber: smsReminderNumber },
           });
           log(`Updated phone number for existing patient ${patient.id}`);
        }
      }
    } catch (dbError) {
      log('Database error during patient find/create', dbError);
      return createVapiResponse(toolCallId, undefined, 'There was an issue accessing patient records.', 500);
    }

    // --- Create Appointment ---
    let newAppointment: Appointment | null = null;
    try {
      // Ensure patient is not null before proceeding
      if (!patient) {
           log('CRITICAL Error: Patient record is unexpectedly null before appointment creation.');
           return createVapiResponse(toolCallId, undefined, 'Internal server error processing patient data.', 500);
      }

      newAppointment = await prisma.appointment.create({
        data: {
          date: appointmentDate,
          reason: DEFAULT_APPOINTMENT_REASON,
          patientType: patientWasCreated ? PatientType.NEW : PatientType.EXISTING,
          status: 'SCHEDULED',
          notes: `Booked via VAPI Tool.${smsReminderNumber ? ` SMS Reminder #: ${smsReminderNumber}` : ''}`,
          patientId: patient.id,
        },
      });
      log('Appointment created successfully in DB', { appointmentId: newAppointment.id });
    } catch (dbError: unknown) {
        log('Database error during appointment creation', dbError);
        // Check for specific Prisma errors, like unique constraint violation if needed
        // Example: if (dbError instanceof Prisma.PrismaClientKnownRequestError && dbError.code === 'P2002') { ... }

        // Attempt rollback if a new patient was created
        if (patientWasCreated && patient?.id) {
            log(`Attempting to rollback patient creation for ${patient.id}`);
            await prisma.patient.delete({ where: { id: patient.id } }).catch(rollbackError => {
                log(`CRITICAL: Failed to rollback patient creation for ${patient.id}`, rollbackError);
                // Decide how to handle this - maybe log prominently
            });
        }
        return createVapiResponse(toolCallId, undefined, 'Failed to save the appointment in the schedule. Please try again.', 500);
    }

    // --- Format Confirmation & Return Success ---
    const formattedDate = formatConfirmationDate(appointmentDate);
    const confirmationMessage = `Okay, I've booked the appointment for ${name} on ${formattedDate}.`;
    log('Sending success response', { confirmationMessage });

    return createVapiResponse(toolCallId, confirmationMessage);

  } catch (error) {
    log('Unhandled error in POST handler', error);
    const message = error instanceof Error ? error.message : 'An unknown server error occurred.';
    // Ensure a Vapi-compatible error format even for unexpected errors
    return createVapiResponse(toolCallId, undefined, `Booking failed due to an unexpected error: ${message}`, 500);
  } finally {
    await prisma.$disconnect().catch(e => log('Error disconnecting Prisma', e));
  }
}

// Handle CORS preflight OPTIONS request
export async function OPTIONS() {
  return new NextResponse(null, { status: 204, headers: corsHeaders });
}

================
File: app/api/patients/route.ts
================
import { NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// GET all patients
export async function GET() {
  try {
    const patients = await prisma.patient.findMany({
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phoneNumber: true,
      },
      orderBy: {
        lastName: 'asc',
      },
    })
    
    return NextResponse.json(patients)
  } catch (error) {
    console.error('Error fetching patients:', error)
    return NextResponse.json(
      { error: 'Failed to fetch patients' },
      { status: 500 }
    )
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { firstName, lastName, email, phoneNumber, dateOfBirth, userId } = body
    
    const patient = await prisma.patient.create({
      data: {
        firstName,
        lastName,
        email,
        phoneNumber,
        dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : null,
        userId,
      },
      include: {
        user: {
          select: {
            name: true,
            email: true,
          },
        },
      },
    })
    
    return NextResponse.json(patient, { status: 201 })
  } catch (error) {
    console.error('Error creating patient:', error)
    return NextResponse.json(
      { error: 'Failed to create patient' },
      { status: 500 }
    )
  }
}

================
File: app/api/update-assistant-tool/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

// Simplified interface for assistant model
interface AssistantModel {
  provider?: string;
  model?: string;
  messages?: Array<{ role: string; content?: string }>;
  tools?: Array<{
    type: string;
    function?: {
      name?: string;
      description?: string;
      parameters?: Record<string, unknown>;
    };
    description?: string;
  }>;
  toolIds?: string[];
}

// Simplified interface for assistant data
interface Assistant {
  id: string;
  model?: AssistantModel;
}

export async function POST(request: Request) {
  // --- Basic Setup & Validation ---
  if (!VAPI_API_KEY) {
    console.error('[update-assistant-tool] VAPI_API_KEY is not set');
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  let assistantId: string | undefined;
  let toolIdToAdd: string | undefined;

  try {
    const body = await request.json();
    assistantId = body.assistantId;
    toolIdToAdd = body.toolId;

    if (!assistantId || typeof assistantId !== 'string') {
      return NextResponse.json({ error: 'assistantId (string) is required in the request body' }, { status: 400 });
    }
    if (!toolIdToAdd || typeof toolIdToAdd !== 'string') {
      return NextResponse.json({ error: 'toolId (string) is required in the request body' }, { status: 400 });
    }

    console.log(`[update-assistant-tool] Request received for assistant ${assistantId} to add tool ${toolIdToAdd}`);

    // --- 1. Fetch current assistant configuration ---
    console.log('[update-assistant-tool] Fetching current config for assistant...');
    
    const fetchResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
      },
    });

    if (!fetchResponse.ok) {
      const errorBody = await fetchResponse.text();
      console.error(`[update-assistant-tool] Failed to fetch assistant ${assistantId}. Status: ${fetchResponse.status}, Body: ${errorBody}`);
      return NextResponse.json({
        error: `Vapi API Error: Failed to fetch assistant. Status: ${fetchResponse.status}`,
        details: errorBody
      }, { status: fetchResponse.status });
    }
    
    const currentAssistant: Assistant = await fetchResponse.json();
    console.log('[update-assistant-tool] Successfully fetched current config.');

    // --- 2. Prepare PATCH payload ---
    // Ensure model object exists, provide defaults if necessary
    const currentModel = currentAssistant.model || { provider: 'openai', model: 'gpt-4o' };

    // Get existing toolIds, ensure it's an array, handle null/undefined
    const existingToolIds = Array.isArray(currentModel.toolIds) ? currentModel.toolIds : [];

    // Add the new toolId, avoiding duplicates
    const updatedToolIdsSet = new Set([...existingToolIds, toolIdToAdd]);
    const finalToolIds = Array.from(updatedToolIdsSet);

    // Construct the payload for PATCH - *only include the model part*
    // Vapi's PATCH should merge this with the existing assistant data
    const updatePayload = {
      model: {
        ...currentModel,   // Keep existing model properties (provider, model name, messages, *transient tools*)
        toolIds: finalToolIds, // Set the new, combined array of tool IDs
      },
      // DO NOT include other top-level assistant properties unless you intend to update them.
      // PATCH should merge the 'model' object.
    };

    console.log(`[update-assistant-tool] Preparing to PATCH assistant ${assistantId} with toolIds: ${finalToolIds.join(', ')}`);
    console.log('[update-assistant-tool] Full PATCH payload (model part):', JSON.stringify(updatePayload, null, 2));

    // --- 3. Send PATCH request ---
    console.log(`[update-assistant-tool] Sending PATCH request for assistant ${assistantId}...`);
    
    const updateResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updatePayload),
    });

    const responseData = await updateResponse.json();

    if (!updateResponse.ok) {
      console.error(`[update-assistant-tool] Vapi API Error (Update Assistant ${assistantId}): ${updateResponse.status}`, responseData);
      return NextResponse.json({ 
        error: `Failed to update assistant: ${responseData.message || updateResponse.statusText}` 
      }, { status: updateResponse.status });
    }

    console.log(`[update-assistant-tool] Successfully updated assistant ${assistantId}.`);
    return NextResponse.json({ success: true, assistant: responseData });

  } catch (error) {
    console.error('[update-assistant-tool] Unexpected error:', error);
    const message = error instanceof Error ? error.message : 'Unknown error during assistant update';
    // Include assistantId in error response if available
    const errorResponse = assistantId
        ? { error: `Internal Server Error updating assistant ${assistantId}`, details: message }
        : { error: 'Internal Server Error', details: message };
    return NextResponse.json(errorResponse, { status: 500 });
  }
}

================
File: app/call-logs/page.tsx
================
"use client";

import { useState, useEffect } from 'react';
import Link from 'next/link';

interface CallInfo {
  callId: string;
  createdAt: string;
  endedAt: string | null;
  endedReason: string | null;
  transcript: string | null;
  summary: string | null;
  structuredData: Record<string, unknown> | null;
}

interface TranscriptEntry {
  role?: string;
  content: string;
  id?: string;
}

export default function CallLogsPage() {
  const [calls, setCalls] = useState<CallInfo[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedCall, setSelectedCall] = useState<string | null>(null);
  const [assistantId, setAssistantId] = useState<string>('');

  // Load assistant ID from environment
  useEffect(() => {
    const fetchAssistantId = async () => {
      try {
        const res = await fetch('/api/assistant-config');
        if (!res.ok) throw new Error('Failed to load configuration');
        
        const data = await res.json();
        if (data.assistantId) {
          setAssistantId(data.assistantId);
        } else {
          setError('No assistant ID found in configuration');
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      }
    };
    
    fetchAssistantId();
  }, []);

  // Load calls from the API when assistantId changes
  useEffect(() => {
    const fetchCalls = async () => {
      if (!assistantId) return;
      
      try {
        setLoading(true);
        const res = await fetch(`/api/call-logs?assistantId=${assistantId}`);
        
        if (!res.ok) {
          throw new Error('Failed to fetch call logs');
        }
        
        const data = await res.json();
        setCalls(data);
        
        // Select the first call by default if available
        if (data.length > 0 && !selectedCall) {
          setSelectedCall(data[0].callId);
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };
    
    fetchCalls();
  }, [assistantId, selectedCall]);

  // Function to format date
  const formatDate = (dateStr: string | null) => {
    if (!dateStr) return 'N/A';
    return new Date(dateStr).toLocaleString();
  };

  // Function to get selected call data
  const getSelectedCallData = () => {
    return calls.find(call => call.callId === selectedCall);
  };

  // Generate a stable key for transcript lines
  const getStableKey = (content: string, index: number): string => {
    // Create a simple hash from the content
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      hash = ((hash << 5) - hash) + content.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return `transcript-${index}-${hash}`;
  };

  // Format transcript for readability
  const formatTranscript = (transcript: string | null) => {
    if (!transcript) return 'No transcript available';
    
    // Parse the transcript if it's in a specific format
    try {
      // Try to parse as JSON
      const entries: TranscriptEntry[] = JSON.parse(transcript);
      return entries.map((entry, index) => (
        <div key={getStableKey(entry.content, index)} className={`mb-2 ${entry.role === 'assistant' ? 'text-blue-700' : 'text-gray-800'}`}>
          <span className="font-semibold">{entry.role || 'unknown'}:</span> {entry.content}
        </div>
      ));
    } catch {
      // If it's plain text or failed to parse
      // Simple format assuming "Speaker: Text" format with newlines
      const lines = transcript.split('\n');
      return lines.map((line, index) => (
        <div key={getStableKey(line, index)} className="mb-1">
          {line}
        </div>
      ));
    }
  };

  const selectedCallData = getSelectedCallData();

  // Handle call selection with keyboard support
  const handleCallSelect = (callId: string) => {
    setSelectedCall(callId);
  };

  return (
    <div className="container mx-auto p-4">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Call Logs</h1>
        <div className="flex gap-4">
          <Link 
            href="/calendar" 
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Calendar
          </Link>
          <Link 
            href="/custom-functions" 
            className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
          >
            Custom Functions
          </Link>
        </div>
      </div>
      
      {assistantId && (
        <div className="mb-4 p-3 bg-blue-50 rounded-lg">
          <p className="text-sm">
            <span className="font-medium">Assistant ID:</span> {assistantId}
          </p>
        </div>
      )}
      
      {loading && (
        <div className="flex justify-center p-8">Loading call logs...</div>
      )}
      
      {error && (
        <div className="p-4 mb-4 text-red-600 bg-red-100 rounded">Error: {error}</div>
      )}
      
      {!loading && !error && assistantId && calls.length === 0 && (
        <div className="p-8 text-center text-gray-500">
          No calls found for this Assistant ID
        </div>
      )}
      
      {calls.length > 0 && (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {/* Call List */}
          <div className="col-span-1 border rounded-lg overflow-hidden">
            <div className="bg-gray-100 p-3 font-bold">Call History</div>
            <div className="divide-y max-h-[500px] overflow-y-auto">
              {calls.map(call => (
                <button
                  key={call.callId}
                  type="button"
                  className={`w-full text-left p-3 block cursor-pointer hover:bg-gray-50 ${
                    selectedCall === call.callId ? 'bg-blue-50' : ''
                  }`}
                  onClick={() => handleCallSelect(call.callId)}
                  role="tab"
                  aria-selected={selectedCall === call.callId}
                >
                  <div className="font-medium">{formatDate(call.createdAt)}</div>
                  <div className="text-sm text-gray-600">
                    Duration: {call.endedAt 
                      ? `${Math.round((new Date(call.endedAt).getTime() - new Date(call.createdAt).getTime()) / 1000)} seconds`
                      : 'Ongoing'}
                  </div>
                  <div className="text-xs text-gray-500">ID: {call.callId}</div>
                </button>
              ))}
            </div>
          </div>
          
          {/* Call Details */}
          <div className="col-span-1 md:col-span-2 border rounded-lg overflow-hidden">
            <div className="bg-gray-100 p-3 font-bold">Call Details</div>
            
            {selectedCallData ? (
              <div className="p-4">
                <div className="mb-4">
                  <h3 className="text-lg font-bold">Call {selectedCallData.callId}</h3>
                  <div className="grid grid-cols-2 gap-2 text-sm">
                    <div><span className="font-medium">Started:</span> {formatDate(selectedCallData.createdAt)}</div>
                    <div><span className="font-medium">Ended:</span> {formatDate(selectedCallData.endedAt)}</div>
                    <div><span className="font-medium">Reason:</span> {selectedCallData.endedReason || 'N/A'}</div>
                  </div>
                </div>
                
                {selectedCallData.summary && (
                  <div className="mb-4">
                    <h4 className="font-bold mb-2">Summary</h4>
                    <div className="p-3 bg-gray-50 rounded text-sm">
                      {selectedCallData.summary}
                    </div>
                  </div>
                )}
                
                {selectedCallData.structuredData && (
                  <div className="mb-4">
                    <h4 className="font-bold mb-2">Structured Data</h4>
                    <pre className="p-3 bg-gray-50 rounded text-sm overflow-x-auto">
                      {JSON.stringify(selectedCallData.structuredData, null, 2)}
                    </pre>
                  </div>
                )}
                
                <div>
                  <h4 className="font-bold mb-2">Transcript</h4>
                  <div className="p-3 bg-gray-50 rounded text-sm max-h-[400px] overflow-y-auto">
                    {formatTranscript(selectedCallData.transcript)}
                  </div>
                </div>
              </div>
            ) : (
              <div className="p-8 text-center text-gray-500">
                Select a call to view details
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

================
File: app/page.tsx
================
import { redirect } from "next/navigation"

export default function Home() {
  redirect("/dashboard")
}

================
File: components/ToolListModal.tsx
================
"use client";

import React, { useState, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
  SheetTrigger,
} from "@/components/ui/sheet";
import { ListTree, Loader2, AlertCircle, ChevronDown, ChevronUp } from 'lucide-react';
import { Alert, AlertTitle, AlertDescription } from "@/components/ui/alert";

// Use a more generic type for the full Vapi Tool structure
interface VapiTool {
  id?: string;
  type: string;
  function?: {
    name?: string;
    description?: string;
    parameters?: Record<string, unknown>;
  };
  description?: string;
  destinations?: string[];
  knowledgeBases?: string[];
  [key: string]: unknown; // Allow for any other properties
}

interface ToolListModalProps {
  assistantId: string;
}

export function ToolListModal({ assistantId }: ToolListModalProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [tools, setTools] = useState<VapiTool[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [expandedTool, setExpandedTool] = useState<string | null>(null); // Track which tool detail is open

  useEffect(() => {
    const fetchTools = async () => {
      if (!isOpen || !assistantId) return; // Only fetch when open and ID is available

      setIsLoading(true);
      setError(null);
      setTools([]); // Clear previous tools
      setExpandedTool(null); // Reset expanded state
      
      try {
        console.log(`[ToolListModal] Fetching tools for assistant: ${assistantId}`);
        const response = await fetch(`/api/get-assistant-tools?id=${assistantId}`);
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || `Failed to fetch tools (status: ${response.status})`);
        }
        console.log(`[ToolListModal] Received ${data.tools?.length ?? 0} tools from API.`);
        setTools(data.tools || []);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Could not load tools');
        console.error("[ToolListModal] Fetch Error:", err);
        setTools([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchTools();
  }, [isOpen, assistantId]); // Refetch when modal opens or assistantId changes

  const toggleExpand = (toolIdentifier: string) => {
    setExpandedTool(prev => (prev === toolIdentifier ? null : toolIdentifier));
  };

  // Helper to get a display name (prioritize function name)
  const getToolDisplayName = (tool: VapiTool): string => {
     return tool.function?.name || tool.type || 'Unnamed Tool';
  };

  // Helper to get a description (prioritize function description)
  const getToolDescription = (tool: VapiTool): string | undefined => {
     return tool.function?.description || tool.description;
  };

  return (
    <Sheet open={isOpen} onOpenChange={setIsOpen}>
      <SheetTrigger asChild>
        <Button
          variant="outline"
          size="icon"
          className="fixed bottom-4 left-4 z-40 shadow-lg rounded-full"
          aria-label="Show Assistant Tools"
        >
          <ListTree className="h-5 w-5" />
        </Button>
      </SheetTrigger>
      <SheetContent side="left" className="w-[90vw] max-w-[600px] sm:max-w-[700px] overflow-y-auto">
        <SheetHeader>
          <SheetTitle>Configured Assistant Tools</SheetTitle>
          <SheetDescription>
            Tools available to assistant ID: <code className="text-xs bg-muted px-1 py-0.5 rounded">{assistantId}</code>
          </SheetDescription>
        </SheetHeader>
        <div className="py-4">
          {isLoading ? (
            <div className="flex justify-center items-center p-8">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : error ? (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>Error</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          ) : tools.length === 0 ? (
            <p className="text-center text-muted-foreground py-8">No tools configured for this assistant.</p>
          ) : (
            <ul className="space-y-3">
              {tools.map((tool) => {
                const toolKey = tool.id || `${getToolDisplayName(tool)}-${tool.type}`; // Use ID or name as key
                const isExpanded = expandedTool === toolKey;
                return (
                  <li key={toolKey} className="border dark:border-gray-700 rounded-md overflow-hidden">
                    <button
                      type="button"
                      onClick={() => toggleExpand(toolKey)}
                      className="w-full flex justify-between items-center p-3 text-left bg-card hover:bg-accent focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-1 focus:ring-offset-background"
                      aria-expanded={isExpanded}
                      aria-controls={`tool-details-${toolKey}`}
                    >
                      <div className="flex-1 min-w-0">
                        <p className="font-semibold text-card-foreground truncate">{getToolDisplayName(tool)}</p>
                        <p className="text-xs text-muted-foreground mt-1">Type: {tool.type}</p>
                        {getToolDescription(tool) && (
                          <p className="text-sm text-muted-foreground mt-1 truncate">{getToolDescription(tool)}</p>
                        )}
                        {tool.id && <p className="text-xs text-muted-foreground mt-1">ID: {tool.id}</p>}
                      </div>
                      {isExpanded ? 
                        <ChevronUp className="h-5 w-5 ml-2 flex-shrink-0" /> : 
                        <ChevronDown className="h-5 w-5 ml-2 flex-shrink-0" />
                      }
                    </button>

                    {/* Collapsible Content */}
                    {isExpanded && (
                      <div
                        id={`tool-details-${toolKey}`}
                        className="p-3 bg-muted/30 border-t"
                      >
                        <h4 className="text-sm font-medium mb-2 text-muted-foreground">Full Configuration:</h4>
                        <pre className="bg-muted p-3 rounded text-xs overflow-x-auto">
                          <code>
                            {JSON.stringify(tool, null, 2)}
                          </code>
                        </pre>
                      </div>
                    )}
                  </li>
                );
              })}
            </ul>
          )}
        </div>
      </SheetContent>
    </Sheet>
  );
}

================
File: prisma/seed.ts
================
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // Clean the database
  await prisma.appointment.deleteMany({})
  await prisma.patient.deleteMany({})
  await prisma.user.deleteMany({})

  console.log('Seeding the database...')
  
  // Create admin user
  const admin = await prisma.user.create({
    data: {
      email: 'admin@airodental.com',
      name: 'Admin User',
      role: 'ADMIN',
    },
  })
  
  // Create a dentist
  const dentist = await prisma.user.create({
    data: {
      email: 'dentist@airodental.com',
      name: 'Dr. Smith',
      role: 'DENTIST',
    },
  })
  
  // Create a receptionist
  const receptionist = await prisma.user.create({
    data: {
      email: 'receptionist@airodental.com',
      name: 'Jane Doe',
      role: 'RECEPTIONIST',
    },
  })
  
  console.log('Created users:', { admin, dentist, receptionist })
  
  // Create patients
  const patient1 = await prisma.patient.create({
    data: {
      firstName: 'John',
      lastName: 'Doe',
      email: 'john.doe@example.com',
      phoneNumber: '555-123-4567',
      dateOfBirth: new Date('1985-05-15'),
      userId: dentist.id,
    },
  })
  
  const patient2 = await prisma.patient.create({
    data: {
      firstName: 'Alice',
      lastName: 'Smith',
      email: 'alice.smith@example.com',
      phoneNumber: '555-987-6543',
      dateOfBirth: new Date('1990-10-20'),
      userId: dentist.id,
    },
  })
  
  console.log('Created patients:', { patient1, patient2 })
  
  // Create appointments
  const today = new Date()
  const tomorrow = new Date(today)
  tomorrow.setDate(tomorrow.getDate() + 1)
  
  const nextWeek = new Date(today)
  nextWeek.setDate(nextWeek.getDate() + 7)
  
  const appointment1 = await prisma.appointment.create({
    data: {
      date: tomorrow,
      reason: 'Regular checkup',
      patientType: 'EXISTING',
      status: 'CONFIRMED',
      notes: 'Patient has sensitivity in lower right molar',
      patientId: patient1.id,
    },
  })
  
  const appointment2 = await prisma.appointment.create({
    data: {
      date: nextWeek,
      reason: 'Teeth cleaning',
      patientType: 'EXISTING',
      status: 'SCHEDULED',
      notes: 'Follow-up appointment after filling',
      patientId: patient2.id,
    },
  })
  
  // Add a few more appointments for the week
  const dayAfterTomorrow = new Date(today)
  dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 2)
  
  const threeDaysFromNow = new Date(today)
  threeDaysFromNow.setDate(threeDaysFromNow.getDate() + 3)
  
  const fourDaysFromNow = new Date(today)
  fourDaysFromNow.setDate(fourDaysFromNow.getDate() + 4)
  
  await prisma.appointment.create({
    data: {
      date: dayAfterTomorrow,
      reason: 'New patient consultation',
      patientType: 'NEW',
      status: 'CONFIRMED',
      notes: 'First visit, comprehensive exam needed',
      patientId: patient1.id,
    },
  })
  
  await prisma.appointment.create({
    data: {
      date: threeDaysFromNow,
      reason: 'Root canal',
      patientType: 'EXISTING',
      status: 'SCHEDULED',
      notes: 'Patient reported severe pain',
      patientId: patient2.id,
    },
  })
  
  await prisma.appointment.create({
    data: {
      date: fourDaysFromNow,
      reason: 'Wisdom tooth extraction',
      patientType: 'EXISTING',
      status: 'SCHEDULED',
      notes: 'X-rays already taken',
      patientId: patient1.id,
    },
  })
  
  console.log('Created appointments for the week')
  
  console.log('Database seeding completed.')
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error('Error during seeding:', e)
    await prisma.$disconnect()
    process.exit(1)
  })

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "scripts"]
}

================
File: app/ai-customiser/_components/TrainTab.tsx
================
"use client";

import type React from 'react';
import { useState, useEffect, useCallback } from 'react';
import {
    Accordion,
    AccordionContent,
    AccordionItem,
    AccordionTrigger,
} from "@/components/ui/accordion";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import {
    Dialog,
    DialogContent,
    DialogHeader,
    DialogTitle,
    DialogDescription,
    DialogFooter,
    DialogClose,
} from "@/components/ui/dialog";
import {
    Loader2,
    AlertCircle,
    FileText,
    Info,
    PlusCircle,
    Pencil,
    Trash2
} from 'lucide-react';
import { Skeleton } from '@/components/ui/skeleton';

// Interface matching the data returned by GET /api/knowledge-topics
interface KnowledgeTopic {
    id: string; // This is the Prisma ID
    topicName: string;
    content: string;
    assistantId: string;
    vapiToolId: string | null; // Vapi Tool ID is crucial for updates/deletes
    vapiFileId: string | null;
    createdAt: string;
    updatedAt: string;
    // Add other vapi IDs if needed for display/debugging
}

interface TrainTabProps {
    assistantId: string;
}

export function TrainTab({ assistantId }: TrainTabProps) {
    const [knowledgeTopics, setKnowledgeTopics] = useState<KnowledgeTopic[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    // State for the Add/Edit Modal
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [editingTopic, setEditingTopic] = useState<KnowledgeTopic | null>(null); // null for Add mode
    const [modalTopicName, setModalTopicName] = useState('');
    const [modalContent, setModalContent] = useState('');
    const [isSaving, setIsSaving] = useState(false);
    const [modalError, setModalError] = useState<string | null>(null);

    // State for delete operation loading indicator
    const [deletingTopicId, setDeletingTopicId] = useState<string | null>(null);

    // Fetch topics function
    const fetchTopics = useCallback(async () => {
        if (!assistantId) return;
        setIsLoading(true);
        setError(null);
        try {
            const response = await fetch(`/api/knowledge-topics?assistantId=${assistantId}`);
            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.error || `Failed to fetch knowledge topics (${response.status})`);
            }
            const data: KnowledgeTopic[] = await response.json();
            setKnowledgeTopics(data);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Could not load knowledge topics.');
            console.error("Fetch Topics Error:", err);
        } finally {
            setIsLoading(false);
        }
    }, [assistantId]);

    // Initial fetch
    useEffect(() => {
        fetchTopics();
    }, [fetchTopics]);

    // --- Modal Handlers ---
    const handleOpenAddModal = () => {
        setEditingTopic(null);
        setModalTopicName('');
        setModalContent('');
        setModalError(null);
        setIsModalOpen(true);
    };

    const handleOpenEditModal = (topic: KnowledgeTopic, e: React.MouseEvent) => {
        e.stopPropagation();
        setEditingTopic(topic);
        setModalTopicName(topic.topicName);
        setModalContent(topic.content);
        setModalError(null);
        setIsModalOpen(true);
    };

    const handleModalSave = async () => {
        setIsSaving(true);
        setModalError(null);
        setError(null); // Clear main page error

        const apiUrl = editingTopic
            ? `/api/knowledge-topics/${editingTopic.vapiToolId}` // PUT for update
            : '/api/knowledge-topics'; // POST for create

        const method = editingTopic ? 'PUT' : 'POST';

        const payload = {
            assistantId: assistantId,
            topicName: modalTopicName,
            content: modalContent,
        };

        try {
            const response = await fetch(apiUrl, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || `Failed to ${editingTopic ? 'update' : 'create'} topic (${response.status})`);
            }

            setIsModalOpen(false); // Close modal on success
            fetchTopics(); // Refresh the list

        } catch (err) {
            const message = err instanceof Error ? err.message : `Could not ${editingTopic ? 'update' : 'create'} topic.`;
            setModalError(message);
            console.error("Save Topic Error:", err);
        } finally {
            setIsSaving(false);
        }
    };

    // --- Delete Handler ---
    const handleDeleteClick = async (topic: KnowledgeTopic, e: React.MouseEvent) => {
        e.stopPropagation();
        if (!topic.vapiToolId) {
            setError("Cannot delete topic: Missing Vapi Tool ID.");
            return;
        }
        if (!window.confirm(`Are you sure you want to delete the topic "${topic.topicName}"? This will remove the associated knowledge from Vapi.`)) {
            return;
        }

        setDeletingTopicId(topic.vapiToolId);
        setError(null); // Clear main page error
        setModalError(null); // Clear modal error

        try {
            const response = await fetch(`/api/knowledge-topics/${topic.vapiToolId}`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                // Send assistantId in body for potential verification on backend
                body: JSON.stringify({ assistantId })
            });

            if (!response.ok && response.status !== 204) { // Allow 204 No Content
                const data = await response.json().catch(() => ({})); // Try to parse error, default to empty obj
                throw new Error(data.error || `Failed to delete topic (${response.status})`);
            }

            fetchTopics(); // Refresh the list

        } catch (err) {
            const message = err instanceof Error ? err.message : 'Could not delete topic.';
            setError(message); // Show error on main page
            console.error("Delete Topic Error:", err);
        } finally {
            setDeletingTopicId(null);
        }
    };

    return (
        <div className="space-y-6 p-4 border rounded-lg bg-white dark:bg-gray-800 shadow-sm">
            <h2 className="text-xl font-semibold mb-2 flex items-center">
                <FileText className="mr-2 h-5 w-5 text-gray-600 dark:text-gray-400" /> Train Your Assistant
            </h2>

            <Alert variant="default" className="bg-blue-50 dark:bg-blue-900 border-blue-200 dark:border-blue-700">
                <Info className="h-4 w-4 text-blue-600 dark:text-blue-300 mt-1" />
                <AlertTitle className="text-blue-800 dark:text-blue-200">Manage Knowledge Topics</AlertTitle>
                <AlertDescription className="text-blue-700 dark:text-blue-300 text-sm">
                    Add, edit, or delete specific knowledge topics for your assistant. Each topic is uploaded as a separate document.
                    Remember to update your assistant&apos;s system prompt in the &apos;Configure&apos; tab to guide it on *when* to use the knowledge from a specific topic (referencing it by the Topic Name you provide here).
                </AlertDescription>
            </Alert>

            {error && (
                <Alert variant="destructive">
                    <AlertCircle className="h-4 w-4" />
                    <AlertTitle>Error</AlertTitle>
                    <AlertDescription>{error}</AlertDescription>
                </Alert>
            )}

            {isLoading ? (
                <div className="space-y-3 py-4">
                    <Skeleton className="h-12 w-full" />
                    <Skeleton className="h-12 w-full" />
                    <Skeleton className="h-12 w-full" />
                </div>
            ) : (
                <>
                    <Accordion type="single" collapsible className="w-full space-y-2">
                        {knowledgeTopics.length === 0 && (
                             <p className="text-center text-muted-foreground py-6">No knowledge topics added yet.</p>
                        )}
                        {knowledgeTopics.map((topic) => (
                            <AccordionItem value={topic.vapiToolId || topic.id} key={topic.vapiToolId || topic.id} className="border dark:border-gray-700 rounded-md bg-card overflow-hidden">
                                <AccordionTrigger className="hover:no-underline px-4 py-3 text-left w-full">
                                    <div className="flex justify-between items-center w-full" >
                                        <span className="font-medium text-card-foreground truncate mr-4">{topic.topicName}</span>
                                        <div className="flex gap-1 flex-shrink-0">
                                            <Button variant="ghost" size="icon" className="h-7 w-7" onClick={(e) => handleOpenEditModal(topic, e)} disabled={!!deletingTopicId}>
                                                <Pencil className="h-4 w-4" />
                                                <span className="sr-only">Edit {topic.topicName}</span>
                                            </Button>
                                            <Button variant="ghost" size="icon" className="text-destructive hover:text-destructive h-7 w-7" onClick={(e) => handleDeleteClick(topic, e)} disabled={deletingTopicId === topic.vapiToolId || !topic.vapiToolId}>
                                                {deletingTopicId === topic.vapiToolId ? <Loader2 className="h-4 w-4 animate-spin" /> : <Trash2 className="h-4 w-4" />}
                                                <span className="sr-only">Delete {topic.topicName}</span>
                                            </Button>
                                        </div>
                                    </div>
                                </AccordionTrigger>
                                <AccordionContent className="px-4 pb-4 pt-0">
                                    <Textarea
                                        readOnly
                                        value={topic.content}
                                        className="w-full font-mono text-xs bg-muted/30 border-none h-auto min-h-[100px] max-h-[300px] overflow-y-auto"
                                        rows={Math.min(15, topic.content.split('\n').length + 1)}
                                    />
                                </AccordionContent>
                            </AccordionItem>
                        ))}
                    </Accordion>

                    <Button onClick={handleOpenAddModal} className="w-full mt-4">
                        <PlusCircle className="mr-2 h-4 w-4" /> Add New Knowledge Topic
                    </Button>
                </>
            )}

            {/* Add/Edit Modal */}
            <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
                <DialogContent className="sm:max-w-[600px]">
                    <DialogHeader>
                        <DialogTitle>{editingTopic ? 'Edit Knowledge Topic' : 'Add New Knowledge Topic'}</DialogTitle>
                        <DialogDescription>
                            {editingTopic ? `Modify the name and content for &quot;${editingTopic.topicName}&quot;.` : 'Provide a name and the content for this knowledge topic.'} Remember to update the assistant&apos;s system prompt to utilize this topic.
                        </DialogDescription>
                    </DialogHeader>
                    <div className="py-4 space-y-4">
                        <div>
                            <Label htmlFor="modalTopicName">Topic Name</Label>
                            <Input
                                id="modalTopicName"
                                value={modalTopicName}
                                onChange={(e) => setModalTopicName(e.target.value)}
                                placeholder="e.g., Office Hours, Insurance Policy"
                                className="mt-1"
                                disabled={isSaving}
                            />
                             <p className="text-xs text-muted-foreground mt-1">A user-friendly name for this knowledge.</p>
                        </div>
                        <div>
                            <Label htmlFor="modalContent">Knowledge Content</Label>
                            <Textarea
                                id="modalContent"
                                value={modalContent}
                                onChange={(e) => setModalContent(e.target.value)}
                                rows={12}
                                className="mt-1 w-full font-mono text-sm"
                                placeholder="Enter Q&A pairs, policy details, or other information..."
                                disabled={isSaving}
                            />
                        </div>
                        {modalError && (
                            <Alert variant="destructive">
                                <AlertCircle className="h-4 w-4" />
                                <AlertTitle>Error</AlertTitle>
                                <AlertDescription>{modalError}</AlertDescription>
                            </Alert>
                        )}
                    </div>
                    <DialogFooter>
                        <DialogClose asChild>
                            <Button type="button" variant="outline" disabled={isSaving}>
                                Cancel
                            </Button>
                        </DialogClose>
                        <Button type="button" onClick={handleModalSave} disabled={isSaving || !modalTopicName.trim() || !modalContent.trim()}>
                            {isSaving ? <Loader2 className="animate-spin mr-2 h-4 w-4" /> : null}
                            {isSaving ? 'Saving...' : (editingTopic ? 'Update Topic' : 'Add Topic')}
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </div>
    );
}

================
File: app/ai-customiser/page.tsx
================
"use client"

import React, { useState, useEffect, useCallback } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ConfigureTab } from './_components/ConfigureTab';
import { TrainTab } from './_components/TrainTab';
import { TestTab } from './_components/TestTab';
import { Loader2, AlertCircle } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { ToolListModal } from '@/components/ToolListModal';

// Define a simplified type for the config needed by ConfigureTab
export interface AssistantConfig {
  name?: string;
  model?: {
    provider?: string;
    model?: string;
    messages?: Array<{ role: string; content?: string }>;
  };
  voice?: {
    provider?: string;
    voiceId?: string;
  };
  // Add other relevant fields as needed by ConfigureTab
}

export default function AICustomiserPage() {
  const [assistantConfig, setAssistantConfig] = useState<AssistantConfig | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [errorMessage, setErrorMessage] = useState<string>('');

  const assistantId = process.env.NEXT_PUBLIC_VAPI_ASSISTANT_ID;

  const fetchAssistantConfig = useCallback(async () => {
    if (!assistantId) {
      setErrorMessage("Assistant ID not configured in environment variables.");
      setIsLoading(false);
      return;
    }
    setIsLoading(true);
    setErrorMessage('');
    try {
      const response = await fetch(`/api/get-assistant-config?id=${assistantId}`);
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || `Failed to fetch config (status: ${response.status})`);
      }
      setAssistantConfig(data);
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error loading configuration.';
      console.error("Fetch config error:", error);
      setErrorMessage(message);
      setAssistantConfig(null); // Clear config on error
    } finally {
      setIsLoading(false);
    }
  }, [assistantId]);

  useEffect(() => {
    fetchAssistantConfig();
  }, [fetchAssistantConfig]);

  return (
    <div className="flex flex-col p-6 relative">
      <h1 className="text-2xl font-bold mb-6">AI Customiser</h1>
      {!assistantId && (
        <Alert variant="destructive" className="mb-4">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Configuration Error</AlertTitle>
          <AlertDescription>
            Assistant ID is not set. Please contact your administrator.
          </AlertDescription>
        </Alert>
      )}

      {isLoading ? (
        <div className="flex justify-center items-center h-64">
          <Loader2 className="animate-spin h-12 w-12 text-primary" />
        </div>
      ) : errorMessage ? (
         <Alert variant="destructive">
           <AlertCircle className="h-4 w-4" />
           <AlertTitle>Error Loading Configuration</AlertTitle>
           <AlertDescription>{errorMessage}</AlertDescription>
         </Alert>
      ) : assistantConfig && assistantId ? (
        <Tabs defaultValue="configure" className="w-full">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="configure">Configure</TabsTrigger>
            <TabsTrigger value="train">Train</TabsTrigger>
            <TabsTrigger value="test">Test</TabsTrigger>
          </TabsList>
          <TabsContent value="configure" className="mt-4">
            <ConfigureTab
              initialConfig={assistantConfig}
              assistantId={assistantId}
            />
          </TabsContent>
          <TabsContent value="train" className="mt-4">
            <TrainTab assistantId={assistantId} />
          </TabsContent>
          <TabsContent value="test" className="mt-4">
            <TestTab assistantId={assistantId} />
          </TabsContent>
        </Tabs>
      ) : (
         <p>Could not load assistant configuration.</p> // Fallback if config is null but no error message
      )}
      
      {assistantId && <ToolListModal assistantId={assistantId} />}
    </div>
  );
}

================
File: app/api/call-logs/route.ts
================
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';

interface CallInfo {
  callId: string;
  createdAt: string;
  endedAt: string | null;
  endedReason: string | null;
  transcript: string | null;
  summary: string | null;
  structuredData: Record<string, unknown> | null;
}

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const assistantId = searchParams.get('assistantId');

  if (!assistantId) {
    return NextResponse.json(
      { error: 'assistantId is required' },
      { status: 400 }
    );
  }

  try {
    // Initialize the Vapi client with the API key
    const client = new VapiClient({ 
      token: process.env.VAPI_API_KEY || '' 
    });

    // Get calls for this assistant
    const calls = await client.calls.list({ assistantId, limit: 50 });
    console.log(`Found ${calls.length} calls for assistant ${assistantId}`);

    // Fetch detailed information for each call
    const detailedCalls: CallInfo[] = [];
    
    for (const basicCall of calls) {
      if (!basicCall.id) continue;
      
      try {
        const detailedCall = await client.calls.get(basicCall.id);
        
        detailedCalls.push({
          callId: detailedCall.id,
          createdAt: detailedCall.createdAt as string,
          endedAt: detailedCall.endedAt as string | null,
          endedReason: detailedCall.endedReason as string | null,
          transcript: detailedCall.artifact?.transcript as string | null,
          summary: detailedCall.analysis?.summary as string | null,
          structuredData: detailedCall.analysis?.structuredData as Record<string, unknown> | null,
        });
        
        console.log(`Fetched details for call: ${detailedCall.id}`);
      } catch (callDetailError) {
        console.error(`Error fetching details for call ${basicCall.id}:`, callDetailError);
      }
    }

    if (detailedCalls.length > 0) {
      return NextResponse.json(detailedCalls);
    }

    // If no calls were found or fetched, fall back to mock data
    console.log('No calls found or unable to fetch details, returning mock data');
    
    // Sample transcript for the mock call
    const sampleTranscript = `AI: Hello, this is Laine from Aero Dental. How can I assist you with scheduling an appointment today?
User: Hey, I'd like to book a cleaning.
AI: Certainly. May I have your full name, please?
User: John Daniel.
AI: Thank you, John Daniel. What will be the purpose of your visit? For example, a cleaning, filling, consultation?
User: Cleaning.
AI: Thank you. Are you a new or existing patient?
User: A new patient.
AI: Great. May I please have your email address and phone number for confirmation?
User: John daniel at g mail dot com.
AI: Thank you, John. And what phone number can we reach you at?
User: 9, double 8, double 6, 3 9 8 0 9.
AI: Thank you for providing that information. To confirm you're scheduling a cleaning appointment as a new patient, Your email is John Daniel at gmail dot com and your phone number is 9 8 8 6 3 9 8 0 9. What date and time would you prefer for your appointment?
User: I'd like to schedule an appointment for April third, 1 30 PM.
AI: I apologize, but we do not have availability at 1 30 pm on April third. However, we do have openings at 1 PM and 3 PM that day. Would either of those work for you?
User: Yes, please.
AI: Thank you. I will schedule your appointment for April third at 1 PM for a cleaning. To confirm, name, John Daniel. Appointment date, April third. Time, 1 PM. Reason, cleaning. Email, john danielgmail dot com. Phone, 9 8 8 6 3 9 8 0 9. Is everything correct?
User: Yes.
AI: Thank you, John. Your appointment is confirmed for April third at 1 PM for a cleaning. We look forward to seeing you. If you have any further questions, feel free to reach out. Have a great day.
User: Thank you.
AI: You're welcome, John. Have a wonderful day.`;

    // Return mock data for demo purposes
    const mockCalls: CallInfo[] = [
      {
        callId: "call_01abc123def456",
        createdAt: new Date(Date.now() - 120000).toISOString(), // 2 minutes ago
        endedAt: new Date(Date.now() - 30000).toISOString(), // 30 seconds ago
        endedReason: "completed",
        transcript: sampleTranscript,
        summary: "John Daniel, a new patient, called to schedule a cleaning appointment. After checking availability, an appointment was booked for April 3rd at 1:00 PM. Contact info: email: john.daniel@gmail.com, phone: 9886398009.",
        structuredData: {
          patientName: "John Daniel",
          patientType: "new",
          appointmentType: "cleaning",
          scheduledDate: "2025-04-03T13:00:00.000Z",
          contactEmail: "john.daniel@gmail.com",
          contactPhone: "9886398099"
        }
      }
    ];

    return NextResponse.json(mockCalls);
  } catch (error) {
    console.error('Error fetching calls:', error);
    
    // If there's an error with the API, return a sample call log
    const sampleTranscript = `AI: Hello, this is Laine from Aero Dental. How can I assist you with scheduling an appointment today?
User: Hey, I'd like to book a cleaning.
AI: Certainly. May I have your full name, please?
User: John Daniel.
AI: Thank you, John Daniel. What will be the purpose of your visit? For example, a cleaning, filling, consultation?
User: Cleaning.
AI: Thank you. Are you a new or existing patient?
User: A new patient.
AI: Great. May I please have your email address and phone number for confirmation?
User: John daniel at g mail dot com.
AI: Thank you, John. And what phone number can we reach you at?
User: 9, double 8, double 6, 3 9 8 0 9.
AI: Thank you for providing that information. To confirm you're scheduling a cleaning appointment as a new patient, Your email is John Daniel at gmail dot com and your phone number is 9 8 8 6 3 9 8 0 9. What date and time would you prefer for your appointment?
User: I'd like to schedule an appointment for April third, 1 30 PM.
AI: I apologize, but we do not have availability at 1 30 pm on April third. However, we do have openings at 1 PM and 3 PM that day. Would either of those work for you?
User: Yes, please.
AI: Thank you. I will schedule your appointment for April third at 1 PM for a cleaning. To confirm, name, John Daniel. Appointment date, April third. Time, 1 PM. Reason, cleaning. Email, john danielgmail dot com. Phone, 9 8 8 6 3 9 8 0 9. Is everything correct?
User: Yes.
AI: Thank you, John. Your appointment is confirmed for April third at 1 PM for a cleaning. We look forward to seeing you. If you have any further questions, feel free to reach out. Have a great day.
User: Thank you.
AI: You're welcome, John. Have a wonderful day.`;

    // Return mock data for error fallback
    const errorFallbackCalls: CallInfo[] = [
      {
        callId: "call_error_fallback",
        createdAt: new Date().toISOString(),
        endedAt: new Date().toISOString(),
        endedReason: "completed",
        transcript: sampleTranscript,
        summary: "API Error: Using fallback sample call. John Daniel, a new patient, called to schedule a cleaning appointment. After checking availability, an appointment was booked for April 3rd at 1:00 PM.",
        structuredData: {
          error: "Failed to fetch real call data",
          fallback: true
        }
      }
    ];
    
    return NextResponse.json(errorFallbackCalls);
  }
}

================
File: app/api/get-assistant-tools/route.ts
================
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

// Simplified interface for Vapi Tool structure
interface VapiTool {
  id?: string;
  type: string;
  function?: {
    name?: string;
    description?: string;
    // Add other function properties if needed
    parameters?: Record<string, unknown>;
  };
  // Some tool types might have description at the root level
  description?: string;
  destinations?: string[];
  knowledgeBases?: string[];
  // Add other potential root-level tool properties if needed
}

export async function GET(request: Request) {
  // --- Basic Setup & Validation ---
  if (!VAPI_API_KEY) {
    console.error("VAPI_API_KEY is not set in environment variables.");
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  const { searchParams } = new URL(request.url);
  const assistantId = searchParams.get('id');

  if (!assistantId) {
    console.error("Request missing assistantId query parameter.");
    return NextResponse.json({ error: 'assistantId is required' }, { status: 400 });
  }

  console.log(`[get-assistant-tools] Received request for assistantId: ${assistantId}`);

  try {
    // Initialize Vapi Client
    const vapi = new VapiClient({ token: VAPI_API_KEY });

    // --- Fetch Assistant Configuration ---
    console.log(`[get-assistant-tools] Fetching assistant configuration for ID: ${assistantId}`);
    const assistant = await vapi.assistants.get(assistantId);

    if (!assistant || !assistant.model) {
      console.log(`[get-assistant-tools] Assistant ${assistantId} not found or has no model configuration.`);
      // Return empty list if assistant or model config is missing
      return NextResponse.json({ tools: [] });
    }
    console.log(`[get-assistant-tools] Successfully fetched assistant configuration for ${assistantId}.`);

    const toolList: VapiTool[] = [];

    // --- Process Transient Tools (assistant.model.tools) ---
    if (Array.isArray(assistant.model.tools)) {
      console.log(`[get-assistant-tools] Processing ${assistant.model.tools.length} transient tools.`);
      for (const tool of assistant.model.tools as VapiTool[]) { // Cast to your defined interface
        // Add the full tool object
        toolList.push({
          ...tool,
          // Add a generated name/description if not already present
          function: {
            ...tool.function,
            name: tool.function?.name || tool.type,
            description: tool.function?.description || tool.description || `A ${tool.type} tool.`
          }
        });
      }
    } else {
      console.log('[get-assistant-tools] No transient tools found in assistant.model.tools.');
    }

    // --- Process Tools by ID (assistant.model.toolIds) ---
    if (Array.isArray(assistant.model.toolIds) && assistant.model.toolIds.length > 0) {
      console.log(`[get-assistant-tools] Processing ${assistant.model.toolIds.length} tool IDs: ${assistant.model.toolIds.join(', ')}.`);
      const toolDetailPromises = assistant.model.toolIds.map(toolId =>
        vapi.tools.get(toolId)
          .then(toolData => {
            if (toolData) {
              console.log(`[get-assistant-tools] Successfully fetched details for tool ID: ${toolId}`);
              // Return the full tool data
              return toolData as unknown as VapiTool;
            }
            console.warn(`[get-assistant-tools] Tool data for ID ${toolId} was unexpectedly null or undefined.`);
            return null; // Explicitly return null if data is missing
          })
          .catch(err => {
            console.error(`[get-assistant-tools] Failed to fetch tool ${toolId}:`, err instanceof Error ? err.message : err);
            return null; // Return null on fetch error to not break Promise.all
          })
      );

      const toolDetails = await Promise.all(toolDetailPromises);

      // Add successfully fetched tools to the list
      for (const tool of toolDetails) {
        if (tool) {
          toolList.push(tool);
        }
      }
      console.log('[get-assistant-tools] Finished processing tool IDs.');
    } else {
      console.log('[get-assistant-tools] No tool IDs found in assistant.model.toolIds.');
    }

    // --- Deduplicate and Return ---
    // Use tool ID for uniqueness if available, otherwise use type + function name as a composite key
    const uniqueToolMap = new Map<string, VapiTool>();
    for (const tool of toolList) {
      const key = tool.id || `${tool.function?.name || ''}-${tool.type}`; // Use ID if present, else composite key
      if (!uniqueToolMap.has(key)) {
        uniqueToolMap.set(key, tool);
      }
    }

    const uniqueToolList = Array.from(uniqueToolMap.values());
    console.log(`[get-assistant-tools] Returning ${uniqueToolList.length} unique tools for assistant ${assistantId}.`);

    return NextResponse.json({ tools: uniqueToolList });

  } catch (error) {
    console.error('[get-assistant-tools] Unexpected error fetching assistant tools:', error);
    const message = error instanceof Error ? error.message : 'Unknown server error occurred';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/users/route.ts
================
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { PrismaClient } from '@prisma/client'
import type { Role } from '@prisma/client'

const prismaClient = new PrismaClient()

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    const roleParam = searchParams.get('role')
    
    // Set up filter with proper typing
    const filter = roleParam ? { role: roleParam as Role } : {}
    
    const users = await prismaClient.user.findMany({
      where: filter,
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
      },
      orderBy: {
        name: 'asc',
      },
    })
    
    return NextResponse.json(users)
  } catch (error) {
    console.error('Error fetching users:', error)
    return NextResponse.json(
      { error: 'Failed to fetch users' },
      { status: 500 }
    )
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { name, email, role } = body
    
    const user = await prisma.user.create({
      data: {
        name,
        email,
        role: role || 'USER',
      },
    })
    
    return NextResponse.json(user, { status: 201 })
  } catch (error) {
    console.error('Error creating user:', error)
    return NextResponse.json(
      { error: 'Failed to create user' },
      { status: 500 }
    )
  }
}

================
File: app/patients/page.tsx
================
"use client";

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Skeleton } from '@/components/ui/skeleton';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { AlertCircle, ArrowLeft } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

type Patient = {
  id: string;
  firstName: string;
  lastName: string;
  email: string | null;
  phoneNumber: string | null;
};

export default function PatientsPage() {
  const [patients, setPatients] = useState<Patient[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPatients = async () => {
      try {
        setError(null); // Reset error on new fetch
        setLoading(true);
        const res = await fetch('/api/patients');

        if (!res.ok) {
            const errorData = await res.text(); // Get more error details
            throw new Error(`Failed to fetch patients: ${res.status} ${res.statusText} - ${errorData}`);
        }

        const data = await res.json();
        setPatients(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An unknown error occurred');
        console.error("Error fetching patients:", err); // Log error
      } finally {
        setLoading(false);
      }
    };

    fetchPatients();
  }, []);

  if (loading) {
    return (
      <div className="container mx-auto p-4 md:p-6 space-y-6">
        <div className="flex justify-between items-center">
          <Skeleton className="h-8 w-32" />
          <Skeleton className="h-10 w-40" />
        </div>
        <Card>
            <CardHeader>
                <Skeleton className="h-6 w-1/4" />
            </CardHeader>
            <CardContent>
                <div className="space-y-3">
                    <Skeleton className="h-10 w-full" /> {/* Header row skeleton */}
                    <Skeleton className="h-12 w-full" />
                    <Skeleton className="h-12 w-full" />
                    <Skeleton className="h-12 w-full" />
                </div>
            </CardContent>
        </Card>
      </div>
    );
  }

  if (error) {
     return (
        <div className="container mx-auto p-4 md:p-6">
            <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>Error Loading Patients</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
            </Alert>
            <div className="mt-4">
               <Link href="/calendar">
                   <Button variant="outline"><ArrowLeft className="mr-2 h-4 w-4"/> Back to Calendar</Button>
               </Link>
            </div>
        </div>
     );
  }

  return (
    <div className="container mx-auto p-4 md:p-6 space-y-6">
      <div className="flex justify-between items-center flex-wrap gap-2">
        <h1 className="text-2xl font-bold tracking-tight sm:text-3xl">Patients</h1>
        <Link href="/calendar">
            <Button variant="outline"><ArrowLeft className="mr-2 h-4 w-4"/> Back to Calendar</Button>
        </Link>
      </div>

       <Card>
         <CardHeader>
            <CardTitle>Patient List</CardTitle>
         </CardHeader>
         <CardContent>
            <Table>
              {/* Optional: Add TableCaption if needed */}
              {/* <TableCaption>A list of registered patients.</TableCaption> */}
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[250px]">Name</TableHead>
                  <TableHead>Email</TableHead>
                  <TableHead className="text-right">Phone Number</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {patients.length > 0 ? (
                  patients.map((patient) => (
                    <TableRow key={patient.id}>
                      <TableCell className="font-medium">{patient.firstName} {patient.lastName}</TableCell>
                      <TableCell>{patient.email || <span className='text-muted-foreground'>N/A</span>}</TableCell>
                      <TableCell className="text-right">{patient.phoneNumber || <span className='text-muted-foreground'>N/A</span>}</TableCell>
                    </TableRow>
                  ))
                ) : (
                  <TableRow>
                    <TableCell colSpan={3} className="h-24 text-center text-muted-foreground">
                      No patients found.
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
         </CardContent>
       </Card>
    </div>
  );
}

================
File: app/globals.css
================
/* Add react-big-calendar base styles FIRST */
@import 'react-big-calendar/lib/css/react-big-calendar.css';

/* Original imports */
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: #C33768;
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: #C33768;
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: #C33768;
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: #C33768;
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Custom overrides for RBC to match Shadcn - separate from Tailwind layers */
.rbc-event {
  background-color: var(--primary);
  color: var(--primary-foreground);
  border-color: var(--primary);
  border-radius: var(--radius);
  padding: 2px 5px;
  font-size: 0.8rem;
}
.rbc-event:focus {
  outline: 2px solid var(--ring);
  outline-offset: 1px;
}
.rbc-event.rbc-selected {
  background-color: color-mix(in srgb, var(--primary) 80%, transparent);
}
.rbc-slot-selecting .rbc-event { 
  background-color: color-mix(in srgb, var(--primary) 50%, transparent);
}
.rbc-toolbar button {
  color: var(--foreground);
  padding: 0.25rem 0.5rem;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  transition-property: color, background-color, border-color;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.rbc-toolbar button:hover {
  background-color: var(--accent);
  color: var(--accent-foreground);
}
.rbc-toolbar button:active, .rbc-toolbar button.rbc-active {
  background-color: var(--accent);
  color: var(--accent-foreground);
}
.rbc-off-range-bg {
  background-color: color-mix(in srgb, var(--muted) 30%, transparent);
}
.rbc-today {
  background-color: color-mix(in srgb, var(--accent) 50%, transparent);
}
.rbc-header {
  border-bottom: 1px solid var(--border);
  padding: 0.5rem 0.25rem;
  text-align: center;
}
.rbc-time-header-gutter .rbc-header, .rbc-time-gutter .rbc-timeslot-group {
  border-right: 1px solid var(--border);
}
.rbc-day-slot .rbc-time-slot {
  border-top: 1px solid var(--border);
}

================
File: components/sidebar/index.tsx
================
"use client"

import { useState } from "react"
import Link from "next/link"
import { usePathname } from "next/navigation"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet"
import {
  LayoutDashboard,
  MessageSquare,
  Users,
  Settings,
  User,
  Menu,
  LogOut,
  Sparkles,
} from "lucide-react"
import { cn } from "@/lib/utils"

const navigationItems = [
  {
    name: "Dashboard",
    href: "/dashboard",
    icon: LayoutDashboard,
  },
  {
    name: "Communications",
    href: "/communications",
    icon: MessageSquare,
  },
  {
    name: "Patient Management",
    href: "/patients",
    icon: Users,
  },
  {
    name: "AI Customiser",
    href: "/ai-customiser",
    icon: Sparkles,
  },
  {
    name: "System",
    href: "/system",
    icon: Settings,
  },
]

export function Sidebar() {
  const pathname = usePathname()
  const [open, setOpen] = useState(false)

  return (
    <>
      {/* Desktop sidebar */}
      <aside className="hidden md:flex fixed top-0 left-0 h-screen w-64 flex-col border-r p-4 overflow-y-auto">
        <div className="flex items-center gap-2 pb-6">
          <div className="rounded-full bg-primary p-1">
            <div className="h-8 w-8 rounded-full bg-white text-center text-xl font-bold leading-8 text-primary">
              A
            </div>
          </div>
          <div className="text-lg font-semibold">AiroDental</div>
        </div>
        
        <nav className="flex-1 space-y-1">
          {navigationItems.map((item) => {
            const isActive = pathname === item.href || pathname?.startsWith(`${item.href}/`)
            return (
              <Link
                key={item.href}
                href={item.href}
                className={cn(
                  "flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium",
                  isActive
                    ? "bg-primary text-primary-foreground"
                    : "text-muted-foreground hover:bg-secondary hover:text-foreground"
                )}
              >
                <item.icon className="h-5 w-5" />
                {item.name}
              </Link>
            )
          })}
        </nav>
        
        <div className="pt-6">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" className="w-full justify-start p-2">
                <Avatar className="mr-2 h-6 w-6">
                  <AvatarImage src="/placeholder-avatar.jpg" />
                  <AvatarFallback>JD</AvatarFallback>
                </Avatar>
                <span>John Doe</span>
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-56">
              <DropdownMenuLabel>My Account</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <User className="mr-2 h-4 w-4" />
                <span>Profile</span>
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Settings className="mr-2 h-4 w-4" />
                <span>Settings</span>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <LogOut className="mr-2 h-4 w-4" />
                <span>Log out</span>
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </aside>

      {/* Mobile sidebar */}
      <div className="flex items-center border-b p-4 md:hidden">
        <Sheet open={open} onOpenChange={setOpen}>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon">
              <Menu className="h-6 w-6" />
              <span className="sr-only">Toggle menu</span>
            </Button>
          </SheetTrigger>
          <SheetContent side="left" className="w-64 p-0">
            <SheetHeader className="border-b p-4">
              <SheetTitle className="flex items-center gap-2">
                <div className="rounded-full bg-primary p-1">
                  <div className="h-8 w-8 rounded-full bg-white text-center text-xl font-bold leading-8 text-primary">
                    A
                  </div>
                </div>
                <div className="text-lg font-semibold">AiroDental</div>
              </SheetTitle>
            </SheetHeader>
            <div className="flex flex-col">
              <nav className="flex-1 space-y-1 p-4">
                {navigationItems.map((item) => {
                  const isActive = pathname === item.href || pathname?.startsWith(`${item.href}/`)
                  return (
                    <Link
                      key={item.href}
                      href={item.href}
                      className={cn(
                        "flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium",
                        isActive
                          ? "bg-primary text-primary-foreground"
                          : "text-muted-foreground hover:bg-secondary hover:text-foreground"
                      )}
                      onClick={() => setOpen(false)}
                    >
                      <item.icon className="h-5 w-5" />
                      {item.name}
                    </Link>
                  )
                })}
              </nav>
              <div className="border-t p-4">
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" className="w-full justify-start p-2">
                      <Avatar className="mr-2 h-6 w-6">
                        <AvatarImage src="/placeholder-avatar.jpg" />
                        <AvatarFallback>JD</AvatarFallback>
                      </Avatar>
                      <span>John Doe</span>
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end" className="w-56">
                    <DropdownMenuLabel>My Account</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem>
                      <User className="mr-2 h-4 w-4" />
                      <span>Profile</span>
                    </DropdownMenuItem>
                    <DropdownMenuItem>
                      <Settings className="mr-2 h-4 w-4" />
                      <span>Settings</span>
                    </DropdownMenuItem>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem>
                      <LogOut className="mr-2 h-4 w-4" />
                      <span>Log out</span>
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </div>
          </SheetContent>
        </Sheet>
        <div className="ml-4 text-lg font-semibold">AiroDental</div>
      </div>
    </>
  )
}

================
File: prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// User model
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  patients  Patient[]
}

enum Role {
  USER
  ADMIN
  RECEPTIONIST
  DENTIST
}

// Patient model
model Patient {
  id           String    @id @default(uuid())
  firstName    String
  lastName     String
  email        String?   @unique
  phoneNumber  String?
  dateOfBirth  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  userId       String    
  user         User      @relation(fields: [userId], references: [id])
  appointments Appointment[]
}

enum PatientType {
  NEW
  EXISTING
}

// Appointment model
model Appointment {
  id          String   @id @default(uuid())
  date        DateTime
  reason      String
  patientType PatientType @default(EXISTING)
  status      AppointmentStatus @default(SCHEDULED)
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  patientId   String
  patient     Patient  @relation(fields: [patientId], references: [id])
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  CANCELLED
  COMPLETED
}

// KnowledgeTopic model
model KnowledgeTopic {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  topicName     String   // User-facing name (e.g., "Office Hours")
  content       String   @db.Text // The actual knowledge content provided by the user
  assistantId   String   // ID of the Vapi Assistant this topic belongs to

  // Vapi resource IDs - store them once created
  vapiToolId    String?  @unique // The ID of the Vapi 'query' tool
  vapiFileId    String?           // The ID of the Vapi file containing the content
  vapiKbName    String?           // Generated internal KB name
  vapiToolName  String?           // Generated internal tool name
  vapiFileName  String?           // Generated internal file name
  vapiDescription String?       // Generated description used for tool/kb

  // Optional: Link to the user who created/owns this topic
  // userId        String
  // user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([assistantId])
  // @@index([userId])
}

================
File: app/api/appointments/route.ts
================
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Validate if the appointment time is within business hours - now ANY time is allowed
function isValidAppointmentTime(): { valid: boolean; message?: string } {
  // Always return valid for demo purposes
  return { valid: true };
}

// GET all appointments with patient details
export async function GET() {
  try {
    const appointments = await prisma.appointment.findMany({
      include: {
        patient: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
      orderBy: {
        date: 'asc',
      },
    });

    return NextResponse.json(appointments);
  } catch (error) {
    console.error('Error fetching appointments:', error);
    return NextResponse.json({ error: 'Failed to fetch appointments' }, { status: 500 });
  }
}

// POST new appointment
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { date, patientId, reason, patientType, notes } = body;

    // Validate required fields
    if (!date || !patientId || !reason) {
      return NextResponse.json(
        { error: 'Missing required fields: date, patientId, and reason are required' },
        { status: 400 }
      );
    }

    // Parse the appointment date
    const appointmentDate = new Date(date);
    
    // Validate that the appointment time is within business hours
    const timeValidation = isValidAppointmentTime();
    if (!timeValidation.valid) {
      console.error('Appointment validation failed:', timeValidation.message);
      return NextResponse.json(
        { error: timeValidation.message },
        { status: 400 }
      );
    }

    // Create new appointment
    const appointment = await prisma.appointment.create({
      data: {
        date: appointmentDate,
        patientId,
        reason,
        patientType: patientType || 'EXISTING',
        notes: notes || '',
        status: 'SCHEDULED',
      },
      include: {
        patient: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    return NextResponse.json(appointment);
  } catch (error) {
    console.error('Error creating appointment:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('Detailed error:', errorMessage);
    return NextResponse.json({ error: `Failed to create appointment: ${errorMessage}` }, { status: 500 });
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/docs

scripts

================
File: app/calendar/page.tsx
================
"use client";

import { useState, useEffect, useCallback, useMemo } from 'react';
import Link from 'next/link';
import { Calendar, Views, dateFnsLocalizer } from 'react-big-calendar';
import type { ToolbarProps } from 'react-big-calendar';
import { format, parse, startOfWeek, getDay } from 'date-fns';
import { enUS } from 'date-fns/locale/en-US';
import { Button } from '@/components/ui/button';
import { Skeleton } from '@/components/ui/skeleton';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, CalendarPlus, ChevronLeft, ChevronRight } from 'lucide-react';
import AppointmentFormModal from '@/components/AppointmentFormModal';
import AppointmentDetailModal from '@/components/AppointmentDetailModal';

// Define types
interface Patient {
  id: string;
  firstName: string;
  lastName: string;
  // Add other patient fields as needed by the form
}

interface Appointment {
  id: string;
  date: Date; // Should be a Date object after parsing
  reason: string;
  status: 'SCHEDULED' | 'CONFIRMED' | 'CANCELLED' | 'COMPLETED'; // Example statuses
  patientType: 'NEW' | 'EXISTING';
  notes?: string | null;
  patientId: string;
  patient: Patient; // Include patient data for display/form
}

// Type for data coming directly from API before parsing date
interface AppointmentData extends Omit<Appointment, 'date' | 'patient'> {
  date: string; // Date as string from API
  patient: Patient;
}

// Type for event object used by react-big-calendar
interface CalendarEvent {
  title: string;
  start: Date;
  end: Date;
  resource: Appointment; // Store original appointment
}

const locales = { 'en-US': enUS };
const localizer = dateFnsLocalizer({
  format,
  parse,
  startOfWeek: () => startOfWeek(new Date(), { locale: locales['en-US'] }),
  getDay,
  locales,
});

// Custom Toolbar Component
const CustomToolbar = (toolbar: ToolbarProps<CalendarEvent>) => {
  const goToBack = () => toolbar.onNavigate('PREV');
  const goToNext = () => toolbar.onNavigate('NEXT');
  const goToCurrent = () => toolbar.onNavigate('TODAY');

  return (
    <div className="rbc-toolbar mb-4 flex items-center justify-between flex-wrap gap-2">
      <div className="flex items-center gap-2 flex-wrap"> {/* Toolbar buttons */} 
        <Button variant="outline" size="sm" onClick={goToBack}>
          <ChevronLeft className="mr-1 h-4 w-4" /> Prev
        </Button>
        <Button variant="outline" size="sm" onClick={goToCurrent}>
          Today
        </Button>
        <Button variant="outline" size="sm" onClick={goToNext}>
          Next <ChevronRight className="ml-1 h-4 w-4" />
        </Button>
      </div>
      <span className="rbc-toolbar-label text-lg font-semibold order-first sm:order-none"> {/* Title */} 
        {toolbar.label}
      </span>
      <div className="rbc-btn-group flex items-center gap-2"> {/* View switcher */} 
        <Button 
          variant={toolbar.view === 'week' ? 'secondary' : 'outline'} 
          size="sm" 
          onClick={() => toolbar.onView('week')}
        >
          Week
        </Button>
        <Button 
          variant={toolbar.view === 'day' ? 'secondary' : 'outline'} 
          size="sm" 
          onClick={() => toolbar.onView('day')}
        >
          Day
        </Button>
      </div>
    </div>
  );
};

export default function CalendarPage() {
  const [appointments, setAppointments] = useState<Appointment[]>([]);
  const [patients, setPatients] = useState<Patient[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [currentDate, setCurrentDate] = useState(new Date());

  // Modal State
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [isDetailOpen, setIsDetailOpen] = useState(false);
  const [selectedAppointment, setSelectedAppointment] = useState<Appointment | null>(null);
  const [newAppointmentSlot, setNewAppointmentSlot] = useState<{ start: Date; end: Date } | null>(null);

  // Load appointments and patients
  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const [appointmentsRes, patientsRes] = await Promise.all([
        fetch('/api/appointments'),
        fetch('/api/patients')
      ]);

      if (!appointmentsRes.ok) throw new Error(`Appointments fetch failed: ${appointmentsRes.statusText} (${appointmentsRes.status})`);
      if (!patientsRes.ok) throw new Error(`Patients fetch failed: ${patientsRes.statusText} (${patientsRes.status})`);

      const appointmentsData: AppointmentData[] = await appointmentsRes.json();
      const patientsData: Patient[] = await patientsRes.json();

      // Important: Parse date strings into Date objects
      const parsedAppointments = appointmentsData.map((apt) => ({
        ...apt,
        date: new Date(apt.date)
      }));

      setAppointments(parsedAppointments);
      setPatients(patientsData);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'An error occurred fetching data';
      setError(message);
      console.error('Error fetching data:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Transform appointments for react-big-calendar events
  const calendarEvents: CalendarEvent[] = useMemo(() => appointments.map(apt => {
    // Basic assumption: 30 min duration. Adjust if you store duration.
    const endTime = new Date(apt.date.getTime() + 30 * 60000); 
    return {
      title: `${apt.patient.firstName} ${apt.patient.lastName} - ${apt.reason}`,
      start: apt.date,
      end: endTime,
      resource: apt, // Attach original data
    };
  }), [appointments]);

  // Event Handlers
  const handleSelectEvent = useCallback((event: CalendarEvent) => {
    setSelectedAppointment(event.resource);
    setIsDetailOpen(true);
    console.log("Selected Event:", event.resource); // For debugging
  }, []);

  const handleSelectSlot = useCallback((slotInfo: { start: Date; end: Date }) => {
    setNewAppointmentSlot({ start: slotInfo.start, end: slotInfo.end });
    setSelectedAppointment(null); // Ensure no previous detail is shown
    setIsFormOpen(true);
    console.log("Selected Slot:", slotInfo); // For debugging
  }, []);

  const handleNavigate = useCallback((newDate: Date) => {
    setCurrentDate(newDate);
  }, []);

  // Modal Success Handlers
  const handleAppointmentSaveSuccess = () => {
    setIsFormOpen(false);
    setNewAppointmentSlot(null);
    fetchData(); // Re-fetch data to show the new appointment
  }

  const handleAppointmentDeleteSuccess = () => {
    setIsDetailOpen(false);
    setSelectedAppointment(null);
    fetchData(); // Re-fetch data after deleting
  }

  // Style Getter (Phase 5)
  const eventStyleGetter = (event: CalendarEvent, start: Date, end: Date, isSelected: boolean) => {
    const appointment = event.resource;
    let newClassName = 'rbc-event flex items-center text-xs leading-tight'; // Base styles
    
    // Add status-specific styles (adjust Tailwind classes as needed for your theme)
    switch (appointment.status) {
      case 'CONFIRMED':
        newClassName += ' bg-green-100 border-green-300 text-green-800 hover:bg-green-200';
        break;
      case 'CANCELLED':
        newClassName += ' bg-red-100 border-red-300 text-red-800 hover:bg-red-200 line-through opacity-75';
        break;
      case 'COMPLETED':
         newClassName += ' bg-blue-100 border-blue-300 text-blue-800 hover:bg-blue-200 opacity-80';
         break;
      default:
        newClassName += ' bg-primary/10 border-primary/30 text-primary hover:bg-primary/20'; // Use theme colors
        break;
    }

    // Add selection style from react-big-calendar default CSS or custom overrides
     if (isSelected) {
       newClassName += ' rbc-selected'; // Rely on CSS for selection style
     }

    return { className: newClassName };
  };

  if (loading && appointments.length === 0) {
    return (
       <div className="container mx-auto p-4 md:p-6 space-y-4">
         <div className="flex justify-between items-center mb-4 flex-wrap gap-2">
          <Skeleton className="h-8 w-48" />
          <div className="flex gap-2">
            <Skeleton className="h-10 w-36" />
            <Skeleton className="h-10 w-32" />
          </div>
         </div>
         <Skeleton className="h-10 w-full" />
         <Skeleton className="h-[60vh] md:h-[70vh] w-full" />
       </div>
    );
  }

  return (
    <div className="container mx-auto p-4 md:p-6 flex flex-col h-[calc(100vh-theme(space.16))]">
      <div className="flex justify-between items-center mb-4 flex-wrap gap-2">
        <h1 className="text-2xl font-bold">Appointment Calendar</h1>
        <div className="flex gap-2 flex-wrap">
          <Button onClick={() => {
            setNewAppointmentSlot(null);
            setSelectedAppointment(null);
            setIsFormOpen(true);
          }}>
            <CalendarPlus className="mr-2 h-4 w-4" /> Add Appointment
          </Button>
          <Link href="/patients">
            <Button variant="outline">View Patients</Button>
          </Link>
        </div>
      </div>

      {error && (
        <Alert variant="destructive" className="mb-4">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Error Loading Data</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="flex-1 min-h-0 bg-card p-2 sm:p-4 rounded-lg border shadow-sm">
        <Calendar
          localizer={localizer}
          events={calendarEvents}
          startAccessor="start"
          endAccessor="end"
          style={{ height: '100%' }}
          views={[Views.WEEK, Views.DAY]}
          defaultView={Views.WEEK}
          date={currentDate}
          onNavigate={handleNavigate}
          onSelectEvent={handleSelectEvent}
          onSelectSlot={handleSelectSlot}
          selectable={true}
          components={{
            toolbar: CustomToolbar,
          }}
          eventPropGetter={eventStyleGetter}
          step={30}
          timeslots={2}
          min={new Date(0, 0, 0, 8, 0, 0)}
          max={new Date(0, 0, 0, 18, 0, 0)}
          popup={true}
        />
      </div>

      <AppointmentFormModal
        isOpen={isFormOpen}
        onOpenChange={setIsFormOpen}
        initialDateTime={newAppointmentSlot}
        patients={patients}
        onSubmitSuccess={handleAppointmentSaveSuccess}
      />

      <AppointmentDetailModal
        isOpen={isDetailOpen}
        onOpenChange={setIsDetailOpen}
        appointment={selectedAppointment}
        onDeleteSuccess={handleAppointmentDeleteSuccess}
      />
    </div>
  );
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist } from "next/font/google";
import "./globals.css";
import { Sidebar } from "@/components/sidebar";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Laine | AiroDental",
  description: "Laine - AI Voice Receptionist for Dental Practices",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} antialiased`}>
        <div className="flex min-h-screen flex-col md:flex-row">
          <Sidebar />
          <main className="flex-1 md:pl-64 h-screen overflow-y-auto">{children}</main>
        </div>
      </body>
    </html>
  );
}

================
File: package.json
================
{
  "name": "laine-core",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "prisma generate && next build",
    "start": "next start",
    "lint": "next lint",
    "prisma:generate": "prisma generate",
    "prisma:push": "prisma db push",
    "prisma:migrate": "prisma migrate dev",
    "prisma:migrate:create": "prisma migrate dev --create-only",
    "prisma:deploy": "prisma migrate deploy",
    "prisma:studio": "prisma studio",
    "db:seed": "prisma db seed",
    "check-vapi-tools": "ts-node scripts/check-vapi-tools.ts",
    "setup-vapi-tools": "ts-node scripts/setup-vapi-tools.ts",
    "seed": "prisma db seed",
    "setup-vapi": "ts-node scripts/setup-vapi-tools.ts"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.6",
    "@ai-sdk/react": "^1.2.5",
    "@prisma/client": "^6.5.0",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@vapi-ai/server-sdk": "^0.5.1",
    "@vapi-ai/web": "^2.2.5",
    "ai": "^4.2.10",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.7",
    "lucide-react": "^0.486.0",
    "next": "15.2.4",
    "react": "^19.0.0",
    "react-big-calendar": "^1.18.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^3.1.0",
    "tw-animate-css": "^1.2.5",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20.17.30",
    "@types/react": "^19",
    "@types/react-big-calendar": "^1.16.1",
    "@types/react-dom": "^19",
    "axios": "^1.8.4",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "node-fetch": "^3.3.2",
    "prisma": "^6.5.0",
    "tailwindcss": "^4",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.3",
    "typescript": "^5"
  },
  "prisma": {
    "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
  }
}



================================================================
End of Codebase
================================================================
