This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    project_description.mdc
app/
  ai-customiser/
    _components/
      ConfigureTab.tsx
      TestTab.tsx
      TrainTab.tsx
    page.tsx
  api/
    appointments/
      [id]/
        route.ts
      route.ts
    call-logs/
      route.ts
    create-query-tool/
      route.ts
    delete-tool/
      route.ts
    get-assistant-config/
      route.ts
    get-assistant-prompt/
      route.ts
    get-assistant-tools/
      route.ts
    laine/
      book-appointment/
        route.ts
      check-availability/
        route.ts
    patients/
      route.ts
    tools/
      route.ts
    update-assistant-config/
      route.ts
    update-assistant-prompt/
      route.ts
    update-assistant-tool/
      route.ts
    update-tool/
      route.ts
    upload-kb-file/
      route.ts
    users/
      route.ts
  calendar/
    page.tsx
  call-logs/
    page.tsx
  check-availability/
    page.tsx
  dashboard/
    page.tsx
  demo/
    page.tsx
  dynamic-kb/
    page.tsx
  edit-prompt/
    page.tsx
  patients/
    page.tsx
  tool-configuration/
    _components/
      EditToolModal.tsx
    page.tsx
  types/
    vapi.ts
  globals.css
  layout.tsx
  page.tsx
components/
  sidebar/
    index.tsx
  ui/
    alert.tsx
    avatar.tsx
    button.tsx
    dropdown-menu.tsx
    input.tsx
    label.tsx
    select.tsx
    separator.tsx
    sheet.tsx
    sidebar.tsx
    skeleton.tsx
    table.tsx
    tabs.tsx
    textarea.tsx
    tooltip.tsx
  Placeholder.tsx
  ToolListModal.tsx
hooks/
  use-mobile.ts
lib/
  prisma.ts
  utils.ts
prisma/
  migrations/
    20250402023503_add_appointment_fields/
      migration.sql
    migration_lock.toml
  schema.prisma
  seed.ts
.gitignore
components.json
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: app/ai-customiser/_components/ConfigureTab.tsx
================
"use client";

import React, { useState, useEffect } from 'react';
import { Loader2, Save, AlertCircle, CheckCircle, RefreshCcw, Mic, UserCog } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Input } from "@/components/ui/input";

export interface AssistantConfig {
  name?: string;
  model?: {
    provider?: string;
    model?: string;
    messages?: Array<{ role: string; content?: string }>;
  };
  voice?: {
    provider?: string;
    voiceId?: string;
  };
}

interface ConfigureTabProps {
  initialConfig: AssistantConfig;
  assistantId: string;
}

// Simplified voice options based on client feedback
// This eliminates the need to show providers to end users
const voiceOptions = [
  { id: "Ali", name: "Ali", tier: "recommended" },
  { id: "Elliot", name: "Elliot", tier: "recommended" },
  { id: "Lily", name: "Lily", tier: "recommended" },
  { id: "Neha", name: "Neha", tier: "recommended" },
  { id: "Cole", name: "Cole", tier: "recommended" },
  { id: "Spencer", name: "Spencer", tier: "recommended" },
  { id: "Savannah", name: "Savannah", tier: "secondary" }
];

// Hidden from UI but needed for implementation
const llmProviders = ["openai", "google", "anthropic", "groq", "custom-llm", "vapi"];
const modelOptions: Record<string, string[]> = {
  openai: ["gpt-4o", "gpt-4-turbo", "gpt-3.5-turbo"],
  google: ["gemini-1.5-pro", "gemini-1.5-flash", "gemini-1.0-pro"],
  anthropic: ["claude-3-5-sonnet-20240620", "claude-3-opus-20240229"],
  groq: ["llama3-70b-8192", "mixtral-8x7b-32768"],
  "custom-llm": ["your-custom-model-name"],
  vapi: ["workflow-model"],
};

export function ConfigureTab({ initialConfig, assistantId }: ConfigureTabProps) {
  // State for editable fields
  const [assistantName, setAssistantName] = useState<string>(initialConfig.name || '');
  const [systemPrompt, setSystemPrompt] = useState<string>(
    initialConfig.model?.messages?.find(m => m.role === 'system')?.content || ''
  );
  const [voiceId, setVoiceId] = useState<string>(initialConfig.voice?.voiceId || '');
  const [llmProvider, setLlmProvider] = useState<string>(initialConfig.model?.provider || '');
  const [llmModel, setLlmModel] = useState<string>(initialConfig.model?.model || '');
  
  // Hidden state for voice provider - always use vapi but don't show to users
  const [voiceProvider, setVoiceProvider] = useState<string>(initialConfig.voice?.provider || 'vapi');

  // State for tracking initial values for reset/dirty check
  const [initialState, setInitialState] = useState(initialConfig);

  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [statusMessage, setStatusMessage] = useState<string>('');
  const [errorMessage, setErrorMessage] = useState<string>('');

  // Update initial state if initialConfig changes (e.g., parent re-fetches)
  useEffect(() => {
    setInitialState(initialConfig);
    setAssistantName(initialConfig.name || '');
    setSystemPrompt(initialConfig.model?.messages?.find(m => m.role === 'system')?.content || '');
    setVoiceProvider(initialConfig.voice?.provider || 'vapi');
    setVoiceId(initialConfig.voice?.voiceId || '');
    setLlmProvider(initialConfig.model?.provider || '');
    setLlmModel(initialConfig.model?.model || '');
  }, [initialConfig]);

  const handleSave = async () => {
    setIsSaving(true);
    setStatusMessage('');
    setErrorMessage('');
    try {
      // Construct the payload with only the fields being managed by this tab
      const updatePayload: Partial<AssistantConfig> = {
        name: assistantName,
        model: {
          // Important: Merge with existing model config to avoid overwriting other settings like tools
          ...(initialState.model || {}), // Start with existing model config
          provider: llmProvider,
          model: llmModel,
          messages: [
            // Replace only the system message, keep others if they exist
            ...(initialState.model?.messages?.filter(m => m.role !== 'system') || []),
            { role: "system", content: systemPrompt }
          ],
        },
        voice: {
          // Important: Merge with existing voice config
          ...(initialState.voice || {}),
          provider: voiceProvider, // Always set to vapi internally
          voiceId: voiceId,
        },
      };

      const response = await fetch('/api/update-assistant-config', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ assistantId, updatePayload }),
      });
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || `Failed to update assistant (status: ${response.status})`);
      }

      // Update initial state to reflect saved changes
      setInitialState(data.assistant); // Use the response data as the new initial state
      setStatusMessage('Configuration updated successfully!');

    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error saving config.';
      setErrorMessage(message);
    } finally {
      setIsSaving(false);
    }
  };

  const handleReset = () => {
    setAssistantName(initialState.name || '');
    setSystemPrompt(initialState.model?.messages?.find(m => m.role === 'system')?.content || '');
    setVoiceProvider(initialState.voice?.provider || 'vapi');
    setVoiceId(initialState.voice?.voiceId || '');
    setLlmProvider(initialState.model?.provider || '');
    setLlmModel(initialState.model?.model || '');
    setStatusMessage('Changes reverted to last saved state.');
    setErrorMessage('');
  };

  const hasChanges =
    assistantName !== (initialState.name || '') ||
    systemPrompt !== (initialState.model?.messages?.find(m => m.role === 'system')?.content || '') ||
    voiceProvider !== (initialState.voice?.provider || '') ||
    voiceId !== (initialState.voice?.voiceId || '') ||
    llmProvider !== (initialState.model?.provider || '') ||
    llmModel !== (initialState.model?.model || '');

  const currentModelOptions = modelOptions[llmProvider] || [];

  return (
    <div className="space-y-8">
      {/* Identity Section */}
      <section className="p-4 border rounded-lg bg-white dark:bg-gray-800 shadow-sm">
        <h2 className="text-xl font-semibold mb-4 flex items-center"><UserCog className="mr-2 h-5 w-5 text-gray-600 dark:text-gray-400" /> Identity & Persona</h2>
        <div className="mb-4">
          <Label htmlFor="assistantName">Assistant Name</Label>
          <Input
            id="assistantName"
            value={assistantName}
            onChange={(e) => setAssistantName(e.target.value)}
            className="mt-1"
            disabled={isSaving}
            placeholder="e.g., Laine"
          />
        </div>
        <div>
          <Label htmlFor="systemPrompt">System Prompt</Label>
          <Textarea
            id="systemPrompt"
            value={systemPrompt}
            onChange={(e) => setSystemPrompt(e.target.value)}
            rows={10}
            className="mt-1 w-full font-mono text-sm"
            placeholder="Define the assistant's role, goals, and personality..."
            disabled={isSaving}
          />
        </div>
      </section>

      {/* Voice Section - Simplified to only show voice selection */}
      <section className="p-4 border rounded-lg bg-white dark:bg-gray-800 shadow-sm">
        <h2 className="text-xl font-semibold mb-4 flex items-center"><Mic className="mr-2 h-5 w-5 text-gray-600 dark:text-gray-400" /> Voice</h2>
        <div>
          <Label htmlFor="voiceId">Voice</Label>
          <Select
            value={voiceId}
            onValueChange={setVoiceId}
            disabled={isSaving}
          >
            <SelectTrigger id="voiceId" className="mt-1 w-full">
              <SelectValue placeholder="Select a voice" />
            </SelectTrigger>
            <SelectContent>
              <div className="pb-1 pt-2 px-2 text-xs font-medium text-muted-foreground">Recommended</div>
              {voiceOptions
                .filter(voice => voice.tier === "recommended")
                .map(voice => (
                  <SelectItem key={voice.id} value={voice.id}>{voice.name}</SelectItem>
                ))
              }
              <div className="pb-1 pt-2 px-2 text-xs font-medium text-muted-foreground">Additional Options</div>
              {voiceOptions
                .filter(voice => voice.tier === "secondary")
                .map(voice => (
                  <SelectItem key={voice.id} value={voice.id}>{voice.name}</SelectItem>
                ))
              }
            </SelectContent>
          </Select>
        </div>
      </section>

      {/* Model Section - Hidden from users but maintained for api compatibility */}
      <div className="hidden">
        <div>
          <Label htmlFor="llmProvider">Provider</Label>
          <Select
            value={llmProvider}
            onValueChange={(value) => { setLlmProvider(value); setLlmModel(''); }}
            disabled={isSaving}
          >
            <SelectTrigger id="llmProvider" className="mt-1">
              <SelectValue placeholder="Select LLM provider" />
            </SelectTrigger>
            <SelectContent>
              {llmProviders.map(p => <SelectItem key={p} value={p}>{p}</SelectItem>)}
            </SelectContent>
          </Select>
        </div>
        <div>
          <Label htmlFor="llmModel">Model</Label>
          <Select
            value={llmModel}
            onValueChange={setLlmModel}
            disabled={isSaving || !llmProvider || currentModelOptions.length === 0}
          >
            <SelectTrigger id="llmModel" className="mt-1">
              <SelectValue placeholder={!llmProvider ? "Select provider first" : "Select model"} />
            </SelectTrigger>
            <SelectContent>
              {currentModelOptions.map(m => <SelectItem key={m} value={m}>{m}</SelectItem>)}
              {llmProvider && currentModelOptions.length === 0 && <SelectItem value="" disabled>No models listed for this provider</SelectItem>}
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Save/Reset Buttons and Status Messages */}
      <div className="mt-6 space-y-4">
        {statusMessage && !errorMessage && (
          <Alert>
            <CheckCircle className="h-4 w-4" />
            <AlertTitle>Success</AlertTitle>
            <AlertDescription>{statusMessage}</AlertDescription>
          </Alert>
        )}
        {errorMessage && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>Error</AlertTitle>
            <AlertDescription>{errorMessage}</AlertDescription>
          </Alert>
        )}

        <div className="flex flex-col sm:flex-row justify-end space-y-2 sm:space-y-0 sm:space-x-3">
          <Button
            variant="outline"
            onClick={handleReset}
            disabled={isSaving || !hasChanges}
          >
            <RefreshCcw className="mr-2 h-4 w-4" /> Reset Changes
          </Button>
          <Button
            onClick={handleSave}
            disabled={isSaving || !hasChanges}
          >
            {isSaving ? (
              <Loader2 className="animate-spin mr-2 h-4 w-4" />
            ) : (
              <Save className="mr-2 h-4 w-4" />
            )}
            Save Configuration
          </Button>
        </div>
      </div>
    </div>
  );
}

================
File: app/api/create-query-tool/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('VAPI_API_KEY is not set');
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    const { fileIds, toolName, kbName, kbDescription } = await request.json();

    if (!Array.isArray(fileIds) || fileIds.length === 0) {
      return NextResponse.json({ error: 'At least one fileId is required' }, { status: 400 });
    }
    if (!toolName || typeof toolName !== 'string') {
        return NextResponse.json({ error: 'toolName is required' }, { status: 400 });
    }
     if (!kbName || typeof kbName !== 'string') {
        return NextResponse.json({ error: 'kbName is required' }, { status: 400 });
    }
     if (!kbDescription || typeof kbDescription !== 'string') {
        return NextResponse.json({ error: 'kbDescription is required' }, { status: 400 });
    }

    console.log(`Creating query tool "${toolName}" with KB "${kbName}" using file IDs: ${fileIds.join(', ')}`);

    const toolPayload = {
      type: "query",
      // The 'function' object defines how the assistant *calls* the tool.
      // The 'name' here is what the assistant uses internally.
      function: {
        name: toolName, // e.g., "search_dynamic_knowledge"
        description: `Use this tool to answer questions based on the dynamically uploaded content about: ${kbDescription}`, // Help LLM know when to use it
        parameters: { // Define parameters the LLM needs to extract from the user query
          type: "object",
          properties: {
            query: {
              type: "string",
              description: "The specific question or topic the user is asking about related to the knowledge base."
            }
          },
          required: ["query"]
        }
      },
      // The 'knowledgeBases' array defines the actual data sources for the tool.
      knowledgeBases: [
        {
          provider: "google", // Currently the only supported provider for Query Tool KB
          model: "gemini-1.5-flash", // Default model for Google KB
          name: kbName, // An internal name for this specific KB source
          description: kbDescription, // Helps the assistant choose *this specific KB* if multiple are present
          fileIds: fileIds // The IDs of the files uploaded earlier
        }
        // You could add more knowledgeBase objects here if needed
      ]
      // Optional: Add server config if you want Vapi to call *your* server
      // when this tool is invoked, instead of Vapi handling the query directly.
      // server: { url: "YOUR_SERVER_ENDPOINT_FOR_QUERY_TOOL" }
    };

    const response = await fetch('https://api.vapi.ai/tool', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(toolPayload),
    });

    const responseData = await response.json();

    if (!response.ok) {
      console.error(`Vapi API Error (Create Tool): ${response.status}`, responseData);
      return NextResponse.json({ error: `Failed to create query tool: ${responseData.message || response.statusText}` }, { status: response.status });
    }

    console.log(`Successfully created query tool "${toolName}". Tool ID: ${responseData.id}`);
    return NextResponse.json({ toolId: responseData.id });

  } catch (error) {
    console.error('Error in /api/create-query-tool:', error);
    const message = error instanceof Error ? error.message : 'Unknown error during tool creation';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/delete-tool/route.ts
================
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  // Basic validation check
  if (!VAPI_API_KEY) {
    console.error("VAPI_API_KEY is not set in environment variables.");
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    // Parse request body
    const body = await request.json() as { toolId: string };
    const { toolId } = body;

    // Validate required fields
    if (!toolId) {
      return NextResponse.json({ error: 'Missing required field: toolId' }, { status: 400 });
    }

    console.log(`[delete-tool] Deleting tool ${toolId}`);

    // Initialize Vapi Client
    const vapi = new VapiClient({ token: VAPI_API_KEY });

    // Delete the tool
    await vapi.tools.delete(toolId);
    
    console.log(`[delete-tool] Successfully deleted tool ${toolId}`);
    return NextResponse.json({ success: true });
  } catch (error) {
    // Log and return error
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error("[delete-tool] Error deleting tool:", errorMessage);
    return NextResponse.json({ error: 'Failed to delete tool' }, { status: 500 });
  }
}

================
File: app/api/get-assistant-config/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function GET(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('API Key missing in server environment.');
    return NextResponse.json({ error: 'Server configuration error.' }, { status: 500 });
  }

  try {
    // Get the assistant ID from the query parameters
    const url = new URL(request.url);
    const assistantId = url.searchParams.get('id');

    if (!assistantId) {
      return NextResponse.json({ error: 'assistantId is required.' }, { status: 400 });
    }

    console.log(`API: Fetching config for assistant ID: ${assistantId}`);
    const response = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Accept': 'application/json',
      },
      cache: 'no-store', // Ensure fresh data is fetched
    });

    const data = await response.json();

    if (!response.ok) {
      console.error(`API Error (Fetch Assistant): ${response.status}`, data);
      return NextResponse.json({ error: `Failed to fetch assistant: ${data.message || response.statusText}` }, { status: response.status });
    }

    console.log("API: Successfully fetched assistant config.");
    return NextResponse.json(data);

  } catch (error) {
    console.error('API Error in /api/get-assistant-config:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/get-assistant-prompt/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;
const VAPI_ASSISTANT_ID = process.env.VAPI_ASSISTANT_ID;

// Define interface for message object
interface VapiMessage {
  role: string;
  content: string;
}

export async function GET() {
  if (!VAPI_API_KEY || !VAPI_ASSISTANT_ID) {
    console.error('API Key or Assistant ID is missing in server environment variables.');
    return NextResponse.json({ error: 'Server configuration error.' }, { status: 500 });
  }

  try {
    console.log(`Fetching assistant configuration for ID: ${VAPI_ASSISTANT_ID}`);
    const response = await fetch(`https://api.vapi.ai/assistant/${VAPI_ASSISTANT_ID}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      console.error(`Vapi API Error (Fetch Assistant): ${response.status}`, data);
      return NextResponse.json({ error: `Failed to fetch assistant: ${data.message || response.statusText}` }, { status: response.status });
    }

    // Find the system prompt within the model messages
    let systemPromptContent = '';
    if (data.model && Array.isArray(data.model.messages)) {
      const systemMessage = data.model.messages.find((msg: VapiMessage) => msg.role === 'system');
      if (systemMessage) {
        systemPromptContent = systemMessage.content || '';
      }
    }

    console.log("Successfully fetched system prompt.");
    return NextResponse.json({ prompt: systemPromptContent });

  } catch (error) {
    console.error('Error fetching assistant prompt:', error);
    const message = error instanceof Error ? error.message : 'Unknown error occurred';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/laine/book-appointment/route.ts
================
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Simple logging function
function log(message: string, data?: unknown) {
  console.log(`[${new Date().toISOString()}] ${message}`);
  if (data) console.log(JSON.stringify(data, null, 2));
}

// Define CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

// Simple interface for appointment parameters
interface AppointmentParams {
  start: string; // ISO Date string
  name: string;
  email: string;
  smsReminderNumber?: string; // Optional
}

export async function POST(request: Request) {
  let toolCallId = 'unknown';
  
  log('Received book appointment request', {
    url: request.url,
    method: request.method
  });
  
  try {
    // Handle preflight request
    if (request.method === 'OPTIONS') {
      return new NextResponse(null, {
        status: 204,
        headers: corsHeaders,
      });
    }

    // Parse the request body
    const reqBody = await request.json();
    log('Request body', reqBody);

    // Extract toolCallId and parameters from different possible structures
    let functionParams: AppointmentParams | undefined;
    
    // Handle direct VAPI format
    if (reqBody.tool_call_id) {
      toolCallId = reqBody.tool_call_id;
      
      // Check if function arguments are provided
      if (reqBody.function?.arguments) {
        const args = typeof reqBody.function.arguments === 'string' 
          ? JSON.parse(reqBody.function.arguments)
          : reqBody.function.arguments;
        
        functionParams = args;
      } else if (reqBody.parameters) {
        // Fallback to parameters object
        functionParams = reqBody.parameters;
      }
    } 
    // Handle OpenAI format 
    else if (reqBody.toolCallId) {
      toolCallId = reqBody.toolCallId;
      
      if (reqBody.arguments) {
        functionParams = typeof reqBody.arguments === 'string'
          ? JSON.parse(reqBody.arguments)
          : reqBody.arguments;
      }
    }
    // Handle array format from VAPI
    else if (Array.isArray(reqBody.toolCalls) && reqBody.toolCalls.length > 0) {
      const toolCall = reqBody.toolCalls[0];
      toolCallId = toolCall.id;
      
      if (toolCall.function?.arguments) {
        functionParams = typeof toolCall.function.arguments === 'string'
          ? JSON.parse(toolCall.function.arguments)
          : toolCall.function.arguments;
      }
    }
    
    if (!functionParams) {
      return NextResponse.json({
        results: [{
          toolCallId,
          error: 'Missing required parameters'
        }]
      }, { status: 400, headers: corsHeaders });
    }
    
    const { start, name, email, smsReminderNumber } = functionParams;
    
    // Check for required parameters
    if (!start) {
      log('Missing start parameter');
      return NextResponse.json(
        { 
          tool_call_id: toolCallId,
          status: 'error',
          message: 'Start date is required'
        }, 
        { 
          status: 400,
          headers: corsHeaders 
        }
      );
    }

    if (!name || !email) {
      log('Missing name or email parameters');
      return NextResponse.json(
        { 
          tool_call_id: toolCallId,
          status: 'error',
          message: 'Name and email are required'
        }, 
        { 
          status: 400,
          headers: corsHeaders 
        }
      );
    }
    
    // Basic validation on date format
    const appointmentDate = new Date(start);
    if (appointmentDate.toString() === 'Invalid Date' || Number.isNaN(appointmentDate.getTime())) {
      log('Invalid date format', { start });
      return NextResponse.json(
        { 
          tool_call_id: toolCallId,
          status: 'error',
          message: 'Invalid date format'
        }, 
        { 
          status: 400,
          headers: corsHeaders 
        }
      );
    }
    
    log(`Booking appointment for ${name} (${email}) at ${start}`);
    
    // Find or create patient record (simplified)
    let patient = null;
    try {
      // Parse name into first and last
      const nameParts = name.trim().split(' ');
      const firstName = nameParts[0];
      const lastName = nameParts.length > 1 ? nameParts.slice(1).join(' ') : '';
      
      // First try to find the patient
      patient = await prisma.patient.findFirst({
        where: { email }
      });
      
      // If not found, create a new patient
      if (!patient) {
        // Find a dentist (we need a user ID for the patient)
        const users = await prisma.user.findMany({
          where: { role: 'DENTIST' },
          take: 1
        });
        
        const dentistId = users.length > 0 ? users[0].id : null;
        if (!dentistId) {
          throw new Error('No dentist found in the system');
        }
        
        // Create the patient
        patient = await prisma.patient.create({
          data: {
            firstName,
            lastName,
            email,
            phoneNumber: smsReminderNumber || null,
            userId: dentistId
          }
        });
        
        log('Created new patient:', patient);
      }
    } catch (e) {
      log('Error with patient', e);
      // We'll still try to create an appointment with a mock patient ID
      if (!patient) {
        patient = { id: 'mock-patient-id' };
      }
    }
    
    // Create the appointment with simplified error handling
    let appointment = null;
    try {
      appointment = await prisma.appointment.create({
        data: {
          date: appointmentDate,
          reason: 'Appointment via voice assistant',
          patientType: 'NEW',
          status: 'SCHEDULED',
          notes: `Booked via VAPI. ${smsReminderNumber ? `SMS: ${smsReminderNumber}` : ''}`,
          patientId: patient.id
        }
      });
      
      log('Created appointment:', appointment);
    } catch (e) {
      log('Error creating appointment', e);
      // Continue - we'll still return a success message
    }
    
    // Format the date for the response
    const formattedDate = appointmentDate.toLocaleString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      timeZone: 'America/Chicago',
    });
    
    // Success response
    log('Appointment created successfully', { appointmentId: appointment?.id || 'unknown' });
    return NextResponse.json(
      {
        tool_call_id: toolCallId,
        status: 'success',
        message: `Your appointment has been scheduled for ${formattedDate}`
      },
      { headers: corsHeaders }
    );

  } catch (e) {
    // Log error and return error response
    log('Error processing appointment booking request', e);
    return NextResponse.json(
      { 
        tool_call_id: toolCallId,
        status: 'error',
        message: 'Failed to book appointment due to a server error. Please try again later.'
      },
      { 
        status: 500,
        headers: corsHeaders 
      }
    );
  } finally {
    try {
      await prisma.$disconnect();
    } catch {
      // Ignore disconnect errors
    }
  }
}

// Handle CORS preflight
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 204,
    headers: corsHeaders,
  });
}

================
File: app/api/laine/check-availability/route.ts
================
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Simple logging utility
function log(message: string, data?: Record<string, unknown>) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${message}`, data ? JSON.stringify(data, null, 2) : '');
}

// Define CORS headers for cross-origin requests
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

// Day of week mapping for date calculations
const DAYS_OF_WEEK = [
  'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
];

// Helper to find the next occurrence of a day of the week
function getNextDayOfWeek(dayName: string, fromDate = new Date()): Date {
  const targetDay = DAYS_OF_WEEK.findIndex(
    day => day.toLowerCase() === dayName.toLowerCase()
  );
  
  if (targetDay === -1) return fromDate; // Invalid day name
  
  const today = fromDate.getDay();
  const daysToAdd = (targetDay + 7 - today) % 7;
  
  const result = new Date(fromDate);
  result.setDate(result.getDate() + (daysToAdd === 0 ? 7 : daysToAdd));
  return result;
}

// More specific types for arguments
type FunctionArguments = {
  startDate?: string;
  [key: string]: unknown;
};

// Type for possible request body formats
type RequestBody = {
  message?: {
    toolCalls?: Array<{
      id: string;
      function?: {
        name?: string;
        arguments?: string | Record<string, unknown>;
      };
    }>;
    toolCallList?: Array<{
      id: string;
      function?: {
        name?: string;
        arguments?: string | Record<string, unknown>;
      };
    }>;
  };
  tool_call_id?: string;
  parameters?: { startDate?: string };
  toolCallId?: string;
  arguments?: string | Record<string, unknown>;
  toolCalls?: Array<{
    id: string;
    function?: {
      name?: string;
      arguments?: string | Record<string, unknown>;
    };
  }>;
};

// Process date to ensure it's valid and in the future
function processRequestDate(dateString: string): Date {
  const currentTime = new Date();
  
  // Create a date object from the string
  const parsedDate = new Date(dateString);
  
  // Check if date string is a valid ISO format date
  if (!Number.isNaN(parsedDate.getTime())) {
    // Extract the day of week from the parsed date
    const dayOfWeek = DAYS_OF_WEEK[parsedDate.getDay()];
    
    log('Parsed date information', {
      originalDate: dateString,
      parsedDate: parsedDate.toISOString(),
      dayOfWeek
    });
    
    // Always use the NEXT occurrence of that day of week from today
    const correctDayOfWeekDate = getNextDayOfWeek(dayOfWeek, currentTime);
    
    // Keep the time from the original parsed date
    correctDayOfWeekDate.setHours(parsedDate.getHours());
    correctDayOfWeekDate.setMinutes(parsedDate.getMinutes());
    correctDayOfWeekDate.setSeconds(parsedDate.getSeconds());
    
    log('Corrected to next occurrence of day of week', {
      originalDate: dateString,
      correctedDate: correctDayOfWeekDate.toISOString(),
      dayOfWeek
    });
    
    return correctDayOfWeekDate;
  }
  
  // If we get here, the date string was not valid ISO format
  // Try to extract day name and time if string contains day reference
  const dayPatterns = [
    { day: 'monday', regex: /\b(mon|monday)\b/i },
    { day: 'tuesday', regex: /\b(tue|tues|tuesday)\b/i },
    { day: 'wednesday', regex: /\b(wed|weds|wednesday)\b/i },
    { day: 'thursday', regex: /\b(thu|thur|thurs|thursday)\b/i },
    { day: 'friday', regex: /\b(fri|friday)\b/i },
    { day: 'saturday', regex: /\b(sat|saturday)\b/i },
    { day: 'sunday', regex: /\b(sun|sunday)\b/i },
  ];
  
  // Check if string contains day reference
  for (const { day, regex } of dayPatterns) {
    if (regex.test(dateString)) {
      // Extract time if available (assuming format like "3pm" or "3:00pm")
      const timeMatch = dateString.match(/(\d{1,2})(?::(\d{2}))?(?:\s*)(am|pm)/i);
      
      const nextDayDate = getNextDayOfWeek(day, currentTime);
      
      // If time was extracted, set it
      if (timeMatch) {
        const hours = Number.parseInt(timeMatch[1], 10);
        const minutes = timeMatch[2] ? Number.parseInt(timeMatch[2], 10) : 0;
        const isPM = timeMatch[3].toLowerCase() === 'pm';
        
        // Convert to 24-hour format
        const adjustedHours = isPM && hours < 12 
          ? hours + 12 
          : (!isPM && hours === 12 ? 0 : hours);
        
        nextDayDate.setHours(adjustedHours, minutes, 0, 0);
      } else {
        // Default to 3PM if no time specified
        nextDayDate.setHours(15, 0, 0, 0);
      }
      
      log('Extracted day reference and created date', {
        originalText: dateString,
        extractedDay: day,
        extractedTime: timeMatch ? `${timeMatch[1]}:${timeMatch[2] || '00'} ${timeMatch[3]}` : 'default 3:00 PM',
        resultDate: nextDayDate.toISOString()
      });
      
      return nextDayDate;
    }
  }
  
  // For demo purposes, use tomorrow at 3:00 PM as fallback
  log('Could not parse date reference, using tomorrow at 3PM as fallback', { 
    originalDate: dateString
  });
  
  const fallbackDate = new Date(currentTime);
  fallbackDate.setDate(fallbackDate.getDate() + 1);
  fallbackDate.setHours(15, 0, 0, 0); // 3:00 PM
  return fallbackDate;
}

// Get current date info for debugging and reference
function getCurrentDateInfo(): Record<string, string> {
  const now = new Date();
  return {
    currentDateTime: now.toISOString(),
    currentDateUTC: now.toUTCString(),
    currentDateLocale: now.toLocaleString(),
    currentDayOfWeek: DAYS_OF_WEEK[now.getDay()],
    nextWednesday: getNextDayOfWeek('wednesday', now).toISOString(),
  };
}

export async function POST(request: Request) {
  log('Received check-availability request');
  log('Current date info', getCurrentDateInfo());
  
  // Handle preflight request
  if (request.method === 'OPTIONS') {
    return new NextResponse(null, { headers: corsHeaders });
  }

  let reqBody: RequestBody = {}; // Define here to access in catch block
  
  try {
    reqBody = await request.json();
    log('Request body', reqBody);

    // Extract toolCallId and parameters from different possible structures
    let toolCallId = '';
    let startDate = '';
    
    // Handle nested message format from VAPI
    if (reqBody.message?.toolCalls && reqBody.message.toolCalls.length > 0) {
      const toolCall = reqBody.message.toolCalls[0];
      toolCallId = toolCall.id;
      
      if (typeof toolCall.function?.arguments === 'string') {
        try {
          const args = JSON.parse(toolCall.function.arguments) as FunctionArguments;
          startDate = args.startDate || '';
        } catch (e) {
          log('Error parsing tool call arguments', { error: e });
        }
      } else if (toolCall.function?.arguments) {
        const args = toolCall.function.arguments as Record<string, unknown>;
        startDate = (args.startDate as string) || '';
      }
    }
    // Handle nested message with toolCallList format
    else if (reqBody.message?.toolCallList && reqBody.message.toolCallList.length > 0) {
      const toolCall = reqBody.message.toolCallList[0];
      toolCallId = toolCall.id;
      
      if (typeof toolCall.function?.arguments === 'string') {
        try {
          const args = JSON.parse(toolCall.function.arguments) as FunctionArguments;
          startDate = args.startDate || '';
        } catch (e) {
          log('Error parsing tool call arguments', { error: e });
        }
      } else if (toolCall.function?.arguments) {
        const args = toolCall.function.arguments as Record<string, unknown>;
        startDate = (args.startDate as string) || '';
      }
    }
    // Handle direct VAPI format
    else if (reqBody.tool_call_id) {
      toolCallId = reqBody.tool_call_id;
      startDate = reqBody.parameters?.startDate || '';
    } 
    // Handle OpenAI format (from VAPI proxy)
    else if (reqBody.toolCallId) {
      toolCallId = reqBody.toolCallId;
      
      if (typeof reqBody.arguments === 'string') {
        try {
          const args = JSON.parse(reqBody.arguments) as FunctionArguments;
          startDate = args.startDate || '';
        } catch (e) {
          log('Error parsing arguments', { error: e });
        }
      } else if (reqBody.arguments) {
        const args = reqBody.arguments as Record<string, unknown>;
        startDate = (args.startDate as string) || '';
      }
    } 
    // Handle array format from VAPI
    else if (Array.isArray(reqBody.toolCalls) && reqBody.toolCalls.length > 0) {
      const toolCall = reqBody.toolCalls[0];
      toolCallId = toolCall.id;
      
      if (typeof toolCall.function?.arguments === 'string') {
        try {
          const args = JSON.parse(toolCall.function.arguments) as FunctionArguments;
          startDate = args.startDate || '';
        } catch (e) {
          log('Error parsing tool call arguments', { error: e });
        }
      } else if (toolCall.function?.arguments) {
        const args = toolCall.function.arguments as Record<string, unknown>;
        startDate = (args.startDate as string) || '';
      }
    }
    
    // For debugging, log the extracted parameters
    log('Extracted parameters', { toolCallId, startDate });
    
    if (!startDate) {
      log('No start date provided in request');
      return NextResponse.json(
        { 
          results: [{
            toolCallId: toolCallId,
            result: 'Start date is required'
          }]
        }, 
        { 
          status: 400,
          headers: corsHeaders 
        }
      );
    }

    log('Checking availability for date', { startDate });
    
    // Process the date to ensure it's valid and in the future
    const requestedTime = processRequestDate(startDate);
    
    // Query appointments from database
    const appointments = await prisma.appointment.findMany({
      select: {
        id: true,
        date: true,
        patient: {
          select: {
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
      orderBy: {
        date: 'asc',
      },
    });
    
    log('Retrieved appointments', { count: appointments.length });
    
    // Format the requested time for display
    const formattedTime = requestedTime.toLocaleString('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      hour12: true
    });
    
    // Find if there's a conflicting appointment
    const conflictingAppointment = appointments.find(appointment => {
      const appointmentTime = new Date(appointment.date);
      const timeDiffMs = Math.abs(appointmentTime.getTime() - requestedTime.getTime());
      // Consider appointments within 30 minutes as conflicting
      return timeDiffMs < 30 * 60 * 1000;
    });
    
    // Generate alternative times for unavailable slots
    function getAlternativeTimes(baseTime: Date): string[] {
      const alternatives = [];
      
      // Next day, same time
      const nextDay = new Date(baseTime);
      nextDay.setDate(nextDay.getDate() + 1);
      alternatives.push(nextDay.toLocaleString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        hour12: true
      }));
      
      // Same day, 2 hours later
      const laterTime = new Date(baseTime);
      laterTime.setHours(laterTime.getHours() + 2);
      alternatives.push(laterTime.toLocaleString('en-US', {
        weekday: 'long',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        hour12: true
      }));
      
      return alternatives;
    }
    
    let message = '';
    if (conflictingAppointment) {
      const alternatives = getAlternativeTimes(requestedTime);
      message = `No ${formattedTime} is not available, here are ${alternatives[0]} and ${alternatives[1]}`;
    } else {
      message = `Yes ${formattedTime} is available`;
    }
    
    // Format response according to Vapi docs - simplified to exactly match the docs
    const response = {
      results: [{
        toolCallId: toolCallId,
        result: message
      }]
    };
    
    // Return the result
    log('Sending response', response);
    return NextResponse.json(
      response,
      { headers: corsHeaders }
    );
    
  } catch (error) {
    // Log the error and return error response
    log('Error checking availability', error as Record<string, unknown>);
    
    const toolCallId = reqBody?.tool_call_id || '';
    const errorMessage = 'error';
    
    return NextResponse.json(
      {
        results: [{
          toolCallId: toolCallId,
          result: errorMessage
        }]
      },
      { 
        status: 500,
        headers: corsHeaders 
      }
    );
  }
}

export async function OPTIONS() {
  return new NextResponse(null, {
    headers: corsHeaders,
  });
}

================
File: app/api/tools/route.ts
================
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';
import type { ToolInfo } from '@/app/types/vapi';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function GET() {
  // Basic validation check
  if (!VAPI_API_KEY) {
    console.error("VAPI_API_KEY is not set in environment variables.");
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    // Initialize Vapi Client
    const vapi = new VapiClient({ token: VAPI_API_KEY });

    // Fetch all tools for the organization
    console.log("[tools] Fetching all tools for the organization");
    const tools = await vapi.tools.list();

    if (!tools || !Array.isArray(tools)) {
      console.log("[tools] No tools found or invalid response format");
      // Return empty array if no tools found
      return NextResponse.json({ tools: [] });
    }

    // Transform tools to consistent format
    const formattedTools: ToolInfo[] = tools.map(tool => {
      // Cast the tool to appropriate shape
      const typedTool = tool as unknown as Record<string, unknown>;

      return {
        id: typedTool.id as string | undefined,
        name: ((typedTool.function as Record<string, unknown> | undefined)?.name as string) || typedTool.type as string,
        description: ((typedTool.function as Record<string, unknown> | undefined)?.description as string) || 
                     (typedTool.description as string) || 
                     `A ${typedTool.type as string} tool.`,
        type: typedTool.type as string,
        function: typedTool.function as {
          name?: string;
          description?: string;
          parameters?: Record<string, unknown>;
        } | undefined,
        destinations: typedTool.destinations as string[] | undefined,
        knowledgeBases: typedTool.knowledgeBases as string[] | undefined
      };
    });

    console.log(`[tools] Successfully fetched ${formattedTools.length} tools`);
    return NextResponse.json({ tools: formattedTools });
  } catch (error) {
    // Log and return error
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error("[tools] Error fetching tools:", errorMessage);
    return NextResponse.json({ error: 'Failed to fetch tools' }, { status: 500 });
  }
}

================
File: app/api/update-assistant-config/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('API Key missing in server environment.');
    return NextResponse.json({ error: 'Server configuration error.' }, { status: 500 });
  }

  try {
    const { assistantId, updatePayload } = await request.json();

    if (!assistantId || typeof assistantId !== 'string') {
      return NextResponse.json({ error: 'assistantId is required.' }, { status: 400 });
    }
    if (!updatePayload || typeof updatePayload !== 'object') {
      return NextResponse.json({ error: 'updatePayload object is required.' }, { status: 400 });
    }

    console.log(`API: Updating config for assistant ${assistantId}...`);

    const updateResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updatePayload),
    });

    const responseData = await updateResponse.json();

    if (!updateResponse.ok) {
      console.error(`API Error (Update Assistant): ${updateResponse.status}`, responseData);
      return NextResponse.json({ error: `Failed to update assistant: ${responseData.message || updateResponse.statusText}` }, { status: updateResponse.status });
    }

    console.log(`API: Successfully updated assistant ${assistantId}.`);
    return NextResponse.json({ success: true, assistant: responseData });

  } catch (error) {
    console.error('API Error in /api/update-assistant-config:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/update-assistant-prompt/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;
// Note: We get assistantId from the request body now, but keep VAPI_ASSISTANT_ID for potential fallback or validation if needed.
// const VAPI_ASSISTANT_ID = process.env.VAPI_ASSISTANT_ID;

// Define interface for message object
interface VapiMessage {
  role: string;
  content: string;
}

export async function POST(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('VAPI_API_KEY is not set');
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    const { assistantId, newPrompt } = await request.json();

    if (!assistantId || typeof assistantId !== 'string') {
      return NextResponse.json({ error: 'assistantId is required in the request body' }, { status: 400 });
    }
    if (typeof newPrompt !== 'string') { // Allow empty string but require the key
      return NextResponse.json({ error: 'newPrompt (string) is required in the request body' }, { status: 400 });
    }

    console.log(`Fetching current config for assistant ${assistantId} before updating prompt...`);

    // --- 1. Fetch current assistant config ---
    const fetchResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'GET',
      headers: { 'Authorization': `Bearer ${VAPI_API_KEY}` },
    });

    if (!fetchResponse.ok) {
      const errorBody = await fetchResponse.text();
      console.error(`Failed to fetch assistant ${assistantId}. Status: ${fetchResponse.status}, Body: ${errorBody}`);
      return NextResponse.json({ error: `Vapi API Error: Failed to fetch assistant. Status: ${fetchResponse.status}`, details: errorBody }, { status: fetchResponse.status });
    }
    const currentAssistant = await fetchResponse.json();
    console.log(`Successfully fetched current configuration for assistant ${assistantId}.`);

    // --- 2. Prepare PATCH payload ---
    // Ensure model and messages array exist, create if necessary
    const currentModel = currentAssistant.model || { provider: 'openai', model: 'gpt-4o', messages: [] }; // Provide defaults
    const currentMessages = Array.isArray(currentModel.messages) ? currentModel.messages : [];

    let systemPromptFound = false;
    const updatedMessages = currentMessages.map((msg: VapiMessage) => {
      if (msg.role === 'system') {
        systemPromptFound = true;
        // Update the content of the existing system prompt
        return { ...msg, content: newPrompt };
      }
      return msg; // Keep other messages as they are
    });

    // If no system prompt was found, add a new one
    if (!systemPromptFound) {
      updatedMessages.unshift({ role: 'system', content: newPrompt }); // Add to the beginning
    }

    const updatePayload = {
      model: {
        ...currentModel, // Keep other model settings (provider, model name, tools, etc.)
        messages: updatedMessages, // Set the updated messages array
      },
      // Include other top-level fields from currentAssistant if you want to ensure they aren't reset
      // Example: name: currentAssistant.name, voice: currentAssistant.voice, etc.
      // However, PATCH should ideally only update the specified 'model' object here.
    };

    console.log(`Updating assistant ${assistantId} with new system prompt...`);

    // --- 3. Send PATCH request ---
    const updateResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updatePayload),
    });

    const responseData = await updateResponse.json();

    if (!updateResponse.ok) {
      console.error(`Vapi API Error (Update Assistant ${assistantId}): ${updateResponse.status}`, responseData);
      return NextResponse.json({ error: `Failed to update assistant: ${responseData.message || updateResponse.statusText}` }, { status: updateResponse.status });
    }

    console.log(`Successfully updated assistant ${assistantId}.`);
    return NextResponse.json({ success: true, assistant: responseData });

  } catch (error) {
    console.error('Error in /api/update-assistant-prompt:', error);
    const message = error instanceof Error ? error.message : 'Unknown error during prompt update';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/update-tool/route.ts
================
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';
import type { ToolUpdatePayload } from '@/app/types/vapi';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  // Basic validation check
  if (!VAPI_API_KEY) {
    console.error("VAPI_API_KEY is not set in environment variables.");
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    // Parse request body
    const body = await request.json() as { updatePayload: ToolUpdatePayload };
    const { updatePayload } = body;

    // Validate required fields
    if (!updatePayload || !updatePayload.id || !updatePayload.type) {
      return NextResponse.json({ 
        error: 'Missing required fields: toolId and type are required' 
      }, { status: 400 });
    }

    const { id: toolId, ...toolData } = updatePayload;
    console.log(`[update-tool] Updating tool ${toolId} with data:`, toolData);

    // Initialize Vapi Client
    const vapi = new VapiClient({ token: VAPI_API_KEY });

    // Update the tool
    // Use type assertion to bypass TypeScript checking since we know our data structure is valid
    // for Vapi's API but TypeScript definitions might be stricter
    const updatedTool = await vapi.tools.update(toolId, toolData as any);
    
    if (!updatedTool) {
      console.log(`[update-tool] Failed to update tool ${toolId}`);
      return NextResponse.json({ error: 'Failed to update tool' }, { status: 500 });
    }

    console.log(`[update-tool] Successfully updated tool ${toolId}`);
    return NextResponse.json({ success: true, tool: updatedTool });
  } catch (error) {
    // Log and return error
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error("[update-tool] Error updating tool:", errorMessage);
    return NextResponse.json({ error: 'Failed to update tool' }, { status: 500 });
  }
}

================
File: app/api/upload-kb-file/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

export async function POST(request: Request) {
  if (!VAPI_API_KEY) {
    console.error('VAPI_API_KEY is not set');
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  try {
    const { content, filename } = await request.json();

    if (!content || typeof content !== 'string' || content.trim() === '') {
      return NextResponse.json({ error: 'File content cannot be empty' }, { status: 400 });
    }
    if (!filename || typeof filename !== 'string') {
        return NextResponse.json({ error: 'Filename is required' }, { status: 400 });
    }

    console.log(`Received request to upload file: ${filename}`);

    // Create a Blob from the text content
    const blob = new Blob([content], { type: 'text/plain' });

    // Create FormData to send the Blob as a file
    const formData = new FormData();
    formData.append('file', blob, filename); // Vapi expects the field name 'file'

    console.log(`Uploading ${filename} to Vapi...`);

    const response = await fetch('https://api.vapi.ai/file', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        // Content-Type is set automatically by fetch when using FormData
      },
      body: formData,
    });

    const responseData = await response.json();

    if (!response.ok) {
      console.error(`Vapi API Error (Upload File ${filename}): ${response.status}`, responseData);
      return NextResponse.json({ error: `Failed to upload file to Vapi: ${responseData.message || response.statusText}` }, { status: response.status });
    }

    console.log(`Successfully uploaded ${filename}. File ID: ${responseData.id}`);
    return NextResponse.json({ fileId: responseData.id });

  } catch (error) {
    console.error('Error in /api/upload-kb-file:', error);
    const message = error instanceof Error ? error.message : 'Unknown error during file upload';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/dashboard/page.tsx
================
"use client"

import { Bell, Search } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"

export default function DashboardPage() {
  return (
    <div className="flex flex-col p-6">
      <div className="flex flex-col space-y-4 md:flex-row md:items-center md:justify-between md:space-y-0">
        <h1 className="text-2xl font-bold">Dashboard</h1>
        <div className="flex items-center space-x-2">
          <div className="relative">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              type="search"
              placeholder="Search..."
              className="w-full rounded-md bg-background pl-8 md:w-[200px] lg:w-[300px]"
            />
          </div>
          <div className="flex h-9 w-9 items-center justify-center">
            <div className="relative">
              <div className="h-2 w-2 rounded-full bg-green-500 ring-2 ring-green-500/25 animate-pulse" />
            </div>
          </div>
          <Button variant="ghost" size="icon">
            <Bell className="h-5 w-5" />
            <span className="sr-only">Notifications</span>
          </Button>
        </div>
      </div>
      <div className="mt-8">
        {/* Dashboard content will be added here */}
      </div>
    </div>
  )
}

================
File: app/dynamic-kb/page.tsx
================
"use client";

import React, { useState } from 'react';
import { Loader2, AlertCircle, CheckCircle, UploadCloud } from 'lucide-react';

export default function DynamicKnowledgeBasePage() {
  const [kbContent1, setKbContent1] = useState<string>("Q: What should I do if the user says they are in pain?\nA: If the user expresses being in pain, immediately ask clarifying questions like 'Where is the pain located?' and 'On a scale of 1 to 10, how severe is the pain?'. Then, advise them to seek medical attention if the pain is severe or persistent. Do not provide medical diagnoses.");
  const [kbContent2, setKbContent2] = useState<string>("Q: What are the business hours?\nA: Our business hours are Monday to Friday, 9 AM to 5 PM Eastern Time.");
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [statusMessage, setStatusMessage] = useState<string>('');
  const [errorMessage, setErrorMessage] = useState<string>('');

  const assistantId = process.env.NEXT_PUBLIC_VAPI_ASSISTANT_ID || "YOUR_ASSISTANT_ID_HERE"; // Fallback

  if (!process.env.NEXT_PUBLIC_VAPI_ASSISTANT_ID) {
      console.warn("NEXT_PUBLIC_VAPI_ASSISTANT_ID is not set in environment variables. Using placeholder.");
  }


  const handleCreateKnowledgeBase = async () => {
    setIsLoading(true);
    setStatusMessage('');
    setErrorMessage('');

    const knowledgeEntries = [
      { filename: `kb_entry_1_${Date.now()}.txt`, content: kbContent1 },
      { filename: `kb_entry_2_${Date.now()}.txt`, content: kbContent2 },
      // Add more entries if you have more text boxes
    ].filter(entry => entry.content.trim() !== ''); // Filter out empty entries

    if (knowledgeEntries.length === 0) {
      setErrorMessage("Please provide content for at least one knowledge base entry.");
      setIsLoading(false);
      return;
    }

    try {
      // --- 1. Upload Files ---
      setStatusMessage(`Uploading ${knowledgeEntries.length} knowledge base file(s)...`);
      const uploadPromises = knowledgeEntries.map(entry =>
        fetch('/api/upload-kb-file', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: entry.content, filename: entry.filename }),
        }).then(res => res.json())
      );

      const uploadResults = await Promise.all(uploadPromises);

      const fileIds: string[] = [];
      for (const result of uploadResults) {
        if (result.error || !result.fileId) {
          throw new Error(`Failed to upload file: ${result.error || 'Unknown error'}`);
        }
        fileIds.push(result.fileId);
      }
      setStatusMessage(`Successfully uploaded ${fileIds.length} file(s). File IDs: ${fileIds.join(', ')}`);
      console.log("Uploaded File IDs:", fileIds);

      // --- 2. Create Query Tool ---
      const toolName = `dynamic_kb_query_${Date.now()}`;
      const kbName = `dynamic_kb_${Date.now()}`;
      const kbDescription = "Dynamically created knowledge base for user queries."; // Customize as needed

      setStatusMessage(`Creating query tool "${toolName}" with knowledge base "${kbName}"...`);
      const createToolResponse = await fetch('/api/create-query-tool', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ fileIds, toolName, kbName, kbDescription }),
      });

      const createToolResult = await createToolResponse.json();
      if (createToolResult.error || !createToolResult.toolId) {
        throw new Error(`Failed to create query tool: ${createToolResult.error || 'Unknown error'}`);
      }
      const toolId = createToolResult.toolId;
      setStatusMessage(`Successfully created query tool. Tool ID: ${toolId}`);
      console.log("Created Tool ID:", toolId);

      // --- 3. Update Assistant ---
      setStatusMessage(`Attaching tool ${toolId} to assistant ${assistantId}...`);
      const updateAssistantResponse = await fetch('/api/update-assistant-tool', {
        method: 'POST', // Using POST for simplicity, could be PATCH
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ assistantId, toolId }),
      });

      const updateAssistantResult = await updateAssistantResponse.json();
      if (updateAssistantResult.error || !updateAssistantResult.success) {
        throw new Error(`Failed to update assistant: ${updateAssistantResult.error || 'Unknown error'}`);
      }
      setStatusMessage(`Successfully attached tool to assistant ${assistantId}!`);
      console.log("Assistant updated successfully:", updateAssistantResult.assistant);

    } catch (error) {
      const message = error instanceof Error ? error.message : 'An unknown error occurred';
      setErrorMessage(message);
      console.error("Error in handleCreateKnowledgeBase:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-6 bg-gray-50 dark:bg-gray-900 min-h-screen">
      <h1 className="text-3xl font-bold mb-6 text-center text-gray-800 dark:text-gray-100">
        Dynamic Knowledge Base Creator
      </h1>

      <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md space-y-4">
        <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
          Enter text content below. Each text box will be saved as a separate `.txt` file and added to a new knowledge base for your assistant.
          Remember to instruct your assistant in its system prompt when to use the query tool (e.g., &quot;Use the &apos;dynamic_kb_query_...&apos; tool when the user asks about pain or business hours.&quot;).
        </p>

        {/* Knowledge Base Entry 1 */}
        <div>
          <label htmlFor="kbContent1" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Knowledge Base Entry 1 (e.g., Pain Handling)
          </label>
          <textarea
            id="kbContent1"
            rows={6}
            className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
            value={kbContent1}
            onChange={(e) => setKbContent1(e.target.value)}
            placeholder="Enter knowledge base content here..."
          />
        </div>

        {/* Knowledge Base Entry 2 */}
        <div>
          <label htmlFor="kbContent2" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Knowledge Base Entry 2 (e.g., Business Hours)
          </label>
          <textarea
            id="kbContent2"
            rows={4}
            className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100"
            value={kbContent2}
            onChange={(e) => setKbContent2(e.target.value)}
            placeholder="Enter more knowledge base content..."
          />
        </div>

        {/* Add more text areas as needed */}

        <button
          onClick={handleCreateKnowledgeBase}
          disabled={isLoading || !assistantId}
          type="button"
          className={`w-full flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white ${
            isLoading ? 'bg-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500'
          } transition duration-150 ease-in-out`}
        >
          {isLoading ? (
            <>
              <Loader2 className="animate-spin mr-2 h-4 w-4" /> Processing...
            </>
          ) : (
            <>
              <UploadCloud className="mr-2 h-4 w-4" /> Create KB, Query Tool & Update Assistant
            </>
          )}
        </button>
         {!assistantId && (
             <p className="text-xs text-yellow-600 dark:text-yellow-400 text-center mt-2">
                 Warning: NEXT_PUBLIC_VAPI_ASSISTANT_ID is not set. Please configure it in your environment variables.
             </p>
         )}

        {/* Status & Error Messages */}
        {statusMessage && (
          <div className="mt-4 p-3 bg-green-100 dark:bg-green-900 border border-green-400 text-green-700 dark:text-green-200 rounded-md text-sm flex items-center">
            <CheckCircle className="h-4 w-4 mr-2" /> {statusMessage}
          </div>
        )}
        {errorMessage && (
          <div className="mt-4 p-3 bg-red-100 dark:bg-red-900 border border-red-400 text-red-700 dark:text-red-200 rounded-md text-sm flex items-center">
            <AlertCircle className="h-4 w-4 mr-2" /> {errorMessage}
          </div>
        )}
      </div>
    </div>
  );
}

================
File: app/edit-prompt/page.tsx
================
"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { Loader2, Save, AlertCircle, CheckCircle, RefreshCcw } from 'lucide-react';

export default function EditAssistantPromptPage() {
  const [initialPrompt, setInitialPrompt] = useState<string>('');
  const [editedPrompt, setEditedPrompt] = useState<string>('');
  const [isLoading, setIsLoading] = useState<boolean>(true); // Start loading initially
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [statusMessage, setStatusMessage] = useState<string>('');
  const [errorMessage, setErrorMessage] = useState<string>('');

  // Get Assistant ID from public env var for display/confirmation
  const assistantId = process.env.NEXT_PUBLIC_VAPI_ASSISTANT_ID;

  // Fetch the current prompt when the component mounts
  const fetchCurrentPrompt = useCallback(async () => {
    setIsLoading(true);
    setStatusMessage('');
    setErrorMessage('');
    try {
      const response = await fetch('/api/get-assistant-prompt');
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || `Failed to fetch prompt (status: ${response.status})`);
      }

      const prompt = data.prompt || ''; // Handle case where prompt might be null/undefined
      setInitialPrompt(prompt);
      setEditedPrompt(prompt);
      setStatusMessage('Current prompt loaded.');
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error fetching prompt.';
      console.error("Fetch prompt error:", error);
      setErrorMessage(message);
      setInitialPrompt(''); // Clear prompts on error
      setEditedPrompt('');
    } finally {
      setIsLoading(false);
    }
  }, []); // No dependencies, runs once on mount

  useEffect(() => {
    if (!assistantId) {
        setErrorMessage("Error: NEXT_PUBLIC_VAPI_ASSISTANT_ID is not set in environment variables.");
        setIsLoading(false);
        return;
    }
    fetchCurrentPrompt();
  }, [assistantId, fetchCurrentPrompt]); // Re-fetch if assistantId changes (though unlikely with env var)

  // Handle saving the updated prompt
  const handleUpdatePrompt = async () => {
    if (!assistantId) {
        setErrorMessage("Cannot update: Assistant ID is missing.");
        return;
    }
    setIsSaving(true);
    setStatusMessage('');
    setErrorMessage('');
    try {
      const response = await fetch('/api/update-assistant-prompt', {
        method: 'POST', // Using POST to send data
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ assistantId: assistantId, newPrompt: editedPrompt }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || `Failed to update prompt (status: ${response.status})`);
      }

      // Update the 'initialPrompt' to reflect the newly saved state
      setInitialPrompt(editedPrompt);
      setStatusMessage('System prompt updated successfully!');
      console.log("Update successful:", data.assistant); // Log updated assistant data

    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error updating prompt.';
      console.error("Update prompt error:", error);
      setErrorMessage(message);
    } finally {
      setIsSaving(false);
    }
  };

  // Handle resetting the text area to the last fetched prompt
  const handleReset = () => {
    setEditedPrompt(initialPrompt);
    setStatusMessage('Editor reset to last loaded prompt.');
    setErrorMessage('');
  };

  const hasChanges = editedPrompt !== initialPrompt;

  return (
    <div className="container mx-auto p-6 bg-gray-50 dark:bg-gray-900 min-h-screen">
      <h1 className="text-3xl font-bold mb-2 text-center text-gray-800 dark:text-gray-100">
        Edit Assistant System Prompt
      </h1>
      {assistantId ? (
        <p className="text-sm text-center text-gray-500 dark:text-gray-400 mb-6">
          Assistant ID: <code className="bg-gray-200 dark:bg-gray-700 px-1 rounded">{assistantId}</code>
        </p>
      ) : (
         <div className="my-4 p-3 bg-yellow-100 dark:bg-yellow-900 border border-yellow-400 text-yellow-700 dark:text-yellow-200 rounded-md text-sm flex items-center justify-center">
            <AlertCircle className="h-4 w-4 mr-2" /> NEXT_PUBLIC_VAPI_ASSISTANT_ID is not configured. Cannot load or save prompt.
         </div>
      )}

      <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md space-y-4">
        <label htmlFor="systemPrompt" className="block text-lg font-medium text-gray-700 dark:text-gray-300 mb-2">
          System Prompt
        </label>

        {isLoading ? (
          <div className="flex justify-center items-center h-40">
            <Loader2 className="animate-spin h-8 w-8 text-indigo-600 dark:text-indigo-400" />
          </div>
        ) : (
          <textarea
            id="systemPrompt"
            rows={15}
            className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-gray-100 text-sm font-mono"
            value={editedPrompt}
            onChange={(e) => setEditedPrompt(e.target.value)}
            placeholder="Enter system prompt here..."
            disabled={!assistantId} // Disable if ID is missing
          />
        )}

        {/* Status & Error Messages */}
        {statusMessage && !errorMessage && (
          <div className="mt-4 p-3 bg-green-100 dark:bg-green-900 border border-green-400 text-green-700 dark:text-green-200 rounded-md text-sm flex items-center">
            <CheckCircle className="h-4 w-4 mr-2 flex-shrink-0" /> {statusMessage}
          </div>
        )}
        {errorMessage && (
          <div className="mt-4 p-3 bg-red-100 dark:bg-red-900 border border-red-400 text-red-700 dark:text-red-200 rounded-md text-sm flex items-center">
            <AlertCircle className="h-4 w-4 mr-2 flex-shrink-0" /> {errorMessage}
          </div>
        )}

        <div className="flex flex-col sm:flex-row justify-end space-y-2 sm:space-y-0 sm:space-x-3 mt-4">
           <button
            onClick={handleReset}
            disabled={isLoading || isSaving || !hasChanges}
            type="button"
            className={`flex items-center justify-center px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-200 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed transition duration-150 ease-in-out`}
          >
            <RefreshCcw className="mr-2 h-4 w-4" /> Reset Changes
          </button>
          <button
            onClick={handleUpdatePrompt}
            disabled={isLoading || isSaving || !hasChanges || !assistantId}
            type="button"
            className={`flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white ${
              isSaving ? 'bg-gray-400 cursor-not-allowed' : 'bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500'
            } disabled:opacity-50 disabled:cursor-not-allowed transition duration-150 ease-in-out`}
          >
            {isSaving ? (
              <>
                <Loader2 className="animate-spin mr-2 h-4 w-4" /> Saving...
              </>
            ) : (
              <>
                <Save className="mr-2 h-4 w-4" /> Update Prompt
              </>
            )}
          </button>
        </div>
      </div>
    </div>
  );
}

================
File: app/patients/page.tsx
================
"use client";

import { useState, useEffect } from 'react';
import Link from 'next/link';

type Patient = {
  id: string;
  firstName: string;
  lastName: string;
  email: string | null;
  phoneNumber: string | null;
};

export default function PatientsPage() {
  const [patients, setPatients] = useState<Patient[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Load patients
  useEffect(() => {
    const fetchPatients = async () => {
      try {
        setLoading(true);
        const res = await fetch('/api/patients');
        
        if (!res.ok) {
          throw new Error('Failed to fetch patients');
        }
        
        const data = await res.json();
        setPatients(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };
    
    fetchPatients();
  }, []);

  if (loading) {
    return <div className="flex justify-center p-8">Loading patients...</div>;
  }
  
  if (error) {
    return <div className="p-8 text-red-600">Error: {error}</div>;
  }

  return (
    <div className="container mx-auto p-4">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Patients</h1>
        <Link 
          href="/calendar" 
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
        >
          Back to Calendar
        </Link>
      </div>
      
      <div className="overflow-x-auto">
        <table className="min-w-full bg-white border border-gray-200">
          <thead className="bg-gray-100">
            <tr>
              <th className="py-2 px-4 border-b text-left">Name</th>
              <th className="py-2 px-4 border-b text-left">Email</th>
              <th className="py-2 px-4 border-b text-left">Phone</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200">
            {patients.length > 0 ? (
              patients.map(patient => (
                <tr key={patient.id} className="hover:bg-gray-50">
                  <td className="py-2 px-4">{patient.firstName} {patient.lastName}</td>
                  <td className="py-2 px-4">{patient.email || 'N/A'}</td>
                  <td className="py-2 px-4">{patient.phoneNumber || 'N/A'}</td>
                </tr>
              ))
            ) : (
              <tr>
                <td colSpan={3} className="py-4 text-center text-gray-500">
                  No patients found
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}

================
File: app/tool-configuration/_components/EditToolModal.tsx
================
"use client";

import { useState, useEffect } from "react";
import { Sheet, SheetContent, SheetHeader, SheetTitle } from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import type { ToolInfo, ToolUpdatePayload } from "@/app/types/vapi";

interface EditToolModalProps {
  tool: ToolInfo | null;
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
  onSave: (updatePayload: ToolUpdatePayload) => Promise<void>;
  isLoading: boolean;
}

export default function EditToolModal({
  tool,
  isOpen,
  onOpenChange,
  onSave,
  isLoading,
}: EditToolModalProps) {
  const [name, setName] = useState<string>(tool?.name || "");
  const [description, setDescription] = useState<string>(tool?.description || "");

  // Reset form when tool changes
  useEffect(() => {
    if (tool) {
      setName(tool.name || "");
      setDescription(tool.description || "");
    }
  }, [tool]);

  const handleSave = async () => {
    if (!tool) return;

    // Create update payload - always include the type as it's required by Vapi
    const updatePayload: ToolUpdatePayload = {
      id: tool.id as string,
      type: tool.type,
      name,
      description,
    };

    // If it's a function tool, we need to update the function property
    if (tool.type === "function" && tool.function) {
      updatePayload.function = {
        ...tool.function,
        name,
        description,
      };
    }

    await onSave(updatePayload);
  };

  return (
    <Sheet open={isOpen} onOpenChange={onOpenChange}>
      <SheetContent className="sm:max-w-md">
        <SheetHeader>
          <SheetTitle>Edit Tool</SheetTitle>
        </SheetHeader>
        <div className="mt-6 space-y-4">
          <div className="space-y-2">
            <div className="text-sm font-medium">Tool Type</div>
            <div className="px-3 py-2 border rounded-md bg-muted/50">
              {tool?.type}
            </div>
          </div>
          
          <div className="space-y-2">
            <label htmlFor="name" className="text-sm font-medium">Name</label>
            <Input
              id="name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="Tool name"
              disabled={isLoading}
            />
          </div>
          
          <div className="space-y-2">
            <label htmlFor="description" className="text-sm font-medium">Description</label>
            <Textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Tool description"
              disabled={isLoading}
            />
          </div>

          <div className="flex items-center justify-end gap-2 pt-4">
            <Button
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isLoading}
            >
              Cancel
            </Button>
            <Button onClick={handleSave} disabled={isLoading}>
              {isLoading ? "Saving..." : "Save Changes"}
            </Button>
          </div>
        </div>
      </SheetContent>
    </Sheet>
  );
}

================
File: app/tool-configuration/page.tsx
================
"use client";

import { useState, useEffect } from "react";
import { Table, TableHeader, TableRow, TableHead, TableBody, TableCell } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { AlertCircle, PencilIcon, Trash2Icon, Loader2 } from "lucide-react";
import type { ToolInfo, ToolUpdatePayload } from "@/app/types/vapi";
import EditToolModal from "./_components/EditToolModal";
import { Alert } from "@/components/ui/alert";

export default function ToolConfigurationPage() {
  const [tools, setTools] = useState<ToolInfo[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [editingTool, setEditingTool] = useState<ToolInfo | null>(null);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [isDeleting, setIsDeleting] = useState<string | null>(null);

  // Fetch tools on component mount
  useEffect(() => {
    fetchTools();
  }, []);

  const fetchTools = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const response = await fetch("/api/tools");
      
      if (!response.ok) {
        throw new Error(`Error fetching tools: ${response.statusText}`);
      }
      
      const data = await response.json();
      setTools(data.tools || []);
    } catch (err) {
      console.error("Failed to fetch tools:", err);
      setError("Failed to load tools. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  const handleEditTool = (tool: ToolInfo) => {
    setEditingTool(tool);
    setIsEditModalOpen(true);
  };

  const handleSaveTool = async (updatePayload: ToolUpdatePayload) => {
    try {
      setIsSaving(true);
      setError(null);
      
      const response = await fetch("/api/update-tool", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ updatePayload }),
      });
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || `Error updating tool: ${response.statusText}`);
      }
      
      // Update the tool in the local state
      setTools(prevTools => 
        prevTools.map(tool => 
          tool.id === updatePayload.id 
            ? { ...tool, name: updatePayload.name || tool.name, description: updatePayload.description || tool.description }
            : tool
        )
      );
      
      // Close the modal
      setIsEditModalOpen(false);
      setEditingTool(null);
    } catch (err) {
      console.error("Failed to update tool:", err);
      setError(err instanceof Error ? err.message : "Failed to update tool");
    } finally {
      setIsSaving(false);
    }
  };

  const handleDeleteTool = async (toolId: string) => {
    // Confirm before deleting
    if (!window.confirm("Are you sure you want to delete this tool? This action cannot be undone.")) {
      return;
    }
    
    try {
      setIsDeleting(toolId);
      setError(null);
      
      const response = await fetch("/api/delete-tool", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ toolId }),
      });
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || `Error deleting tool: ${response.statusText}`);
      }
      
      // Remove the tool from the local state
      setTools(prevTools => prevTools.filter(tool => tool.id !== toolId));
    } catch (err) {
      console.error("Failed to delete tool:", err);
      setError(err instanceof Error ? err.message : "Failed to delete tool");
    } finally {
      setIsDeleting(null);
    }
  };

  return (
    <div className="container py-8 space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Tool Configuration</h1>
      </div>
      
      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <div className="ml-3">{error}</div>
        </Alert>
      )}
      
      {isLoading ? (
        <div className="space-y-3">
          <Skeleton className="h-8 w-full" />
          <Skeleton className="h-24 w-full" />
          <Skeleton className="h-24 w-full" />
          <Skeleton className="h-24 w-full" />
        </div>
      ) : tools.length === 0 ? (
        <div className="py-12 text-center text-muted-foreground">
          <p>No tools found for your organization.</p>
        </div>
      ) : (
        <div className="border rounded-md">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Name</TableHead>
                <TableHead>Type</TableHead>
                <TableHead className="hidden md:table-cell">Description</TableHead>
                <TableHead className="text-right">Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {tools.map((tool) => (
                <TableRow key={tool.id || `${tool.name}-${tool.type}`}>
                  <TableCell className="font-medium">{tool.name}</TableCell>
                  <TableCell>{tool.type}</TableCell>
                  <TableCell className="hidden md:table-cell max-w-[400px] truncate">
                    {tool.description}
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex justify-end gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleEditTool(tool)}
                        disabled={!!isDeleting}
                      >
                        <PencilIcon className="h-4 w-4" />
                        <span className="sr-only">Edit</span>
                      </Button>
                      <Button
                        variant="destructive"
                        size="sm"
                        onClick={() => handleDeleteTool(tool.id as string)}
                        disabled={isDeleting === tool.id || !tool.id}
                      >
                        {isDeleting === tool.id ? (
                          <Loader2 className="h-4 w-4 animate-spin" />
                        ) : (
                          <Trash2Icon className="h-4 w-4" />
                        )}
                        <span className="sr-only">Delete</span>
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      )}
      
      <EditToolModal
        tool={editingTool}
        isOpen={isEditModalOpen}
        onOpenChange={setIsEditModalOpen}
        onSave={handleSaveTool}
        isLoading={isSaving}
      />
    </div>
  );
}

================
File: app/types/vapi.ts
================
// Type definitions for Vapi tools

export interface ToolInfo {
  id?: string; // ID might not exist for transient tools
  name: string;
  description?: string;
  type: string; // e.g., 'function', 'query', 'transferCall'
  function?: {
    name?: string;
    description?: string;
    parameters?: Record<string, unknown>;
  };
  destinations?: string[]; // For transferCall tools
  knowledgeBases?: string[]; // For query tools
}

// Simplified interface for update payload
export interface ToolUpdatePayload {
  id: string;
  type: string; // Required for PATCH requests
  name?: string;
  description?: string;
  function?: {
    name?: string;
    description?: string;
    parameters?: Record<string, unknown>;
  };
  destinations?: string[]; // For transferCall tools
  knowledgeBases?: string[]; // For query tools
}

================
File: components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }

================
File: components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }

================
File: components/ui/dropdown-menu.tsx
================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}

================
File: components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

================
File: components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }

================
File: components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

================
File: components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

================
File: components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: components/ui/sidebar.tsx
================
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

================
File: components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: components/ui/table.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn("bg-primary font-medium text-primary-foreground", className)}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

================
File: components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

================
File: components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: components/Placeholder.tsx
================
import type { ReactNode } from 'react';

interface PlaceholderProps {
  className?: string;
  children?: ReactNode;
}

export function Placeholder({ className, children }: PlaceholderProps) {
  return (
    <div className={`flex items-center justify-center border-2 border-dashed border-gray-300 rounded-md ${className}`}>
      {children || 'Placeholder content'}
    </div>
  );
}

================
File: hooks/use-mobile.ts
================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: lib/prisma.ts
================
import { PrismaClient } from '@prisma/client'

const globalForPrisma = global as unknown as { prisma: PrismaClient }

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  })

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: prisma/migrations/20250402023503_add_appointment_fields/migration.sql
================
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'ADMIN', 'RECEPTIONIST', 'DENTIST');

-- CreateEnum
CREATE TYPE "PatientType" AS ENUM ('NEW', 'EXISTING');

-- CreateEnum
CREATE TYPE "AppointmentStatus" AS ENUM ('SCHEDULED', 'CONFIRMED', 'CANCELLED', 'COMPLETED');

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "role" "Role" NOT NULL DEFAULT 'USER',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Patient" (
    "id" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "email" TEXT,
    "phoneNumber" TEXT,
    "dateOfBirth" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Patient_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Appointment" (
    "id" TEXT NOT NULL,
    "date" TIMESTAMP(3) NOT NULL,
    "reason" TEXT NOT NULL,
    "patientType" "PatientType" NOT NULL DEFAULT 'EXISTING',
    "status" "AppointmentStatus" NOT NULL DEFAULT 'SCHEDULED',
    "notes" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "patientId" TEXT NOT NULL,

    CONSTRAINT "Appointment_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Patient_email_key" ON "Patient"("email");

-- AddForeignKey
ALTER TABLE "Patient" ADD CONSTRAINT "Patient_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Appointment" ADD CONSTRAINT "Appointment_patientId_fkey" FOREIGN KEY ("patientId") REFERENCES "Patient"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: eslint.config.mjs
================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

================
File: postcss.config.mjs
================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: .cursor/rules/project_description.mdc
================
---
description: 
globs: 
alwaysApply: false
---
# .cursorrules

project:
  name: "Laine"
  description: >
    Laine is an AI-Powered Dental Office Assistant designed to optimize dental practice workflows.
    It is built to enhance patient interactions and streamline office operations, combining a
    real-time dashboard, a customizable AI virtual assistant, intelligent call handling, and smart task
    management into one unified experience.

vision:
  - "Improve patient communication and engagement in dental practices."
  - "Empower dental staff with intuitive tools that automate routine tasks."
  - "Provide a clean, user-centric interface that makes managing dental operations effortless."
  - "Lay the groundwork for future enhancements like EHR integration and multi-channel messaging."

focus:
  - "Real-time data and actionable insights on a simplified dashboard."
  - "A highly customizable AI assistant tailored for dental office workflows."
  - "Efficient call handling with intelligent transcription and task creation."
  - "A straightforward, minimal interface that prioritizes clarity and usability."

philosophy:
  - "User-first design: Build tools that dental professionals love to use."
  - "Simplicity meets functionality: Keep the interface clean and effective."
  - "Scalable core: Establish a robust foundation for future features and integrations."

================
File: app/ai-customiser/_components/TestTab.tsx
================
"use client";

import React, { useState, useEffect } from 'react';
import Vapi from '@vapi-ai/web';
import { Mic, MicOff, Play, Square, Loader2, AlertCircle, Bot } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";

interface TestTabProps {
  assistantId: string;
}

interface TranscriptEntry {
  id: string; // Unique ID for React key
  role: 'assistant' | 'user' | 'system' | 'tool_calls' | 'tool_call_result';
  content: string;
  name?: string; // For tool results
  toolCallId?: string; // For tool results/calls
  timestamp: number;
}

// Define a generic message type for Vapi messages
interface VapiMessage {
  type?: string;
  role?: string;
  transcriptType?: string;
  transcript?: string;
  toolCallList?: Array<{
    id: string;
    function?: {
      name?: string;
      arguments?: Record<string, unknown> | string;
    };
  }>;
  toolCallResult?: {
    name: string;
    result?: unknown;
    error?: unknown;
    toolCallId: string;
  };
  content?: string;
  message?: string;
}

export function TestTab({ assistantId }: TestTabProps) {
  const [assistant, setAssistant] = useState<Vapi | null>(null);
  const [isSessionActive, setIsSessionActive] = useState<boolean>(false);
  const [isConnecting, setIsConnecting] = useState<boolean>(false);
  const [isMuted, setIsMuted] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [transcript, setTranscript] = useState<TranscriptEntry[]>([]);
  const [showToolCallNotification, setShowToolCallNotification] = useState<string | null>(null);
  const [showToolResultNotification, setShowToolResultNotification] = useState<string | null>(null);

  const publicKey = process.env.NEXT_PUBLIC_VAPI_PUBLIC_KEY;

  useEffect(() => {
    if (!publicKey) {
      setError("Unable to initialize the test system.");
      return;
    }
    const assistant = new Vapi(publicKey);
    setAssistant(assistant);

    assistant.on('call-start', () => {
      console.log('Test Call Started');
      setIsSessionActive(true);
      setIsConnecting(false);
      setError(null);
      setTranscript([]); // Clear transcript on new call
    });
    assistant.on('call-end', () => {
      console.log('Test Call Ended');
      setIsSessionActive(false);
      setIsConnecting(false);
      setIsMuted(false); // Reset mute state on call end
    });
    assistant.on('message', (message: VapiMessage) => {
      console.log('Received message:', message); // Keep for debugging

      const createEntry = (role: TranscriptEntry['role'], content: string, name?: string, toolCallId?: string): TranscriptEntry => ({
        id: `${Date.now()}-${Math.random()}`, // Simple unique key
        role,
        content,
        name,
        toolCallId,
        timestamp: Date.now()
      });

      setTranscript(prev => {
        const newEntries: TranscriptEntry[] = [];

        switch (message.type) {
          case 'transcript':
            // Only add final transcripts to the main log for clarity
            if (message.transcriptType === 'final' && message.role && message.transcript) {
              newEntries.push(createEntry(message.role as TranscriptEntry['role'], message.transcript));
            }
            break;
          case 'tool-calls':
            if (message.toolCallList && message.toolCallList.length > 0) {
              for (const tc of message.toolCallList) {
                const argsString = JSON.stringify(tc.function?.arguments || {});
                const content = `Calling tool: ${tc.function?.name}(${argsString})`;
                newEntries.push(createEntry('tool_calls', content, tc.function?.name, tc.id));
                // Trigger toaster
                setShowToolCallNotification(`Calling: ${tc.function?.name}`);
                setTimeout(() => setShowToolCallNotification(null), 3000); // Hide after 3s
              }
            }
            break;
          case 'tool-calls-result':
             if (message.toolCallResult) {
                const resultString = JSON.stringify(message.toolCallResult.result || message.toolCallResult.error || 'No result/error provided');
                const content = `Tool Result (${message.toolCallResult.name}): ${resultString}`;
                newEntries.push(createEntry('tool_call_result', content, message.toolCallResult.name, message.toolCallResult.toolCallId));
                // Trigger result toaster
                setShowToolResultNotification(`Result for ${message.toolCallResult.name}: ${resultString.substring(0, 50)}...`);
                 setTimeout(() => setShowToolResultNotification(null), 4000); // Hide after 4s
             }
            break;
          default:
             // If the message has a 'role' and 'content' or 'message', add it generically
             if (message.role && (message.content || message.message)) {
                 const content = message.content || message.message || '[No Content]';
                 // Avoid adding duplicates if transcript event already handled it
                 if (!prev.some(entry => entry.content === content && entry.role === message.role)) {
                    newEntries.push(createEntry(message.role as TranscriptEntry['role'], content as string));
                 }
             }
        }
        return [...prev, ...newEntries];
      });
    });
    assistant.on('error', (e) => {
      console.error('Assistant Error:', e);
      setError(e?.message || 'An unknown error occurred during the call.');
      setIsSessionActive(false);
      setIsConnecting(false);
    });

    return () => {
      assistant.stop(); // Ensure call stops if component unmounts
      // Clean up listeners if assistant SDK provides an 'off' method or similar
    };
  }, [publicKey]); // Re-initialize if publicKey changes

  const handleStartCall = async () => {
    if (!assistant || !assistantId) return;
    setIsConnecting(true);
    setError(null);
    setTranscript([]); // Clear transcript
    try {
      await assistant.start(assistantId);
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      setError(`Failed to start test call: ${errorMsg}`);
      setIsConnecting(false);
    }
  };

  const handleStopCall = async () => {
    if (!assistant) return;
    try {
      await assistant.stop();
    } catch (e) {
      const errorMsg = e instanceof Error ? e.message : String(e);
      setError(`Failed to stop test call: ${errorMsg}`);
    } finally {
      setIsSessionActive(false);
      setIsConnecting(false);
    }
  };

  const toggleMute = () => {
    if (!assistant) return;
    const newMutedState = !isMuted;
    assistant.setMuted(newMutedState);
    setIsMuted(newMutedState);
  };

  return (
    <div className="space-y-6 p-4 border rounded-lg bg-white dark:bg-gray-800 shadow-sm">
      <h2 className="text-xl font-semibold mb-4 flex items-center">
        <Bot className="mr-2 h-5 w-5 text-gray-600 dark:text-gray-400" /> Test Assistant
      </h2>

      {!publicKey && (
         <Alert variant="destructive">
           <AlertCircle className="h-4 w-4" />
           <AlertTitle>Configuration Error</AlertTitle>
           <AlertDescription>The assistant test system is not fully configured. Please contact your administrator.</AlertDescription>
         </Alert>
      )}

      <div className="flex flex-col sm:flex-row items-center justify-center space-y-3 sm:space-y-0 sm:space-x-4">
        {!isSessionActive ? (
          <Button
            onClick={handleStartCall}
            disabled={!assistant || isConnecting || !publicKey || !assistantId}
            className="w-full sm:w-auto"
          >
            {isConnecting ? (
              <Loader2 className="animate-spin mr-2 h-4 w-4" />
            ) : (
              <Play className="mr-2 h-5 w-5" />
            )}
            {isConnecting ? 'Connecting...' : 'Start Test Call'}
          </Button>
        ) : (
          <Button
            onClick={handleStopCall}
            variant="destructive"
            disabled={!assistant}
            className="w-full sm:w-auto"
          >
            <Square className="mr-2 h-5 w-5" /> End Test Call
          </Button>
        )}
        <Button
          variant="outline"
          onClick={toggleMute}
          disabled={!isSessionActive}
          className="w-full sm:w-auto"
        >
          {isMuted ? <MicOff className="mr-2 h-5 w-5" /> : <Mic className="mr-2 h-5 w-5" />}
          {isMuted ? 'Unmute Mic' : 'Mute Mic'}
        </Button>
      </div>

      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Call Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {/* Transcript Display Area */}
      <div className="mt-4 p-3 bg-gray-50 dark:bg-gray-700 rounded min-h-[200px] max-h-[400px] overflow-y-auto space-y-2">
        <p className="text-xs text-gray-500 dark:text-gray-400 sticky top-0 bg-gray-50 dark:bg-gray-700 py-1">Conversation Transcript:</p>
        {transcript.length === 0 && !isSessionActive && <p className="text-sm text-gray-500 dark:text-gray-400">Call not active.</p>}
        {transcript.length === 0 && isSessionActive && <p className="text-sm text-gray-500 dark:text-gray-400">Waiting for speech...</p>}
        {transcript.map((entry) => (
          <div key={entry.id} className={`text-sm ${
            entry.role === 'user' ? 'text-right' : 'text-left'
          }`}>
            <span className={`inline-block p-2 rounded-lg max-w-[80%] ${
              entry.role === 'assistant' ? 'bg-blue-100 dark:bg-blue-900 text-blue-900 dark:text-blue-100' :
              entry.role === 'user' ? 'bg-green-100 dark:bg-green-900 text-green-900 dark:text-green-100' :
              entry.role === 'system' ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-900 dark:text-yellow-100 italic' :
              entry.role === 'tool_calls' ? 'bg-purple-100 dark:bg-purple-900 text-purple-900 dark:text-purple-100 font-mono text-xs' :
              entry.role === 'tool_call_result' ? 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-200 font-mono text-xs' :
              'bg-gray-100 dark:bg-gray-600' // Default/System
            }`}>
              <span className="font-bold capitalize">{entry.role.replace('_', ' ')}{entry.name ? ` (${entry.name})` : ''}: </span>
              {entry.content}
            </span>
          </div>
        ))}
      </div>

      {/* Tool Call Toaster Notification */}
      {showToolCallNotification && (
        <div className="fixed bottom-4 right-4 bg-blue-500 text-white p-3 rounded-lg shadow-lg animate-pulse z-50 text-sm">
          {showToolCallNotification}
        </div>
      )}

      {/* Tool Result Toaster Notification */}
       {showToolResultNotification && (
         <div className="fixed bottom-16 right-4 bg-green-500 text-white p-3 rounded-lg shadow-lg z-50 text-sm max-w-xs break-words">
           {showToolResultNotification}
         </div>
       )}
    </div>
  );
}

================
File: app/ai-customiser/_components/TrainTab.tsx
================
"use client";

import React, { useState } from 'react';
import { Loader2, AlertCircle, CheckCircle, UploadCloud, FileText, Info } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";

interface TrainTabProps {
  assistantId: string;
}

export function TrainTab({ assistantId }: TrainTabProps) {
  const [kbContent, setKbContent] = useState<string>('');
  const [filename, setFilename] = useState<string>('');
  const [toolName, setToolName] = useState<string>('');
  const [kbName, setKbName] = useState<string>('');
  const [kbDescription, setKbDescription] = useState<string>('');

  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [statusMessage, setStatusMessage] = useState<string>('');
  const [errorMessage, setErrorMessage] = useState<string>('');
  const [createdToolInfo, setCreatedToolInfo] = useState<{ id: string; name: string } | null>(null);

  const handleCreateKnowledgeBase = async () => {
    if (!kbContent.trim()) {
      setErrorMessage("Knowledge base content cannot be empty.");
      return;
    }
    if (!filename.trim()) {
      setErrorMessage("Filename is required.");
      return;
    }
    if (!toolName.trim()) {
      setErrorMessage("Knowledge Tool Name is required.");
      return;
    }
    if (!kbName.trim()) {
      setErrorMessage("Knowledge Base Name is required.");
      return;
    }
    if (!kbDescription.trim()) {
      setErrorMessage("Topic Description is required.");
      return;
    }

    setIsLoading(true);
    setStatusMessage('');
    setErrorMessage('');
    setCreatedToolInfo(null); // Reset previous info

    try {
      // --- 1. Upload File ---
      setStatusMessage(`Uploading file "${filename}"...`);
      const uploadRes = await fetch('/api/upload-kb-file', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: kbContent, filename }),
      });
      const uploadData = await uploadRes.json();
      if (!uploadRes.ok || uploadData.error) {
        throw new Error(`File upload failed: ${uploadData.error || uploadRes.statusText}`);
      }
      const fileId = uploadData.fileId;
      setStatusMessage(`File "${filename}" uploaded successfully (ID: ${fileId}).`);
      console.log("Uploaded File ID:", fileId);

      // --- 2. Create Query Tool ---
      setStatusMessage(`Creating knowledge tool "${toolName}" for "${kbDescription}"...`);
      const createToolRes = await fetch('/api/create-query-tool', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ fileIds: [fileId], toolName, kbName, kbDescription }),
      });
      const createToolData = await createToolRes.json();
      if (!createToolRes.ok || createToolData.error) {
        throw new Error(`Knowledge tool creation failed: ${createToolData.error || createToolRes.statusText}`);
      }
      const toolId = createToolData.toolId;
      setStatusMessage(`Knowledge tool "${toolName}" created successfully (ID: ${toolId}).`);
      console.log("Created Tool ID:", toolId);

      // --- 3. Update Assistant ---
      setStatusMessage(`Attaching knowledge tool ${toolId} to assistant ${assistantId}...`);
      const updateAssistantRes = await fetch('/api/update-assistant-tool', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ assistantId, toolId }),
      });
      const updateAssistantData = await updateAssistantRes.json();
      if (!updateAssistantRes.ok || updateAssistantData.error) {
        throw new Error(`Assistant update failed: ${updateAssistantData.error || updateAssistantRes.statusText}`);
      }
      setStatusMessage(`Success! Knowledge tool "${toolName}" (ID: ${toolId}) attached to assistant.`);
      setCreatedToolInfo({ id: toolId, name: toolName });
      console.log("Assistant updated successfully:", updateAssistantData.assistant);

    } catch (error) {
      const message = error instanceof Error ? error.message : 'An unknown error occurred';
      setErrorMessage(message);
      console.error("Error in handleCreateKnowledgeBase:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="space-y-6 p-4 border rounded-lg bg-white dark:bg-gray-800 shadow-sm">
      <h2 className="text-xl font-semibold mb-4 flex items-center">
        <FileText className="mr-2 h-5 w-5 text-gray-600 dark:text-gray-400" /> Train Your Assistant
      </h2>

      <Alert variant="default" className="bg-blue-50 dark:bg-blue-900 border-blue-200 dark:border-blue-700">
        <Info className="h-4 w-4 text-blue-600 dark:text-blue-300" />
        <AlertTitle className="text-blue-800 dark:text-blue-200">How Knowledge Training Works</AlertTitle>
        <AlertDescription className="text-blue-700 dark:text-blue-300 text-sm">
          Enter information below that your assistant should learn. This knowledge will be uploaded and made available to your assistant. Remember to update your assistant&apos;s system prompt to tell it when to use this knowledge (e.g., &quot;Use your knowledge about {kbDescription || 'specific topics'} when asked.&quot;).
        </AlertDescription>
      </Alert>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
         <div>
            <Label htmlFor="toolName">Knowledge Tool Name</Label>
            <Input
              id="toolName"
              value={toolName}
              onChange={(e) => setToolName(e.target.value)}
              placeholder="e.g., office_policies"
              className="mt-1"
              disabled={isLoading}
            />
            <p className="text-xs text-gray-500 mt-1">A unique technical name for this knowledge (no spaces).</p>
          </div>
          <div>
            <Label htmlFor="kbName">Knowledge Base Name</Label>
            <Input
              id="kbName"
              value={kbName}
              onChange={(e) => setKbName(e.target.value)}
              placeholder="e.g., Office_Policies"
              className="mt-1"
              disabled={isLoading}
            />
             <p className="text-xs text-gray-500 mt-1">Internal name for this knowledge set (no spaces).</p>
          </div>
      </div>
       <div>
            <Label htmlFor="kbDescription">Topic Description</Label>
            <Input
              id="kbDescription"
              value={kbDescription}
              onChange={(e) => setKbDescription(e.target.value)}
              placeholder="e.g., Office hours and appointment policies"
              className="mt-1"
              disabled={isLoading}
            />
             <p className="text-xs text-gray-500 mt-1">What topics this knowledge covers (spaces allowed).</p>
          </div>

      <div>
        <Label htmlFor="kbContent">Knowledge Content</Label>
        <Textarea
          id="kbContent"
          value={kbContent}
          onChange={(e) => setKbContent(e.target.value)}
          rows={10}
          className="mt-1 w-full font-mono text-sm"
          placeholder="Enter Q&A pairs or general information here. e.g.,&#10;Q: What are your weekend hours?&#10;A: We are closed on weekends."
          disabled={isLoading}
        />
      </div>

      <div>
        <Label htmlFor="filename">Filename</Label>
        <Input
          id="filename"
          value={filename}
          onChange={(e) => setFilename(e.target.value)}
          placeholder="e.g., office_policies.txt"
          className="mt-1"
          disabled={isLoading}
        />
         <p className="text-xs text-gray-500 mt-1">A name for this knowledge file (include .txt extension).</p>
      </div>

      <Button
        onClick={handleCreateKnowledgeBase}
        disabled={isLoading || !kbContent.trim() || !filename.trim() || !toolName.trim() || !kbName.trim() || !kbDescription.trim()}
        className="w-full"
      >
        {isLoading ? (
          <Loader2 className="animate-spin mr-2 h-4 w-4" />
        ) : (
          <UploadCloud className="mr-2 h-4 w-4" />
        )}
        Upload Knowledge to Assistant
      </Button>

      {statusMessage && !errorMessage && createdToolInfo && (
        <Alert>
          <CheckCircle className="h-4 w-4" />
          <AlertTitle>Success</AlertTitle>
          <AlertDescription>
            {statusMessage} You can now reference this knowledge in your assistant&apos;s prompt using the tool name: <strong>{createdToolInfo.name}</strong>.
          </AlertDescription>
        </Alert>
      )}
      {statusMessage && !errorMessage && !createdToolInfo && (
        <Alert>
          <CheckCircle className="h-4 w-4" />
          <AlertTitle>Status</AlertTitle>
          <AlertDescription>{statusMessage}</AlertDescription>
        </Alert>
      )}
      {errorMessage && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{errorMessage}</AlertDescription>
        </Alert>
      )}
    </div>
  );
}

================
File: app/api/appointments/[id]/route.ts
================
import { PrismaClient } from '@prisma/client';
import { NextResponse } from 'next/server';

const prisma = new PrismaClient();

// DELETE appointment by ID
export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  
  try {
    // Check if appointment exists
    const appointment = await prisma.appointment.findUnique({
      where: { id },
    });

    if (!appointment) {
      return NextResponse.json({ error: 'Appointment not found' }, { status: 404 });
    }

    // Delete appointment
    await prisma.appointment.delete({
      where: { id },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting appointment:', error);
    return NextResponse.json({ error: 'Failed to delete appointment' }, { status: 500 });
  }
}

// GET appointment by ID
export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  
  try {
    const appointment = await prisma.appointment.findUnique({
      where: { id },
      include: {
        patient: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    if (!appointment) {
      return NextResponse.json({ error: 'Appointment not found' }, { status: 404 });
    }

    return NextResponse.json(appointment);
  } catch (error) {
    console.error('Error fetching appointment:', error);
    return NextResponse.json({ error: 'Failed to fetch appointment' }, { status: 500 });
  }
}

================
File: app/api/patients/route.ts
================
import { NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// GET all patients
export async function GET() {
  try {
    const patients = await prisma.patient.findMany({
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phoneNumber: true,
      },
      orderBy: {
        lastName: 'asc',
      },
    })
    
    return NextResponse.json(patients)
  } catch (error) {
    console.error('Error fetching patients:', error)
    return NextResponse.json(
      { error: 'Failed to fetch patients' },
      { status: 500 }
    )
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { firstName, lastName, email, phoneNumber, dateOfBirth, userId } = body
    
    const patient = await prisma.patient.create({
      data: {
        firstName,
        lastName,
        email,
        phoneNumber,
        dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : null,
        userId,
      },
      include: {
        user: {
          select: {
            name: true,
            email: true,
          },
        },
      },
    })
    
    return NextResponse.json(patient, { status: 201 })
  } catch (error) {
    console.error('Error creating patient:', error)
    return NextResponse.json(
      { error: 'Failed to create patient' },
      { status: 500 }
    )
  }
}

================
File: app/api/update-assistant-tool/route.ts
================
import { NextResponse } from 'next/server';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

// Simplified interface for assistant model
interface AssistantModel {
  provider?: string;
  model?: string;
  messages?: Array<{ role: string; content?: string }>;
  tools?: Array<{
    type: string;
    function?: {
      name?: string;
      description?: string;
      parameters?: Record<string, unknown>;
    };
    description?: string;
  }>;
  toolIds?: string[];
}

// Simplified interface for assistant data
interface Assistant {
  id: string;
  model?: AssistantModel;
}

export async function POST(request: Request) {
  // --- Basic Setup & Validation ---
  if (!VAPI_API_KEY) {
    console.error('[update-assistant-tool] VAPI_API_KEY is not set');
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  let assistantId: string | undefined;
  let toolIdToAdd: string | undefined;

  try {
    const body = await request.json();
    assistantId = body.assistantId;
    toolIdToAdd = body.toolId;

    if (!assistantId || typeof assistantId !== 'string') {
      return NextResponse.json({ error: 'assistantId (string) is required in the request body' }, { status: 400 });
    }
    if (!toolIdToAdd || typeof toolIdToAdd !== 'string') {
      return NextResponse.json({ error: 'toolId (string) is required in the request body' }, { status: 400 });
    }

    console.log(`[update-assistant-tool] Request received for assistant ${assistantId} to add tool ${toolIdToAdd}`);

    // --- 1. Fetch current assistant configuration ---
    console.log('[update-assistant-tool] Fetching current config for assistant...');
    
    const fetchResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
      },
    });

    if (!fetchResponse.ok) {
      const errorBody = await fetchResponse.text();
      console.error(`[update-assistant-tool] Failed to fetch assistant ${assistantId}. Status: ${fetchResponse.status}, Body: ${errorBody}`);
      return NextResponse.json({
        error: `Vapi API Error: Failed to fetch assistant. Status: ${fetchResponse.status}`,
        details: errorBody
      }, { status: fetchResponse.status });
    }
    
    const currentAssistant: Assistant = await fetchResponse.json();
    console.log('[update-assistant-tool] Successfully fetched current config.');

    // --- 2. Prepare PATCH payload ---
    // Ensure model object exists, provide defaults if necessary
    const currentModel = currentAssistant.model || { provider: 'openai', model: 'gpt-4o' };

    // Get existing toolIds, ensure it's an array, handle null/undefined
    const existingToolIds = Array.isArray(currentModel.toolIds) ? currentModel.toolIds : [];

    // Add the new toolId, avoiding duplicates
    const updatedToolIdsSet = new Set([...existingToolIds, toolIdToAdd]);
    const finalToolIds = Array.from(updatedToolIdsSet);

    // Construct the payload for PATCH - *only include the model part*
    // Vapi's PATCH should merge this with the existing assistant data
    const updatePayload = {
      model: {
        ...currentModel,   // Keep existing model properties (provider, model name, messages, *transient tools*)
        toolIds: finalToolIds, // Set the new, combined array of tool IDs
      },
      // DO NOT include other top-level assistant properties unless you intend to update them.
      // PATCH should merge the 'model' object.
    };

    console.log(`[update-assistant-tool] Preparing to PATCH assistant ${assistantId} with toolIds: ${finalToolIds.join(', ')}`);
    console.log('[update-assistant-tool] Full PATCH payload (model part):', JSON.stringify(updatePayload, null, 2));

    // --- 3. Send PATCH request ---
    console.log(`[update-assistant-tool] Sending PATCH request for assistant ${assistantId}...`);
    
    const updateResponse = await fetch(`https://api.vapi.ai/assistant/${assistantId}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${VAPI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updatePayload),
    });

    const responseData = await updateResponse.json();

    if (!updateResponse.ok) {
      console.error(`[update-assistant-tool] Vapi API Error (Update Assistant ${assistantId}): ${updateResponse.status}`, responseData);
      return NextResponse.json({ 
        error: `Failed to update assistant: ${responseData.message || updateResponse.statusText}` 
      }, { status: updateResponse.status });
    }

    console.log(`[update-assistant-tool] Successfully updated assistant ${assistantId}.`);
    return NextResponse.json({ success: true, assistant: responseData });

  } catch (error) {
    console.error('[update-assistant-tool] Unexpected error:', error);
    const message = error instanceof Error ? error.message : 'Unknown error during assistant update';
    // Include assistantId in error response if available
    const errorResponse = assistantId
        ? { error: `Internal Server Error updating assistant ${assistantId}`, details: message }
        : { error: 'Internal Server Error', details: message };
    return NextResponse.json(errorResponse, { status: 500 });
  }
}

================
File: app/call-logs/page.tsx
================
"use client";

import { useState, useEffect } from 'react';
import Link from 'next/link';

interface CallInfo {
  callId: string;
  createdAt: string;
  endedAt: string | null;
  endedReason: string | null;
  transcript: string | null;
  summary: string | null;
  structuredData: Record<string, unknown> | null;
}

interface TranscriptEntry {
  role?: string;
  content: string;
  id?: string;
}

export default function CallLogsPage() {
  const [calls, setCalls] = useState<CallInfo[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedCall, setSelectedCall] = useState<string | null>(null);
  const [assistantId, setAssistantId] = useState<string>('');

  // Load assistant ID from environment
  useEffect(() => {
    const fetchAssistantId = async () => {
      try {
        const res = await fetch('/api/assistant-config');
        if (!res.ok) throw new Error('Failed to load configuration');
        
        const data = await res.json();
        if (data.assistantId) {
          setAssistantId(data.assistantId);
        } else {
          setError('No assistant ID found in configuration');
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      }
    };
    
    fetchAssistantId();
  }, []);

  // Load calls from the API when assistantId changes
  useEffect(() => {
    const fetchCalls = async () => {
      if (!assistantId) return;
      
      try {
        setLoading(true);
        const res = await fetch(`/api/call-logs?assistantId=${assistantId}`);
        
        if (!res.ok) {
          throw new Error('Failed to fetch call logs');
        }
        
        const data = await res.json();
        setCalls(data);
        
        // Select the first call by default if available
        if (data.length > 0 && !selectedCall) {
          setSelectedCall(data[0].callId);
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };
    
    fetchCalls();
  }, [assistantId, selectedCall]);

  // Function to format date
  const formatDate = (dateStr: string | null) => {
    if (!dateStr) return 'N/A';
    return new Date(dateStr).toLocaleString();
  };

  // Function to get selected call data
  const getSelectedCallData = () => {
    return calls.find(call => call.callId === selectedCall);
  };

  // Generate a stable key for transcript lines
  const getStableKey = (content: string, index: number): string => {
    // Create a simple hash from the content
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      hash = ((hash << 5) - hash) + content.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return `transcript-${index}-${hash}`;
  };

  // Format transcript for readability
  const formatTranscript = (transcript: string | null) => {
    if (!transcript) return 'No transcript available';
    
    // Parse the transcript if it's in a specific format
    try {
      // Try to parse as JSON
      const entries: TranscriptEntry[] = JSON.parse(transcript);
      return entries.map((entry, index) => (
        <div key={getStableKey(entry.content, index)} className={`mb-2 ${entry.role === 'assistant' ? 'text-blue-700' : 'text-gray-800'}`}>
          <span className="font-semibold">{entry.role || 'unknown'}:</span> {entry.content}
        </div>
      ));
    } catch {
      // If it's plain text or failed to parse
      // Simple format assuming "Speaker: Text" format with newlines
      const lines = transcript.split('\n');
      return lines.map((line, index) => (
        <div key={getStableKey(line, index)} className="mb-1">
          {line}
        </div>
      ));
    }
  };

  const selectedCallData = getSelectedCallData();

  // Handle call selection with keyboard support
  const handleCallSelect = (callId: string) => {
    setSelectedCall(callId);
  };

  return (
    <div className="container mx-auto p-4">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Call Logs</h1>
        <div className="flex gap-4">
          <Link 
            href="/calendar" 
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Calendar
          </Link>
          <Link 
            href="/custom-functions" 
            className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
          >
            Custom Functions
          </Link>
        </div>
      </div>
      
      {assistantId && (
        <div className="mb-4 p-3 bg-blue-50 rounded-lg">
          <p className="text-sm">
            <span className="font-medium">Assistant ID:</span> {assistantId}
          </p>
        </div>
      )}
      
      {loading && (
        <div className="flex justify-center p-8">Loading call logs...</div>
      )}
      
      {error && (
        <div className="p-4 mb-4 text-red-600 bg-red-100 rounded">Error: {error}</div>
      )}
      
      {!loading && !error && assistantId && calls.length === 0 && (
        <div className="p-8 text-center text-gray-500">
          No calls found for this Assistant ID
        </div>
      )}
      
      {calls.length > 0 && (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {/* Call List */}
          <div className="col-span-1 border rounded-lg overflow-hidden">
            <div className="bg-gray-100 p-3 font-bold">Call History</div>
            <div className="divide-y max-h-[500px] overflow-y-auto">
              {calls.map(call => (
                <button
                  key={call.callId}
                  type="button"
                  className={`w-full text-left p-3 block cursor-pointer hover:bg-gray-50 ${
                    selectedCall === call.callId ? 'bg-blue-50' : ''
                  }`}
                  onClick={() => handleCallSelect(call.callId)}
                  role="tab"
                  aria-selected={selectedCall === call.callId}
                >
                  <div className="font-medium">{formatDate(call.createdAt)}</div>
                  <div className="text-sm text-gray-600">
                    Duration: {call.endedAt 
                      ? `${Math.round((new Date(call.endedAt).getTime() - new Date(call.createdAt).getTime()) / 1000)} seconds`
                      : 'Ongoing'}
                  </div>
                  <div className="text-xs text-gray-500">ID: {call.callId}</div>
                </button>
              ))}
            </div>
          </div>
          
          {/* Call Details */}
          <div className="col-span-1 md:col-span-2 border rounded-lg overflow-hidden">
            <div className="bg-gray-100 p-3 font-bold">Call Details</div>
            
            {selectedCallData ? (
              <div className="p-4">
                <div className="mb-4">
                  <h3 className="text-lg font-bold">Call {selectedCallData.callId}</h3>
                  <div className="grid grid-cols-2 gap-2 text-sm">
                    <div><span className="font-medium">Started:</span> {formatDate(selectedCallData.createdAt)}</div>
                    <div><span className="font-medium">Ended:</span> {formatDate(selectedCallData.endedAt)}</div>
                    <div><span className="font-medium">Reason:</span> {selectedCallData.endedReason || 'N/A'}</div>
                  </div>
                </div>
                
                {selectedCallData.summary && (
                  <div className="mb-4">
                    <h4 className="font-bold mb-2">Summary</h4>
                    <div className="p-3 bg-gray-50 rounded text-sm">
                      {selectedCallData.summary}
                    </div>
                  </div>
                )}
                
                {selectedCallData.structuredData && (
                  <div className="mb-4">
                    <h4 className="font-bold mb-2">Structured Data</h4>
                    <pre className="p-3 bg-gray-50 rounded text-sm overflow-x-auto">
                      {JSON.stringify(selectedCallData.structuredData, null, 2)}
                    </pre>
                  </div>
                )}
                
                <div>
                  <h4 className="font-bold mb-2">Transcript</h4>
                  <div className="p-3 bg-gray-50 rounded text-sm max-h-[400px] overflow-y-auto">
                    {formatTranscript(selectedCallData.transcript)}
                  </div>
                </div>
              </div>
            ) : (
              <div className="p-8 text-center text-gray-500">
                Select a call to view details
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

================
File: app/globals.css
================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: #C33768;
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: #C33768;
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: #C33768;
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: #C33768;
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: app/page.tsx
================
import { redirect } from "next/navigation"

export default function Home() {
  redirect("/dashboard")
}

================
File: components/sidebar/index.tsx
================
"use client"

import { useState } from "react"
import Link from "next/link"
import { usePathname } from "next/navigation"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet"
import {
  LayoutDashboard,
  MessageSquare,
  Users,
  Settings,
  User,
  Menu,
  LogOut,
  Sparkles,
} from "lucide-react"
import { cn } from "@/lib/utils"

const navigationItems = [
  {
    name: "Dashboard",
    href: "/dashboard",
    icon: LayoutDashboard,
  },
  {
    name: "Communications",
    href: "/communications",
    icon: MessageSquare,
  },
  {
    name: "Patient Management",
    href: "/patients",
    icon: Users,
  },
  {
    name: "AI Customiser",
    href: "/ai-customiser",
    icon: Sparkles,
  },
  {
    name: "System",
    href: "/system",
    icon: Settings,
  },
]

export function Sidebar() {
  const pathname = usePathname()
  const [open, setOpen] = useState(false)

  return (
    <>
      <aside className="hidden h-screen w-64 flex-col border-r p-4 md:flex">
        <div className="flex items-center gap-2 pb-6">
          <div className="rounded-full bg-primary p-1">
            <div className="h-8 w-8 rounded-full bg-white text-center text-xl font-bold leading-8 text-primary">
              A
            </div>
          </div>
          <div className="text-lg font-semibold">AiroDental</div>
        </div>
        
        <nav className="flex-1 space-y-1">
          {navigationItems.map((item) => {
            const isActive = pathname === item.href || pathname?.startsWith(`${item.href}/`)
            return (
              <Link
                key={item.href}
                href={item.href}
                className={cn(
                  "flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium",
                  isActive
                    ? "bg-primary text-primary-foreground"
                    : "text-muted-foreground hover:bg-secondary hover:text-foreground"
                )}
              >
                <item.icon className="h-5 w-5" />
                {item.name}
              </Link>
            )
          })}
        </nav>
        
        <div className="pt-6">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" className="w-full justify-start p-2">
                <Avatar className="mr-2 h-6 w-6">
                  <AvatarImage src="/placeholder-avatar.jpg" />
                  <AvatarFallback>JD</AvatarFallback>
                </Avatar>
                <span>John Doe</span>
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-56">
              <DropdownMenuLabel>My Account</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <User className="mr-2 h-4 w-4" />
                <span>Profile</span>
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Settings className="mr-2 h-4 w-4" />
                <span>Settings</span>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <LogOut className="mr-2 h-4 w-4" />
                <span>Log out</span>
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </aside>

      {/* Mobile sidebar */}
      <div className="flex items-center border-b p-4 md:hidden">
        <Sheet open={open} onOpenChange={setOpen}>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon">
              <Menu className="h-6 w-6" />
              <span className="sr-only">Toggle menu</span>
            </Button>
          </SheetTrigger>
          <SheetContent side="left" className="w-64 p-0">
            <SheetHeader className="border-b p-4">
              <SheetTitle className="flex items-center gap-2">
                <div className="rounded-full bg-primary p-1">
                  <div className="h-8 w-8 rounded-full bg-white text-center text-xl font-bold leading-8 text-primary">
                    A
                  </div>
                </div>
                <div className="text-lg font-semibold">AiroDental</div>
              </SheetTitle>
            </SheetHeader>
            <div className="flex flex-col">
              <nav className="flex-1 space-y-1 p-4">
                {navigationItems.map((item) => {
                  const isActive = pathname === item.href || pathname?.startsWith(`${item.href}/`)
                  return (
                    <Link
                      key={item.href}
                      href={item.href}
                      className={cn(
                        "flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium",
                        isActive
                          ? "bg-primary text-primary-foreground"
                          : "text-muted-foreground hover:bg-secondary hover:text-foreground"
                      )}
                      onClick={() => setOpen(false)}
                    >
                      <item.icon className="h-5 w-5" />
                      {item.name}
                    </Link>
                  )
                })}
              </nav>
              <div className="border-t p-4">
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" className="w-full justify-start p-2">
                      <Avatar className="mr-2 h-6 w-6">
                        <AvatarImage src="/placeholder-avatar.jpg" />
                        <AvatarFallback>JD</AvatarFallback>
                      </Avatar>
                      <span>John Doe</span>
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end" className="w-56">
                    <DropdownMenuLabel>My Account</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem>
                      <User className="mr-2 h-4 w-4" />
                      <span>Profile</span>
                    </DropdownMenuItem>
                    <DropdownMenuItem>
                      <Settings className="mr-2 h-4 w-4" />
                      <span>Settings</span>
                    </DropdownMenuItem>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem>
                      <LogOut className="mr-2 h-4 w-4" />
                      <span>Log out</span>
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </div>
          </SheetContent>
        </Sheet>
        <div className="ml-4 text-lg font-semibold">AiroDental</div>
      </div>
    </>
  )
}

================
File: components/ToolListModal.tsx
================
"use client";

import React, { useState, useEffect } from 'react';
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
  SheetTrigger,
} from "@/components/ui/sheet";
import { ListTree, Loader2, AlertCircle, ChevronDown, ChevronUp } from 'lucide-react';
import { Alert, AlertTitle, AlertDescription } from "@/components/ui/alert";

// Use a more generic type for the full Vapi Tool structure
interface VapiTool {
  id?: string;
  type: string;
  function?: {
    name?: string;
    description?: string;
    parameters?: Record<string, unknown>;
  };
  description?: string;
  destinations?: string[];
  knowledgeBases?: string[];
  [key: string]: unknown; // Allow for any other properties
}

interface ToolListModalProps {
  assistantId: string;
}

export function ToolListModal({ assistantId }: ToolListModalProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [tools, setTools] = useState<VapiTool[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [expandedTool, setExpandedTool] = useState<string | null>(null); // Track which tool detail is open

  useEffect(() => {
    const fetchTools = async () => {
      if (!isOpen || !assistantId) return; // Only fetch when open and ID is available

      setIsLoading(true);
      setError(null);
      setTools([]); // Clear previous tools
      setExpandedTool(null); // Reset expanded state
      
      try {
        console.log(`[ToolListModal] Fetching tools for assistant: ${assistantId}`);
        const response = await fetch(`/api/get-assistant-tools?id=${assistantId}`);
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || `Failed to fetch tools (status: ${response.status})`);
        }
        console.log(`[ToolListModal] Received ${data.tools?.length ?? 0} tools from API.`);
        setTools(data.tools || []);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Could not load tools');
        console.error("[ToolListModal] Fetch Error:", err);
        setTools([]);
      } finally {
        setIsLoading(false);
      }
    };

    fetchTools();
  }, [isOpen, assistantId]); // Refetch when modal opens or assistantId changes

  const toggleExpand = (toolIdentifier: string) => {
    setExpandedTool(prev => (prev === toolIdentifier ? null : toolIdentifier));
  };

  // Helper to get a display name (prioritize function name)
  const getToolDisplayName = (tool: VapiTool): string => {
     return tool.function?.name || tool.type || 'Unnamed Tool';
  };

  // Helper to get a description (prioritize function description)
  const getToolDescription = (tool: VapiTool): string | undefined => {
     return tool.function?.description || tool.description;
  };

  return (
    <Sheet open={isOpen} onOpenChange={setIsOpen}>
      <SheetTrigger asChild>
        <Button
          variant="outline"
          size="icon"
          className="fixed bottom-4 left-4 z-40 shadow-lg rounded-full"
          aria-label="Show Assistant Tools"
        >
          <ListTree className="h-5 w-5" />
        </Button>
      </SheetTrigger>
      <SheetContent side="left" className="w-[90vw] max-w-[600px] sm:max-w-[700px] overflow-y-auto">
        <SheetHeader>
          <SheetTitle>Configured Assistant Tools</SheetTitle>
          <SheetDescription>
            Tools available to assistant ID: <code className="text-xs bg-muted px-1 py-0.5 rounded">{assistantId}</code>
          </SheetDescription>
        </SheetHeader>
        <div className="py-4">
          {isLoading ? (
            <div className="flex justify-center items-center p-8">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : error ? (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>Error</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          ) : tools.length === 0 ? (
            <p className="text-center text-muted-foreground py-8">No tools configured for this assistant.</p>
          ) : (
            <ul className="space-y-3">
              {tools.map((tool) => {
                const toolKey = tool.id || `${getToolDisplayName(tool)}-${tool.type}`; // Use ID or name as key
                const isExpanded = expandedTool === toolKey;
                return (
                  <li key={toolKey} className="border dark:border-gray-700 rounded-md overflow-hidden">
                    <button
                      type="button"
                      onClick={() => toggleExpand(toolKey)}
                      className="w-full flex justify-between items-center p-3 text-left bg-card hover:bg-accent focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-1 focus:ring-offset-background"
                      aria-expanded={isExpanded}
                      aria-controls={`tool-details-${toolKey}`}
                    >
                      <div className="flex-1 min-w-0">
                        <p className="font-semibold text-card-foreground truncate">{getToolDisplayName(tool)}</p>
                        <p className="text-xs text-muted-foreground mt-1">Type: {tool.type}</p>
                        {getToolDescription(tool) && (
                          <p className="text-sm text-muted-foreground mt-1 truncate">{getToolDescription(tool)}</p>
                        )}
                        {tool.id && <p className="text-xs text-muted-foreground mt-1">ID: {tool.id}</p>}
                      </div>
                      {isExpanded ? 
                        <ChevronUp className="h-5 w-5 ml-2 flex-shrink-0" /> : 
                        <ChevronDown className="h-5 w-5 ml-2 flex-shrink-0" />
                      }
                    </button>

                    {/* Collapsible Content */}
                    {isExpanded && (
                      <div
                        id={`tool-details-${toolKey}`}
                        className="p-3 bg-muted/30 border-t"
                      >
                        <h4 className="text-sm font-medium mb-2 text-muted-foreground">Full Configuration:</h4>
                        <pre className="bg-muted p-3 rounded text-xs overflow-x-auto">
                          <code>
                            {JSON.stringify(tool, null, 2)}
                          </code>
                        </pre>
                      </div>
                    )}
                  </li>
                );
              })}
            </ul>
          )}
        </div>
      </SheetContent>
    </Sheet>
  );
}

================
File: prisma/schema.prisma
================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// User model
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  patients  Patient[]
}

enum Role {
  USER
  ADMIN
  RECEPTIONIST
  DENTIST
}

// Patient model
model Patient {
  id           String    @id @default(uuid())
  firstName    String
  lastName     String
  email        String?   @unique
  phoneNumber  String?
  dateOfBirth  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  userId       String    
  user         User      @relation(fields: [userId], references: [id])
  appointments Appointment[]
}

enum PatientType {
  NEW
  EXISTING
}

// Appointment model
model Appointment {
  id          String   @id @default(uuid())
  date        DateTime
  reason      String
  patientType PatientType @default(EXISTING)
  status      AppointmentStatus @default(SCHEDULED)
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  patientId   String
  patient     Patient  @relation(fields: [patientId], references: [id])
}

enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  CANCELLED
  COMPLETED
}

================
File: prisma/seed.ts
================
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // Clean the database
  await prisma.appointment.deleteMany({})
  await prisma.patient.deleteMany({})
  await prisma.user.deleteMany({})

  console.log('Seeding the database...')
  
  // Create admin user
  const admin = await prisma.user.create({
    data: {
      email: 'admin@airodental.com',
      name: 'Admin User',
      role: 'ADMIN',
    },
  })
  
  // Create a dentist
  const dentist = await prisma.user.create({
    data: {
      email: 'dentist@airodental.com',
      name: 'Dr. Smith',
      role: 'DENTIST',
    },
  })
  
  // Create a receptionist
  const receptionist = await prisma.user.create({
    data: {
      email: 'receptionist@airodental.com',
      name: 'Jane Doe',
      role: 'RECEPTIONIST',
    },
  })
  
  console.log('Created users:', { admin, dentist, receptionist })
  
  // Create patients
  const patient1 = await prisma.patient.create({
    data: {
      firstName: 'John',
      lastName: 'Doe',
      email: 'john.doe@example.com',
      phoneNumber: '555-123-4567',
      dateOfBirth: new Date('1985-05-15'),
      userId: dentist.id,
    },
  })
  
  const patient2 = await prisma.patient.create({
    data: {
      firstName: 'Alice',
      lastName: 'Smith',
      email: 'alice.smith@example.com',
      phoneNumber: '555-987-6543',
      dateOfBirth: new Date('1990-10-20'),
      userId: dentist.id,
    },
  })
  
  console.log('Created patients:', { patient1, patient2 })
  
  // Create appointments
  const today = new Date()
  const tomorrow = new Date(today)
  tomorrow.setDate(tomorrow.getDate() + 1)
  
  const nextWeek = new Date(today)
  nextWeek.setDate(nextWeek.getDate() + 7)
  
  const appointment1 = await prisma.appointment.create({
    data: {
      date: tomorrow,
      reason: 'Regular checkup',
      patientType: 'EXISTING',
      status: 'CONFIRMED',
      notes: 'Patient has sensitivity in lower right molar',
      patientId: patient1.id,
    },
  })
  
  const appointment2 = await prisma.appointment.create({
    data: {
      date: nextWeek,
      reason: 'Teeth cleaning',
      patientType: 'EXISTING',
      status: 'SCHEDULED',
      notes: 'Follow-up appointment after filling',
      patientId: patient2.id,
    },
  })
  
  // Add a few more appointments for the week
  const dayAfterTomorrow = new Date(today)
  dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 2)
  
  const threeDaysFromNow = new Date(today)
  threeDaysFromNow.setDate(threeDaysFromNow.getDate() + 3)
  
  const fourDaysFromNow = new Date(today)
  fourDaysFromNow.setDate(fourDaysFromNow.getDate() + 4)
  
  await prisma.appointment.create({
    data: {
      date: dayAfterTomorrow,
      reason: 'New patient consultation',
      patientType: 'NEW',
      status: 'CONFIRMED',
      notes: 'First visit, comprehensive exam needed',
      patientId: patient1.id,
    },
  })
  
  await prisma.appointment.create({
    data: {
      date: threeDaysFromNow,
      reason: 'Root canal',
      patientType: 'EXISTING',
      status: 'SCHEDULED',
      notes: 'Patient reported severe pain',
      patientId: patient2.id,
    },
  })
  
  await prisma.appointment.create({
    data: {
      date: fourDaysFromNow,
      reason: 'Wisdom tooth extraction',
      patientType: 'EXISTING',
      status: 'SCHEDULED',
      notes: 'X-rays already taken',
      patientId: patient1.id,
    },
  })
  
  console.log('Created appointments for the week')
  
  console.log('Database seeding completed.')
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error('Error during seeding:', e)
    await prisma.$disconnect()
    process.exit(1)
  })

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "scripts"]
}

================
File: app/ai-customiser/page.tsx
================
"use client"

import React, { useState, useEffect, useCallback } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ConfigureTab } from './_components/ConfigureTab';
import { TrainTab } from './_components/TrainTab';
import { TestTab } from './_components/TestTab';
import { Loader2, AlertCircle } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { ToolListModal } from '@/components/ToolListModal';

// Define a simplified type for the config needed by ConfigureTab
export interface AssistantConfig {
  name?: string;
  model?: {
    provider?: string;
    model?: string;
    messages?: Array<{ role: string; content?: string }>;
  };
  voice?: {
    provider?: string;
    voiceId?: string;
  };
  // Add other relevant fields as needed by ConfigureTab
}

export default function AICustomiserPage() {
  const [assistantConfig, setAssistantConfig] = useState<AssistantConfig | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [errorMessage, setErrorMessage] = useState<string>('');

  const assistantId = process.env.NEXT_PUBLIC_VAPI_ASSISTANT_ID;

  const fetchAssistantConfig = useCallback(async () => {
    if (!assistantId) {
      setErrorMessage("Assistant ID not configured in environment variables.");
      setIsLoading(false);
      return;
    }
    setIsLoading(true);
    setErrorMessage('');
    try {
      const response = await fetch(`/api/get-assistant-config?id=${assistantId}`);
      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || `Failed to fetch config (status: ${response.status})`);
      }
      setAssistantConfig(data);
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Unknown error loading configuration.';
      console.error("Fetch config error:", error);
      setErrorMessage(message);
      setAssistantConfig(null); // Clear config on error
    } finally {
      setIsLoading(false);
    }
  }, [assistantId]);

  useEffect(() => {
    fetchAssistantConfig();
  }, [fetchAssistantConfig]);

  return (
    <div className="flex flex-col p-6 relative">
      <h1 className="text-2xl font-bold mb-6">AI Customiser</h1>
      {!assistantId && (
        <Alert variant="destructive" className="mb-4">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Configuration Error</AlertTitle>
          <AlertDescription>
            Assistant ID is not set. Please contact your administrator.
          </AlertDescription>
        </Alert>
      )}

      {isLoading ? (
        <div className="flex justify-center items-center h-64">
          <Loader2 className="animate-spin h-12 w-12 text-primary" />
        </div>
      ) : errorMessage ? (
         <Alert variant="destructive">
           <AlertCircle className="h-4 w-4" />
           <AlertTitle>Error Loading Configuration</AlertTitle>
           <AlertDescription>{errorMessage}</AlertDescription>
         </Alert>
      ) : assistantConfig && assistantId ? (
        <Tabs defaultValue="configure" className="w-full">
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="configure">Configure</TabsTrigger>
            <TabsTrigger value="train">Train</TabsTrigger>
            <TabsTrigger value="test">Test</TabsTrigger>
          </TabsList>
          <TabsContent value="configure" className="mt-4">
            <ConfigureTab
              initialConfig={assistantConfig}
              assistantId={assistantId}
            />
          </TabsContent>
          <TabsContent value="train" className="mt-4">
            <TrainTab assistantId={assistantId} />
          </TabsContent>
          <TabsContent value="test" className="mt-4">
            <TestTab assistantId={assistantId} />
          </TabsContent>
        </Tabs>
      ) : (
         <p>Could not load assistant configuration.</p> // Fallback if config is null but no error message
      )}
      
      {assistantId && <ToolListModal assistantId={assistantId} />}
    </div>
  );
}

================
File: app/api/call-logs/route.ts
================
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';

interface CallInfo {
  callId: string;
  createdAt: string;
  endedAt: string | null;
  endedReason: string | null;
  transcript: string | null;
  summary: string | null;
  structuredData: Record<string, unknown> | null;
}

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const assistantId = searchParams.get('assistantId');

  if (!assistantId) {
    return NextResponse.json(
      { error: 'assistantId is required' },
      { status: 400 }
    );
  }

  try {
    // Initialize the Vapi client with the API key
    const client = new VapiClient({ 
      token: process.env.VAPI_API_KEY || '' 
    });

    // Get calls for this assistant
    const calls = await client.calls.list({ assistantId, limit: 50 });
    console.log(`Found ${calls.length} calls for assistant ${assistantId}`);

    // Fetch detailed information for each call
    const detailedCalls: CallInfo[] = [];
    
    for (const basicCall of calls) {
      if (!basicCall.id) continue;
      
      try {
        const detailedCall = await client.calls.get(basicCall.id);
        
        detailedCalls.push({
          callId: detailedCall.id,
          createdAt: detailedCall.createdAt as string,
          endedAt: detailedCall.endedAt as string | null,
          endedReason: detailedCall.endedReason as string | null,
          transcript: detailedCall.artifact?.transcript as string | null,
          summary: detailedCall.analysis?.summary as string | null,
          structuredData: detailedCall.analysis?.structuredData as Record<string, unknown> | null,
        });
        
        console.log(`Fetched details for call: ${detailedCall.id}`);
      } catch (callDetailError) {
        console.error(`Error fetching details for call ${basicCall.id}:`, callDetailError);
      }
    }

    if (detailedCalls.length > 0) {
      return NextResponse.json(detailedCalls);
    }

    // If no calls were found or fetched, fall back to mock data
    console.log('No calls found or unable to fetch details, returning mock data');
    
    // Sample transcript for the mock call
    const sampleTranscript = `AI: Hello, this is Laine from Aero Dental. How can I assist you with scheduling an appointment today?
User: Hey, I'd like to book a cleaning.
AI: Certainly. May I have your full name, please?
User: John Daniel.
AI: Thank you, John Daniel. What will be the purpose of your visit? For example, a cleaning, filling, consultation?
User: Cleaning.
AI: Thank you. Are you a new or existing patient?
User: A new patient.
AI: Great. May I please have your email address and phone number for confirmation?
User: John daniel at g mail dot com.
AI: Thank you, John. And what phone number can we reach you at?
User: 9, double 8, double 6, 3 9 8 0 9.
AI: Thank you for providing that information. To confirm you're scheduling a cleaning appointment as a new patient, Your email is John Daniel at gmail dot com and your phone number is 9 8 8 6 3 9 8 0 9. What date and time would you prefer for your appointment?
User: I'd like to schedule an appointment for April third, 1 30 PM.
AI: I apologize, but we do not have availability at 1 30 pm on April third. However, we do have openings at 1 PM and 3 PM that day. Would either of those work for you?
User: Yes, please.
AI: Thank you. I will schedule your appointment for April third at 1 PM for a cleaning. To confirm, name, John Daniel. Appointment date, April third. Time, 1 PM. Reason, cleaning. Email, john danielgmail dot com. Phone, 9 8 8 6 3 9 8 0 9. Is everything correct?
User: Yes.
AI: Thank you, John. Your appointment is confirmed for April third at 1 PM for a cleaning. We look forward to seeing you. If you have any further questions, feel free to reach out. Have a great day.
User: Thank you.
AI: You're welcome, John. Have a wonderful day.`;

    // Return mock data for demo purposes
    const mockCalls: CallInfo[] = [
      {
        callId: "call_01abc123def456",
        createdAt: new Date(Date.now() - 120000).toISOString(), // 2 minutes ago
        endedAt: new Date(Date.now() - 30000).toISOString(), // 30 seconds ago
        endedReason: "completed",
        transcript: sampleTranscript,
        summary: "John Daniel, a new patient, called to schedule a cleaning appointment. After checking availability, an appointment was booked for April 3rd at 1:00 PM. Contact info: email: john.daniel@gmail.com, phone: 9886398009.",
        structuredData: {
          patientName: "John Daniel",
          patientType: "new",
          appointmentType: "cleaning",
          scheduledDate: "2025-04-03T13:00:00.000Z",
          contactEmail: "john.daniel@gmail.com",
          contactPhone: "9886398099"
        }
      }
    ];

    return NextResponse.json(mockCalls);
  } catch (error) {
    console.error('Error fetching calls:', error);
    
    // If there's an error with the API, return a sample call log
    const sampleTranscript = `AI: Hello, this is Laine from Aero Dental. How can I assist you with scheduling an appointment today?
User: Hey, I'd like to book a cleaning.
AI: Certainly. May I have your full name, please?
User: John Daniel.
AI: Thank you, John Daniel. What will be the purpose of your visit? For example, a cleaning, filling, consultation?
User: Cleaning.
AI: Thank you. Are you a new or existing patient?
User: A new patient.
AI: Great. May I please have your email address and phone number for confirmation?
User: John daniel at g mail dot com.
AI: Thank you, John. And what phone number can we reach you at?
User: 9, double 8, double 6, 3 9 8 0 9.
AI: Thank you for providing that information. To confirm you're scheduling a cleaning appointment as a new patient, Your email is John Daniel at gmail dot com and your phone number is 9 8 8 6 3 9 8 0 9. What date and time would you prefer for your appointment?
User: I'd like to schedule an appointment for April third, 1 30 PM.
AI: I apologize, but we do not have availability at 1 30 pm on April third. However, we do have openings at 1 PM and 3 PM that day. Would either of those work for you?
User: Yes, please.
AI: Thank you. I will schedule your appointment for April third at 1 PM for a cleaning. To confirm, name, John Daniel. Appointment date, April third. Time, 1 PM. Reason, cleaning. Email, john danielgmail dot com. Phone, 9 8 8 6 3 9 8 0 9. Is everything correct?
User: Yes.
AI: Thank you, John. Your appointment is confirmed for April third at 1 PM for a cleaning. We look forward to seeing you. If you have any further questions, feel free to reach out. Have a great day.
User: Thank you.
AI: You're welcome, John. Have a wonderful day.`;

    // Return mock data for error fallback
    const errorFallbackCalls: CallInfo[] = [
      {
        callId: "call_error_fallback",
        createdAt: new Date().toISOString(),
        endedAt: new Date().toISOString(),
        endedReason: "completed",
        transcript: sampleTranscript,
        summary: "API Error: Using fallback sample call. John Daniel, a new patient, called to schedule a cleaning appointment. After checking availability, an appointment was booked for April 3rd at 1:00 PM.",
        structuredData: {
          error: "Failed to fetch real call data",
          fallback: true
        }
      }
    ];
    
    return NextResponse.json(errorFallbackCalls);
  }
}

================
File: app/api/get-assistant-tools/route.ts
================
import { NextResponse } from 'next/server';
import { VapiClient } from '@vapi-ai/server-sdk';

const VAPI_API_KEY = process.env.VAPI_API_KEY;

// Simplified interface for Vapi Tool structure
interface VapiTool {
  id?: string;
  type: string;
  function?: {
    name?: string;
    description?: string;
    // Add other function properties if needed
    parameters?: Record<string, unknown>;
  };
  // Some tool types might have description at the root level
  description?: string;
  destinations?: string[];
  knowledgeBases?: string[];
  // Add other potential root-level tool properties if needed
}

export async function GET(request: Request) {
  // --- Basic Setup & Validation ---
  if (!VAPI_API_KEY) {
    console.error("VAPI_API_KEY is not set in environment variables.");
    return NextResponse.json({ error: 'Server configuration error: API key missing' }, { status: 500 });
  }

  const { searchParams } = new URL(request.url);
  const assistantId = searchParams.get('id');

  if (!assistantId) {
    console.error("Request missing assistantId query parameter.");
    return NextResponse.json({ error: 'assistantId is required' }, { status: 400 });
  }

  console.log(`[get-assistant-tools] Received request for assistantId: ${assistantId}`);

  try {
    // Initialize Vapi Client
    const vapi = new VapiClient({ token: VAPI_API_KEY });

    // --- Fetch Assistant Configuration ---
    console.log(`[get-assistant-tools] Fetching assistant configuration for ID: ${assistantId}`);
    const assistant = await vapi.assistants.get(assistantId);

    if (!assistant || !assistant.model) {
      console.log(`[get-assistant-tools] Assistant ${assistantId} not found or has no model configuration.`);
      // Return empty list if assistant or model config is missing
      return NextResponse.json({ tools: [] });
    }
    console.log(`[get-assistant-tools] Successfully fetched assistant configuration for ${assistantId}.`);

    const toolList: VapiTool[] = [];

    // --- Process Transient Tools (assistant.model.tools) ---
    if (Array.isArray(assistant.model.tools)) {
      console.log(`[get-assistant-tools] Processing ${assistant.model.tools.length} transient tools.`);
      for (const tool of assistant.model.tools as VapiTool[]) { // Cast to your defined interface
        // Add the full tool object
        toolList.push({
          ...tool,
          // Add a generated name/description if not already present
          function: {
            ...tool.function,
            name: tool.function?.name || tool.type,
            description: tool.function?.description || tool.description || `A ${tool.type} tool.`
          }
        });
      }
    } else {
      console.log('[get-assistant-tools] No transient tools found in assistant.model.tools.');
    }

    // --- Process Tools by ID (assistant.model.toolIds) ---
    if (Array.isArray(assistant.model.toolIds) && assistant.model.toolIds.length > 0) {
      console.log(`[get-assistant-tools] Processing ${assistant.model.toolIds.length} tool IDs: ${assistant.model.toolIds.join(', ')}.`);
      const toolDetailPromises = assistant.model.toolIds.map(toolId =>
        vapi.tools.get(toolId)
          .then(toolData => {
            if (toolData) {
              console.log(`[get-assistant-tools] Successfully fetched details for tool ID: ${toolId}`);
              // Return the full tool data
              return toolData as unknown as VapiTool;
            }
            console.warn(`[get-assistant-tools] Tool data for ID ${toolId} was unexpectedly null or undefined.`);
            return null; // Explicitly return null if data is missing
          })
          .catch(err => {
            console.error(`[get-assistant-tools] Failed to fetch tool ${toolId}:`, err instanceof Error ? err.message : err);
            return null; // Return null on fetch error to not break Promise.all
          })
      );

      const toolDetails = await Promise.all(toolDetailPromises);

      // Add successfully fetched tools to the list
      for (const tool of toolDetails) {
        if (tool) {
          toolList.push(tool);
        }
      }
      console.log('[get-assistant-tools] Finished processing tool IDs.');
    } else {
      console.log('[get-assistant-tools] No tool IDs found in assistant.model.toolIds.');
    }

    // --- Deduplicate and Return ---
    // Use tool ID for uniqueness if available, otherwise use type + function name as a composite key
    const uniqueToolMap = new Map<string, VapiTool>();
    for (const tool of toolList) {
      const key = tool.id || `${tool.function?.name || ''}-${tool.type}`; // Use ID if present, else composite key
      if (!uniqueToolMap.has(key)) {
        uniqueToolMap.set(key, tool);
      }
    }

    const uniqueToolList = Array.from(uniqueToolMap.values());
    console.log(`[get-assistant-tools] Returning ${uniqueToolList.length} unique tools for assistant ${assistantId}.`);

    return NextResponse.json({ tools: uniqueToolList });

  } catch (error) {
    console.error('[get-assistant-tools] Unexpected error fetching assistant tools:', error);
    const message = error instanceof Error ? error.message : 'Unknown server error occurred';
    return NextResponse.json({ error: 'Internal Server Error', details: message }, { status: 500 });
  }
}

================
File: app/api/users/route.ts
================
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { PrismaClient } from '@prisma/client'
import type { Role } from '@prisma/client'

const prismaClient = new PrismaClient()

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    const roleParam = searchParams.get('role')
    
    // Set up filter with proper typing
    const filter = roleParam ? { role: roleParam as Role } : {}
    
    const users = await prismaClient.user.findMany({
      where: filter,
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
      },
      orderBy: {
        name: 'asc',
      },
    })
    
    return NextResponse.json(users)
  } catch (error) {
    console.error('Error fetching users:', error)
    return NextResponse.json(
      { error: 'Failed to fetch users' },
      { status: 500 }
    )
  }
}

export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { name, email, role } = body
    
    const user = await prisma.user.create({
      data: {
        name,
        email,
        role: role || 'USER',
      },
    })
    
    return NextResponse.json(user, { status: 201 })
  } catch (error) {
    console.error('Error creating user:', error)
    return NextResponse.json(
      { error: 'Failed to create user' },
      { status: 500 }
    )
  }
}

================
File: app/api/appointments/route.ts
================
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Validate if the appointment time is within business hours - now ANY time is allowed
function isValidAppointmentTime(): { valid: boolean; message?: string } {
  // Always return valid for demo purposes
  return { valid: true };
}

// GET all appointments with patient details
export async function GET() {
  try {
    const appointments = await prisma.appointment.findMany({
      include: {
        patient: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
      orderBy: {
        date: 'asc',
      },
    });

    return NextResponse.json(appointments);
  } catch (error) {
    console.error('Error fetching appointments:', error);
    return NextResponse.json({ error: 'Failed to fetch appointments' }, { status: 500 });
  }
}

// POST new appointment
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { date, patientId, reason, patientType, notes } = body;

    // Validate required fields
    if (!date || !patientId || !reason) {
      return NextResponse.json(
        { error: 'Missing required fields: date, patientId, and reason are required' },
        { status: 400 }
      );
    }

    // Parse the appointment date
    const appointmentDate = new Date(date);
    
    // Validate that the appointment time is within business hours
    const timeValidation = isValidAppointmentTime();
    if (!timeValidation.valid) {
      console.error('Appointment validation failed:', timeValidation.message);
      return NextResponse.json(
        { error: timeValidation.message },
        { status: 400 }
      );
    }

    // Create new appointment
    const appointment = await prisma.appointment.create({
      data: {
        date: appointmentDate,
        patientId,
        reason,
        patientType: patientType || 'EXISTING',
        notes: notes || '',
        status: 'SCHEDULED',
      },
      include: {
        patient: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    return NextResponse.json(appointment);
  } catch (error) {
    console.error('Error creating appointment:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('Detailed error:', errorMessage);
    return NextResponse.json({ error: `Failed to create appointment: ${errorMessage}` }, { status: 500 });
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

/docs

scripts

================
File: app/calendar/page.tsx
================
"use client";

import { useState, useEffect } from 'react';

// Define types
type Appointment = {
  id: string;
  date: Date;
  reason: string;
  patientType: 'NEW' | 'EXISTING';
  status: 'SCHEDULED' | 'CONFIRMED' | 'CANCELLED' | 'COMPLETED';
  notes?: string;
  patient: {
    firstName: string;
    lastName: string;
  };
};

type AppointmentFormData = {
  date: string;
  time: string;
  patientId: string;
  reason: string;
  patientType: 'NEW' | 'EXISTING';
  notes: string;
  // New patient fields
  newPatientFirstName: string;
  newPatientLastName: string;
  newPatientEmail: string;
  newPatientPhone: string;
};

type Patient = {
  id: string;
  firstName: string;
  lastName: string;
  email?: string;
  phoneNumber?: string;
};

// Define appointment data coming from API
interface AppointmentData {
  id: string;
  date: string;
  reason: string;
  patientType: 'NEW' | 'EXISTING';
  status: 'SCHEDULED' | 'CONFIRMED' | 'CANCELLED' | 'COMPLETED';
  notes?: string;
  patient: {
    firstName: string;
    lastName: string;
  };
}

const CalendarPage = () => {
  const [appointments, setAppointments] = useState<Appointment[]>([]);
  const [patients, setPatients] = useState<Patient[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [formData, setFormData] = useState<AppointmentFormData>({
    date: new Date().toISOString().split('T')[0],
    time: '09:00',
    patientId: '',
    reason: '',
    patientType: 'EXISTING',
    notes: '',
    newPatientFirstName: '',
    newPatientLastName: '',
    newPatientEmail: '',
    newPatientPhone: '',
  });
  
  // Time slots for the entire day with 30-minute intervals (24/7 for demo)
  const timeSlots = [
    '00:00', '00:30', '01:00', '01:30', '02:00', '02:30', '03:00', '03:30', 
    '04:00', '04:30', '05:00', '05:30', '06:00', '06:30', '07:00', '07:30', 
    '08:00', '08:30', '09:00', '09:30', '10:00', '10:30', '11:00', '11:30', 
    '12:00', '12:30', '13:00', '13:30', '14:00', '14:30', '15:00', '15:30', 
    '16:00', '16:30', '17:00', '17:30', '18:00', '18:30', '19:00', '19:30', 
    '20:00', '20:30', '21:00', '21:30', '22:00', '22:30', '23:00', '23:30'
  ];

  // Load appointments and patients
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const appointmentsRes = await fetch('/api/appointments');
        if (!appointmentsRes.ok) throw new Error('Failed to fetch appointments');
        
        const patientsRes = await fetch('/api/patients');
        if (!patientsRes.ok) throw new Error('Failed to fetch patients');
        
        const appointmentsData = await appointmentsRes.json();
        const patientsData = await patientsRes.json();
        
        // Add parsing of appointment dates here, since they come as strings from the API
        const parsedAppointments = appointmentsData.map((apt: AppointmentData) => ({
          ...apt,
          date: new Date(apt.date)
        }));
        
        setAppointments(parsedAppointments);
        setPatients(patientsData);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
        console.error('Error fetching data:', err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, []);
  
  // Handle form input changes
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };
  
  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      // Combine date and time
      const dateTime = new Date(`${formData.date}T${formData.time}`);
      
      let patientId = formData.patientId;
      
      // If new patient, create the patient first
      if (formData.patientType === 'NEW') {
        if (!formData.newPatientFirstName || !formData.newPatientLastName) {
          setError('First name and last name are required for new patients');
          return;
        }
        
        // Get the first dentist (assuming we have at least one)
        const usersRes = await fetch('/api/users?role=DENTIST');
        const users = await usersRes.json();
        
        if (users.length === 0) {
          setError('No dentist found in the system');
          return;
        }
        
        const dentistId = users[0].id;
        
        // Create the new patient
        const patientRes = await fetch('/api/patients', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            firstName: formData.newPatientFirstName,
            lastName: formData.newPatientLastName,
            email: formData.newPatientEmail || null,
            phoneNumber: formData.newPatientPhone || null,
            userId: dentistId
          }),
        });
        
        if (!patientRes.ok) {
          throw new Error('Failed to create new patient');
        }
        
        const newPatient = await patientRes.json();
        patientId = newPatient.id;
        
        // Add the new patient to the local state
        setPatients(prev => [...prev, newPatient]);
      } else if (!formData.patientId) {
        setError('Please select a patient');
        return;
      }
      
      // Create the appointment
      const response = await fetch('/api/appointments', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          date: dateTime.toISOString(),
          patientId,
          reason: formData.reason,
          patientType: formData.patientType,
          notes: formData.notes,
        }),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create appointment');
      }
      
      // Get the new appointment data and add it to the local state
      const newAppointment = await response.json();
      setAppointments(prev => [...prev, { ...newAppointment, date: new Date(newAppointment.date) }]);
      
      // Close form and reset
      setIsFormOpen(false);
      setError(null);
      
      // Reset form data
      setFormData({
        date: new Date().toISOString().split('T')[0],
        time: '09:00',
        patientId: '',
        reason: '',
        patientType: 'EXISTING',
        notes: '',
        newPatientFirstName: '',
        newPatientLastName: '',
        newPatientEmail: '',
        newPatientPhone: '',
      });
      
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
      console.error('Error creating appointment:', err);
    }
  };
  
  // Delete an appointment
  const handleDelete = async (id: string) => {
    if (!confirm('Are you sure you want to delete this appointment?')) {
      return;
    }
    
    try {
      const response = await fetch(`/api/appointments/${id}`, {
        method: 'DELETE',
      });
      
      if (!response.ok) {
        throw new Error('Failed to delete appointment');
      }
      
      // Update local state
      setAppointments(prev => prev.filter(apt => apt.id !== id));
      setError(null);
      
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
      console.error('Error deleting appointment:', err);
    }
  };
  
  // Group appointments by day
  const appointmentsByDay = appointments.reduce((acc, appointment) => {
    const day = appointment.date.toISOString().split('T')[0];
    if (!acc[day]) {
      acc[day] = [];
    }
    acc[day].push(appointment);
    return acc;
  }, {} as Record<string, Appointment[]>);
  
  if (loading) {
    return <div className="flex justify-center p-8">Loading calendar...</div>;
  }

  return (
    <div className="container mx-auto p-4">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Appointment Calendar</h1>
        <div className="flex gap-4">
          <button 
            onClick={() => setIsFormOpen(true)}
            type="button"
            className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Add Appointment
          </button>
          <a 
            href="/patients"
            className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
          >
            View Patients
          </a>
          <a 
            href="/check-availability"
            className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700"
          >
            Check Availability
          </a>
        </div>
      </div>
      
      {error && (
        <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-6">
          <p>{error}</p>
        </div>
      )}
      
      {/* Appointment Form */}
      {isFormOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg w-full max-w-md">
            <h2 className="text-xl font-bold mb-4">New Appointment</h2>
            
            <div className="mb-4 p-4 bg-blue-50 rounded shadow-sm">
              <h3 className="font-semibold text-blue-800 mb-2">Appointment Information</h3>
              <ul className="list-disc list-inside text-sm pl-2">
                <li className="mb-1">Hours: 24/7 - ANY day, ANY time (for demo purposes)</li>
                <li className="mb-1">Appointments are scheduled in 30-minute slots</li>
                <li>All times are displayed in your local timezone</li>
              </ul>
            </div>
            
            <form onSubmit={handleSubmit}>
              <div className="space-y-4">
                <div>
                  <label htmlFor="date" className="block text-sm font-medium mb-1">Date</label>
                  <input
                    id="date"
                    type="date"
                    name="date"
                    value={formData.date}
                    onChange={handleChange}
                    className="w-full p-2 border rounded"
                    required
                  />
                </div>
                
                <div>
                  <label htmlFor="time" className="block text-sm font-medium mb-1">Time</label>
                  <select
                    id="time"
                    name="time"
                    value={formData.time}
                    onChange={handleChange}
                    className="w-full p-2 border rounded"
                    required
                  >
                    {timeSlots.map(time => (
                      <option key={time} value={time}>
                        {time}
                      </option>
                    ))}
                  </select>
                </div>
                
                <div>
                  <label htmlFor="patientType" className="block text-sm font-medium mb-1">Patient Type</label>
                  <select
                    id="patientType"
                    name="patientType"
                    value={formData.patientType}
                    onChange={handleChange}
                    className="w-full p-2 border rounded"
                  >
                    <option value="EXISTING">Existing Patient</option>
                    <option value="NEW">New Patient</option>
                  </select>
                </div>
                
                {formData.patientType === 'EXISTING' ? (
                  <div>
                    <label htmlFor="patientId" className="block text-sm font-medium mb-1">Patient</label>
                    <select
                      id="patientId"
                      name="patientId"
                      value={formData.patientId}
                      onChange={handleChange}
                      className="w-full p-2 border rounded"
                      required={formData.patientType === 'EXISTING'}
                    >
                      <option value="">Select a patient</option>
                      {patients.map(patient => (
                        <option key={patient.id} value={patient.id}>
                          {patient.firstName} {patient.lastName}
                        </option>
                      ))}
                    </select>
                  </div>
                ) : (
                  <div className="space-y-3 border-t border-b py-3">
                    <h3 className="font-medium">New Patient Information</h3>
                    
                    <div>
                      <label htmlFor="newPatientFirstName" className="block text-sm font-medium mb-1">First Name</label>
                      <input
                        id="newPatientFirstName"
                        type="text"
                        name="newPatientFirstName"
                        value={formData.newPatientFirstName}
                        onChange={handleChange}
                        className="w-full p-2 border rounded"
                        required={formData.patientType === 'NEW'}
                      />
                    </div>
                    
                    <div>
                      <label htmlFor="newPatientLastName" className="block text-sm font-medium mb-1">Last Name</label>
                      <input
                        id="newPatientLastName"
                        type="text"
                        name="newPatientLastName"
                        value={formData.newPatientLastName}
                        onChange={handleChange}
                        className="w-full p-2 border rounded"
                        required={formData.patientType === 'NEW'}
                      />
                    </div>
                    
                    <div>
                      <label htmlFor="newPatientEmail" className="block text-sm font-medium mb-1">Email</label>
                      <input
                        id="newPatientEmail"
                        type="email"
                        name="newPatientEmail"
                        value={formData.newPatientEmail}
                        onChange={handleChange}
                        className="w-full p-2 border rounded"
                      />
                    </div>
                    
                    <div>
                      <label htmlFor="newPatientPhone" className="block text-sm font-medium mb-1">Phone Number</label>
                      <input
                        id="newPatientPhone"
                        type="tel"
                        name="newPatientPhone"
                        value={formData.newPatientPhone}
                        onChange={handleChange}
                        className="w-full p-2 border rounded"
                      />
                    </div>
                  </div>
                )}
                
                <div>
                  <label htmlFor="reason" className="block text-sm font-medium mb-1">Reason</label>
                  <input
                    id="reason"
                    type="text"
                    name="reason"
                    value={formData.reason}
                    onChange={handleChange}
                    className="w-full p-2 border rounded"
                    required
                  />
                </div>
                
                <div>
                  <label htmlFor="notes" className="block text-sm font-medium mb-1">Notes</label>
                  <textarea
                    id="notes"
                    name="notes"
                    value={formData.notes}
                    onChange={handleChange}
                    className="w-full p-2 border rounded"
                    rows={3}
                  />
                </div>
              </div>
              
              <div className="flex justify-end space-x-2 mt-6">
                <button
                  type="button"
                  onClick={() => setIsFormOpen(false)}
                  className="px-4 py-2 border rounded text-gray-600 hover:bg-gray-100"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                  Save Appointment
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
      
      {/* Calendar View */}
      <div className="space-y-6">
        {Object.entries(appointmentsByDay)
          .sort(([dayA], [dayB]) => dayA.localeCompare(dayB))
          .map(([day, dayAppointments]) => (
            <div key={day} className="border rounded-lg overflow-hidden">
              <div className="bg-gray-100 p-3 font-bold">
                {new Date(day).toLocaleDateString('en-US', {
                  weekday: 'long',
                  month: 'long',
                  day: 'numeric'
                })}
              </div>
              
              <div className="divide-y">
                {dayAppointments
                  .sort((a, b) => a.date.getTime() - b.date.getTime())
                  .map(appointment => (
                    <div key={appointment.id} className="p-4 flex justify-between items-start">
                      <div>
                        <div className="flex items-center">
                          <span className="font-medium">
                            {appointment.date.toLocaleString('en-US', {
                              hour: '2-digit',
                              minute: '2-digit',
                              hour12: true
                            })}
                          </span>
                          <span className={`ml-2 px-2 py-0.5 text-xs rounded ${
                            appointment.status === 'CONFIRMED' ? 'bg-green-100 text-green-800' :
                            appointment.status === 'CANCELLED' ? 'bg-red-100 text-red-800' :
                            appointment.status === 'COMPLETED' ? 'bg-blue-100 text-blue-800' :
                            'bg-yellow-100 text-yellow-800'
                          }`}>
                            {appointment.status}
                          </span>
                          <span className={`ml-2 px-2 py-0.5 text-xs rounded ${
                            appointment.patientType === 'NEW' ? 'bg-purple-100 text-purple-800' : 'bg-gray-100 text-gray-800'
                          }`}>
                            {appointment.patientType}
                          </span>
                        </div>
                        <div className="mt-1 font-bold">
                          {appointment.patient.firstName} {appointment.patient.lastName}
                        </div>
                        <div className="text-sm text-gray-600">{appointment.reason}</div>
                        {appointment.notes && (
                          <div className="mt-1 text-xs text-gray-500">{appointment.notes}</div>
                        )}
                      </div>
                      
                      <button
                        type="button"
                        onClick={() => handleDelete(appointment.id)}
                        className="text-red-600 hover:text-red-800"
                      >
                        Delete
                      </button>
                    </div>
                  ))}
              </div>
            </div>
          ))}
          
        {Object.keys(appointmentsByDay).length === 0 && (
          <div className="p-8 text-center text-gray-500">
            No appointments found. Create a new appointment to get started.
          </div>
        )}
      </div>
    </div>
  );
};

export default CalendarPage;

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist } from "next/font/google";
import "./globals.css";
import { Sidebar } from "@/components/sidebar";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Laine | AiroDental",
  description: "Laine - AI Voice Receptionist for Dental Practices",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} antialiased`}>
        <div className="flex min-h-screen flex-col md:flex-row">
          <Sidebar />
          <main className="flex-1">{children}</main>
        </div>
      </body>
    </html>
  );
}

================
File: app/check-availability/page.tsx
================
'use client';

import { useState, useEffect } from 'react';
import axios from 'axios';
import Link from 'next/link';

// Define interfaces for the API response
interface ApiResult {
  tool_call_id?: string;
  toolCallId?: string;
  status?: string;
  message?: string;
  result?: string;
  error?: string;
}

interface ApiResponse {
  results?: ApiResult[];
  tool_call_id?: string;
  status?: string;
  message?: string;
  error?: string;
}

interface Appointment {
  id: string;
  date: string;
  status: string;
  patient: {
    firstName: string;
    lastName: string;
  };
}

export default function CheckAvailability() {
  const [date, setDate] = useState(new Date().toISOString().split('T')[0]);
  const [time, setTime] = useState('09:00');
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState('');
  const [error, setError] = useState('');
  const [rawData, setRawData] = useState<ApiResponse | null>(null);
  const [currentAppointments, setCurrentAppointments] = useState<Appointment[]>([]);

  // Available time slots (30-minute intervals)
  const timeSlots = [
    '00:00', '00:30', '01:00', '01:30', '02:00', '02:30', '03:00', '03:30', 
    '04:00', '04:30', '05:00', '05:30', '06:00', '06:30', '07:00', '07:30', 
    '08:00', '08:30', '09:00', '09:30', '10:00', '10:30', '11:00', '11:30', 
    '12:00', '12:30', '13:00', '13:30', '14:00', '14:30', '15:00', '15:30', 
    '16:00', '16:30', '17:00', '17:30', '18:00', '18:30', '19:00', '19:30', 
    '20:00', '20:30', '21:00', '21:30', '22:00', '22:30', '23:00', '23:30'
  ];

  // Fetch current appointments on component mount
  useEffect(() => {
    const fetchAppointments = async () => {
      try {
        const response = await axios.get('/api/appointments');
        console.log('Raw appointments data:', response.data);
        setCurrentAppointments(response.data);
      } catch (err) {
        console.error('Error fetching appointments:', err);
      }
    };
    fetchAppointments();
  }, []);

  const handleCheck = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    setResult('');
    setRawData(null);

    try {
      // Combine date and time into ISO format
      const startDate = new Date(`${date}T${time}`).toISOString();
      
      // Create payload for the API
      const payload = {
        tool_call_id: "check-from-ui",
        parameters: {
          startDate
        }
      };

      console.log('Sending payload:', payload);

      // Make API call to the local endpoint for faster development testing
      const apiUrl = window.location.hostname === 'localhost' 
        ? 'http://localhost:3000/api/laine/check-availability'
        : 'https://laine-core.vercel.app/api/laine/check-availability';
        
      const response = await axios.post(
        apiUrl,
        payload,
        {
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          timeout: 10000
        }
      );

      // Handle response
      console.log('API response:', response.data);
      setRawData(response.data);
      
      if (response.status === 200) {
        if (response.data.message) {
          // New API format
          setResult(response.data.message);
        } else if (response.data.results?.[0]?.result) {
          // Old API format
          setResult(response.data.results[0].result);
        } else if (response.data.error || response.data.results?.[0]?.error) {
          // Error format
          setError(response.data.error || response.data.results?.[0]?.error || 'Unknown error');
        } else {
          setError("No clear result found in the response");
        }
      } else {
        setError(`Unexpected response status: ${response.status}`);
      }
    } catch (err) {
      console.error('Error checking availability:', err);
      if (axios.isAxiosError(err)) {
        const errorMessage = err.response?.data?.message || 
                           err.response?.data?.error || 
                           err.message;
        setError(`Failed to check availability: ${errorMessage}`);
        setRawData(err.response?.data || null);
      } else {
        setError('Failed to check availability. Please try again.');
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">Check Appointment Availability</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Left column - Input */}
        <div className="bg-white p-4 rounded shadow">
          <h2 className="text-lg font-semibold mb-4">Enter Date and Time</h2>
          
          <div className="mb-4 p-3 bg-blue-50 border-l-4 border-blue-500 text-blue-700">
            <p className="font-semibold">Appointment Information:</p>
            <ul className="list-disc list-inside mt-1 text-sm">
              <li>Hours: 24/7 - ANY day, ANY time (for demo purposes)</li>
              <li>Appointments are scheduled in 30-minute slots</li>
              <li>All times are displayed in your local timezone</li>
            </ul>
          </div>
          
          <form onSubmit={handleCheck} className="space-y-4">
            <div>
              <label htmlFor="date" className="block mb-1">Date</label>
              <input
                id="date"
                type="date"
                value={date}
                onChange={(e) => setDate(e.target.value)}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label htmlFor="time" className="block mb-1">Time</label>
              <select
                id="time"
                value={time}
                onChange={(e) => setTime(e.target.value)}
                className="w-full p-2 border rounded"
                required
              >
                {timeSlots.map(slot => (
                  <option key={slot} value={slot}>{slot}</option>
                ))}
              </select>
            </div>
            <button
              type="submit"
              disabled={loading}
              className={`w-full p-2 rounded ${
                loading
                  ? 'bg-gray-400'
                  : 'bg-blue-500 hover:bg-blue-600 text-white'
              }`}
            >
              {loading ? 'Checking...' : 'Check Availability'}
            </button>
          </form>
          
          <div className="mt-4">
            <p className="text-xs text-gray-500">
              Selected date and time in ISO format: 
              {date && time ? new Date(`${date}T${time}`).toISOString() : 'None selected'}
            </p>
          </div>
        </div>
        
        {/* Right column - Results */}
        <div className="bg-white p-4 rounded shadow">
          <h2 className="text-lg font-semibold mb-4">Availability Results</h2>
          
          {error && (
            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-4">
              <p>{error}</p>
            </div>
          )}
          
          {result && (
            <div className="bg-green-100 border-l-4 border-green-500 text-green-700 p-4">
              <p>{result}</p>
            </div>
          )}
          
          {!error && !result && !loading && (
            <p className="text-gray-500">Select a date and time to check availability</p>
          )}
          
          {loading && <p className="text-blue-500">Checking availability...</p>}
        </div>
      </div>
      
      {/* Raw Response Data */}
      <div className="mt-8 bg-white p-4 rounded shadow">
        <h2 className="text-lg font-semibold mb-4">Raw Response Data</h2>
        {rawData ? (
          <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96 text-sm">
            {JSON.stringify(rawData, null, 2)}
          </pre>
        ) : (
          <p className="text-gray-500">No data available</p>
        )}
      </div>

      {/* Current Appointments */}
      <div className="mt-8 bg-white p-4 rounded shadow">
        <h2 className="text-lg font-semibold mb-4">Current Appointments</h2>
        {currentAppointments.length > 0 ? (
          <>
            <div className="overflow-x-auto mb-4">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Patient</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {currentAppointments.map((appointment) => (
                    <tr key={appointment.id}>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {new Date(appointment.date).toLocaleString()}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {appointment.patient.firstName} {appointment.patient.lastName}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {appointment.status}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
            
            {/* Raw Appointments Data */}
            <div className="mt-4">
              <h3 className="text-md font-semibold mb-2">Raw Appointments Data</h3>
              <pre className="bg-gray-100 p-4 rounded overflow-auto max-h-96 text-sm">
                {JSON.stringify(currentAppointments, null, 2)}
              </pre>
            </div>
          </>
        ) : (
          <div>
            <p className="text-gray-500 mb-4">No appointments found</p>
            <a 
              href="/calendar"
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Go to Calendar to Add Appointments
            </a>
          </div>
        )}
      </div>
      
      <div className="mt-8 flex justify-between">
        <Link 
          href="/"
          className="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700"
        >
          Dashboard
        </Link>
        <a 
          href="/calendar"
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
        >
          Manage Appointments
        </a>
      </div>
    </div>
  );
}

================
File: app/demo/page.tsx
================
// app/demo/page.tsx
"use client";

import type { FC } from 'react';
import { Suspense } from 'react';
import { Placeholder } from '../../components/Placeholder';

const DemoPage: FC = () => {
  return (
    <main className="min-h-screen items-center justify-center p-4 md:p-10 lg:p-16">
      <Suspense fallback={<div>Loading...</div>}>
        <div className="mx-auto flex max-w-screen-2xl flex-col items-center">
          <h1 className="mb-8 text-4xl font-bold tracking-tight">Meet Laine Demo</h1>
          <div className="mb-4 w-full rounded-md bg-slate-50 p-4">
            <Placeholder className="h-[600px] w-full">Laine Demo</Placeholder>
          </div>
        </div>
      </Suspense>
    </main>
  );
};

export default DemoPage;

================
File: package.json
================
{
  "name": "laine-core",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "prisma generate && next build",
    "start": "next start",
    "lint": "next lint",
    "prisma:generate": "prisma generate",
    "prisma:push": "prisma db push",
    "prisma:migrate": "prisma migrate dev",
    "prisma:migrate:create": "prisma migrate dev --create-only",
    "prisma:deploy": "prisma migrate deploy",
    "prisma:studio": "prisma studio",
    "db:seed": "prisma db seed",
    "check-vapi-tools": "ts-node scripts/check-vapi-tools.ts",
    "setup-vapi-tools": "ts-node scripts/setup-vapi-tools.ts",
    "seed": "prisma db seed",
    "setup-vapi": "ts-node scripts/setup-vapi-tools.ts"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.6",
    "@ai-sdk/react": "^1.2.5",
    "@prisma/client": "^6.5.0",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@vapi-ai/server-sdk": "^0.5.1",
    "@vapi-ai/web": "^2.2.5",
    "ai": "^4.2.10",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.7",
    "lucide-react": "^0.486.0",
    "next": "15.2.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^3.1.0",
    "tw-animate-css": "^1.2.5",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20.17.30",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "axios": "^1.8.4",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "node-fetch": "^3.3.2",
    "prisma": "^6.5.0",
    "tailwindcss": "^4",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.3",
    "typescript": "^5"
  },
  "prisma": {
    "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
  }
}



================================================================
End of Codebase
================================================================
